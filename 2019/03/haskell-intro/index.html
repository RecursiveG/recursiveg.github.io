<!DOCTYPE HTML>
<html>
<head>
  <meta charset="UTF-8">
  
  <title>Haskell 简易指南 | RECURSIVE LAND</title>
  <meta name="author" content="RecursiveG" />
  
  <meta name="description" content="Recursive G&#39;s personal blog" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <meta property="og:title" content="Haskell 简易指南"/>
  <meta property="og:site_name" content="RECURSIVE LAND"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon" />
  <link rel="alternate" href="/atom.xml" title="RECURSIVE LAND" type="application/atom+xml" />
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css" />
  <script type="text/javascript"><!--Code to Prevent been iframed-->
    if(top.location!=self.location){alert('No iFrame Allowed!');top.location=self.location;}
  </script>
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script>
if((window.location.origin.indexOf("localhost")==-1)&&(window.location.origin.indexOf("127.0.0.1")==-1)){
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-37331447-3', 'auto');
	ga('send', 'pageview');
}
</script>


<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">RECURSIVE LAND</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/about">About</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="https://github.com/RecursiveG" target="_blank" rel="noopener">Github</a></li>
    
      <li><a href="/atom.xml">RSS</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-03-20T18:00:00.000Z"><a href="/2019/03/haskell-intro/">Mar 20 2019</a></time>
      
      
  
    <h1 class="title">Haskell 简易指南</h1>
  

    </header>
    <div class="entry">
      
        <h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>用任何你喜欢的方法安装 <a href="https://www.haskell.org/" target="_blank" rel="noopener">Glasgow Haskell Compiler</a> (a.k.a. GHC)。Cabal 之类的<br>依赖管理系统就用不着了。 <del>因为我也不会用。</del> 保证能够执行<code>ghc</code>和<code>ghci</code>命令就行。</p>
<h1 id="GHCi基础"><a href="#GHCi基础" class="headerlink" title="GHCi基础"></a>GHCi基础</h1><p>首先，把以下文件保存成<code>helloworld.hs</code>。</p>
<figure class="highlight haskell"><figcaption><span>helloworld.hs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> = <span class="string">"hello, world"</span></span><br></pre></td></tr></table></figure>
<p>然后执行<code>ghci helloworld.hs</code>，然后在<code>&gt;</code>提示符后输入<code>foo</code>并回车</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GHCi, version 8.6.3: http:&#x2F;&#x2F;www.haskell.org&#x2F;ghc&#x2F;  :? for help</span><br><span class="line">[1 of 1] Compiling Main             ( helloworld.hs, interpreted )</span><br><span class="line">Ok, one module loaded.</span><br><span class="line">*Main&gt; foo</span><br><span class="line">&quot;hello, world&quot;</span><br><span class="line">*Main&gt;</span><br></pre></td></tr></table></figure>
<p>你可以使用<code>:r</code>来重新载入文件，也可以使用<code>:l &lt;文件名&gt;</code>来载入代码。</p>
<a id="more"></a>

<h1 id="基础表达式"><a href="#基础表达式" class="headerlink" title="基础表达式"></a>基础表达式</h1><p>你可以修改你的代码文件，并在GHCi中观察程序行为。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里是注释</span></span><br><span class="line"></span><br><span class="line"><span class="title">foo</span> = <span class="string">"hello, world"</span>  <span class="comment">-- 名称绑定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义一个函数，返回参数加一</span></span><br><span class="line"><span class="title">plus1</span> x=x+<span class="number">1</span></span><br><span class="line"><span class="comment">-- 函数调用的格式为 &lt;函数名&gt; &lt;参数1&gt; &lt;参数2&gt; ……</span></span><br><span class="line"><span class="comment">-- *Main&gt; plus1 41</span></span><br><span class="line"><span class="comment">-- 42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 递归调用，定义的顺序很重要，在前面的定义优先考虑</span></span><br><span class="line"><span class="title">fact</span> <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="title">fact</span> n = n * fact (n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列表 (a.k.a. 数组)</span></span><br><span class="line"><span class="title">list1</span> = [<span class="string">"I"</span>, <span class="string">"am"</span>, <span class="string">"a"</span>, <span class="string">"list"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 元组</span></span><br><span class="line"><span class="title">tuple1</span> = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="title">triple1</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 元组的模式匹配</span></span><br><span class="line"><span class="title">sumOfTuple</span> (x1, x2) = x1+x2</span><br><span class="line"><span class="comment">-- *Main&gt; sumOfTuple tuple1</span></span><br><span class="line"><span class="comment">-- 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列表与列表合并</span></span><br><span class="line"><span class="title">list2</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">list3</span> = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="title">list4</span> = list2 ++ list3</span><br><span class="line"><span class="comment">-- *Main&gt; list4</span></span><br><span class="line"><span class="comment">-- [1,2,3,4,5,6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串是字符组成的列表</span></span><br><span class="line"><span class="title">str1</span> = <span class="string">"foo"</span> ++ ['b','a','r']</span><br><span class="line"><span class="comment">-- *Main&gt; str1</span></span><br><span class="line"><span class="comment">-- "foobar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列表头部插入, 以下四种表达方式等价</span></span><br><span class="line"><span class="title">list5</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">list6</span> = <span class="number">1</span>:[<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">list7</span> = <span class="number">1</span>:<span class="number">2</span>:[<span class="number">3</span>]</span><br><span class="line"><span class="title">list8</span> = <span class="number">1</span>:<span class="number">2</span>:<span class="number">3</span>:[]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列表的模式匹配</span></span><br><span class="line"><span class="title">sumOfList</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">sumOfList</span> (headElement:remainingElements) = headElement + sumOfList remainingElements</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 强制前缀表达式</span></span><br><span class="line"><span class="title">three</span> = (+) <span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 强制中缀表达式，mod为取模函数</span></span><br><span class="line"><span class="title">four</span> = <span class="number">18</span> `mod` <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数部分求值 (Partial application)，以下两个函数等价</span></span><br><span class="line"><span class="comment">-- 单引号没有特殊意义，是合法函数名的一部分</span></span><br><span class="line"><span class="title">plus2</span>  x = (+) <span class="number">2</span> x</span><br><span class="line"><span class="title">plus2'</span>   = (+) <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- if 条件 (类似三目运算符)</span></span><br><span class="line"><span class="title">five</span> = <span class="keyword">if</span> <span class="type">False</span> <span class="keyword">then</span> <span class="number">4</span> <span class="keyword">else</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- let 名称绑定</span></span><br><span class="line"><span class="title">six</span>  = <span class="keyword">let</span> x = <span class="number">7</span> <span class="keyword">in</span> x<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Guard</span></span><br><span class="line"><span class="title">sign</span> x</span><br><span class="line">    | x &lt; <span class="number">0</span>     = <span class="number">-1</span></span><br><span class="line">    | x == <span class="number">0</span>    = <span class="number">0</span></span><br><span class="line">    | otherwise = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数复合</span></span><br><span class="line"><span class="title">plus4</span>  x = plus2 (plus2 x)</span><br><span class="line"><span class="title">plus4'</span> x = (plus2 . plus2) x</span><br><span class="line"><span class="title">plus4''</span>  = plus2 . plus2</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Lambda表达式 (a.k.a. 匿名函数)</span></span><br><span class="line"><span class="title">sum'</span>  = (\x y -&gt; x+y)</span><br><span class="line"><span class="title">plus5</span> = (\x   -&gt; sum' x <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>这里仅列出了极少数基本用法。更多关于语言本身的以及数据结构的特定语法规则请参考相关Haskell教程。</p>
<h1 id="类型标记"><a href="#类型标记" class="headerlink" title="类型标记"></a>类型标记</h1><p>Haskell 是一门具有类型推导的静态类型语言。每个表达式都有自己的类型，在 GHCi 的交互模式下，可以使用<code>:t &lt;表达式&gt;</code>来检查表达式的类型。类型注记通常写为<code>&lt;表达式&gt; :: &lt;类型&gt;</code>。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 布尔型</span></span><br><span class="line">*<span class="type">Main</span>&gt; :t <span class="type">True</span></span><br><span class="line"><span class="type">True</span>::<span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 元组</span></span><br><span class="line">*<span class="type">Main</span>&gt; :t (<span class="type">True</span>, <span class="type">False</span>)</span><br><span class="line">(<span class="type">True</span>, <span class="type">False</span>) :: (<span class="type">Bool</span>, <span class="type">Bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列表</span></span><br><span class="line">*<span class="type">Main</span>&gt; :t <span class="string">"123"</span></span><br><span class="line"><span class="string">"123"</span> :: [<span class="type">Char</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数</span></span><br><span class="line">*<span class="type">Main</span>&gt; :t (+)</span><br><span class="line">(+) :: <span class="type">Num</span> a =&gt; a -&gt; a -&gt; a</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 部分求值后，新的函数只需要一个参数</span></span><br><span class="line">*<span class="type">Main</span>&gt; :t (+) <span class="number">1</span></span><br><span class="line">(+) <span class="number">1</span> :: <span class="type">Num</span> a =&gt; a -&gt; a</span><br></pre></td></tr></table></figure>
<p>函数类型以 <code>(参数1的类型) -&gt; (参数2的类型) -&gt; ... -&gt; (返回值的类型)</code> 形式表达。不明显区分参数和返回值。<code>Num</code>是代表数字的类型类，可以近似理解成Java中的接口。<code>Num a =&gt;</code> 表示 “在后续的类型定义中，<code>a</code>可以被替换成任何满足<code>Num</code>的类型”。整数<code>Int</code>和浮点数<code>Float</code>都是<code>Num</code>类型类的成员，所以加法函数既可以将整数相加，也可以将浮点数相加。</p>
<p>类型箭头都是右结合，但是你可以手动添加括号来改变类型的意义</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 接受一个整型参数，返回一个新函数。这个新函数接受一个整型，返回一个整型</span></span><br><span class="line"><span class="title">product'</span> :: <span class="type">Int</span> -&gt; (<span class="type">Int</span> -&gt; <span class="type">Int</span>)</span><br><span class="line"><span class="title">product'</span> x y = x * y</span><br><span class="line"><span class="title">timesThree</span> = product' <span class="number">3</span></span><br><span class="line"><span class="title">nine</span> = timesThree <span class="number">3</span></span><br><span class="line"><span class="title">nine'</span> = (product' <span class="number">3</span>) <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 接受一个参数，该参数是“接受一个整型，返回一个整型”的函数，然后返回一个整型</span></span><br><span class="line"><span class="title">some_func</span> :: (<span class="type">Int</span> -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">some_func</span> f = f <span class="number">42</span></span><br><span class="line"><span class="comment">-- *Main&gt; some_func (* 2)</span></span><br><span class="line"><span class="comment">-- 84</span></span><br></pre></td></tr></table></figure>

<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>Haskell 中定义新类型的基本语法是<code>data &lt;新类型名&gt; [类型参数..] = &lt;构造函数1&gt; [成员类型...] | &lt;构造函数2&gt; [成员类型...] | ...</code>。类型名和构造函数都需要首字母大写。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">NameAndAge</span> = <span class="type">MakeNameAndAge</span> <span class="type">String</span> <span class="type">Int</span></span></span><br><span class="line"><span class="comment">-- *Main&gt; :t MakeNameAndAge</span></span><br><span class="line"><span class="comment">-- MakeNameAndAge :: String -&gt; Int -&gt; NameAndAge</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">IntOrBool</span> = <span class="type">MakeInt</span> <span class="type">Int</span> | <span class="type">MakeBool</span> <span class="type">Bool</span></span></span><br><span class="line"><span class="comment">-- *Main&gt; :t MakeInt</span></span><br><span class="line"><span class="comment">-- MakeInt :: Int -&gt; IntOrBool</span></span><br><span class="line"><span class="comment">-- *Main&gt; :t MakeBool</span></span><br><span class="line"><span class="comment">-- MakeBool :: Bool -&gt; IntOrBool</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Weekends</span> = <span class="type">Saturday</span> | <span class="type">Sunday</span></span></span><br><span class="line"><span class="comment">-- Saturday :: Weekends</span></span><br><span class="line"><span class="comment">-- Sunday :: Weekends</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">TupleOf</span> a = <span class="type">MakeTupleOf</span> a a</span></span><br><span class="line"><span class="comment">-- MakeTupleOf :: a -&gt; a -&gt; TupleOf a</span></span><br><span class="line"><span class="comment">-- MakeTupleOf False True :: TupleOf Bool</span></span><br><span class="line"><span class="comment">-- MakeTupleOf 1 2 :: Num a =&gt; TupleOf a</span></span><br><span class="line"><span class="comment">-- MakeTupleOf plus1 plus2 :: Num a =&gt; TupleOf (a -&gt; a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 你可以使用函数的模式匹配来提取数据结构中的成员</span></span><br><span class="line"><span class="title">printNameAndAge</span> :: <span class="type">NameAndAge</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">printNameAndAge</span> (<span class="type">MakeNameAndAge</span> name age) =</span><br><span class="line">    <span class="string">"I'm "</span> ++ name ++ <span class="string">" and I'm "</span> ++ (show age) ++ <span class="string">" years old."</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 你也可以使用模式匹配来判断是哪一个构造函数</span></span><br><span class="line"><span class="title">printIntOrBool</span> :: <span class="type">IntOrBool</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">printIntOrBool</span> (<span class="type">MakeInt</span> n) = <span class="string">"Wow, an integer: "</span> ++ (show n)</span><br><span class="line"><span class="title">printIntOrBool</span> (<span class="type">MakeBool</span> b) = <span class="string">"Wow, a boolean: "</span> ++ (show b)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 你甚至可以进行递归类型定义 。当然，你需要一个终止条件。</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">ListOf</span> a = <span class="type">EmptyList</span> | <span class="type">AppendList</span> (<span class="type">ListOf</span> <span class="title">a</span>) a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 相关操作也需要使用递归函数来完成</span></span><br><span class="line"><span class="title">contains</span> :: (<span class="type">Eq</span> a) =&gt; <span class="type">ListOf</span> a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">contains</span> <span class="type">EmptyList</span> _ = <span class="type">False</span></span><br><span class="line"><span class="title">contains</span> (<span class="type">AppendList</span> list x') x =</span><br><span class="line">    <span class="keyword">if</span> x == x' <span class="keyword">then</span> <span class="type">True</span> <span class="keyword">else</span> contains list x</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为 ListOf a 类型实现 Eq 类型类</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Eq</span> a =&gt; <span class="type">Eq</span> (<span class="type">ListOf</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    <span class="type">EmptyList</span> == <span class="type">EmptyList</span>                   = <span class="type">True</span></span><br><span class="line">    (<span class="type">AppendList</span> l1 a1) == (<span class="type">AppendList</span> l2 a2) = a1 == a2 &amp;&amp; l1 == l2</span><br><span class="line">    _ == _                                   = <span class="type">False</span></span><br></pre></td></tr></table></figure>
<p>注意：<code>a</code>是一个类型，<code>ListOf a</code>是一个类型，但是 <strong><em>ListOf 不是类型，ListOf 不是类型，ListOf 不是类型。</em></strong> 这个定义表示：<code>ListOf a</code>满足<code>Eq</code> 仅当 <code>a</code>满足<code>Eq</code>。要查看类型的相关信息，可以在 GHCi 中执行<code>:info</code>指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*Main&gt; :info Eq</span><br><span class="line">class Eq a where</span><br><span class="line">  (&#x3D;&#x3D;) :: a -&gt; a -&gt; Bool</span><br><span class="line">  (&#x2F;&#x3D;) :: a -&gt; a -&gt; Bool</span><br><span class="line">  &#123;-# MINIMAL (&#x3D;&#x3D;) | (&#x2F;&#x3D;) #-&#125;</span><br><span class="line">  	-- Defined in ‘GHC.Classes’</span><br><span class="line">instance [safe] Eq a &#x3D;&gt; Eq (ListOf a) -- Defined at [omitted]</span><br><span class="line">[... omitted ...]</span><br></pre></td></tr></table></figure>

<h1 id="也许是个单子"><a href="#也许是个单子" class="headerlink" title="也许是个单子"></a>也许是个单子</h1><p><code>Maybe a</code>类似Java中的<code>Optional&lt;T&gt;</code>，常用于表示“会失败”的函数。</p>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Maybe</span> a = <span class="type">Nothing</span> | <span class="type">Just</span> a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一些函数</span></span><br><span class="line"><span class="title">func1</span> :: <span class="type">Float</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">func2</span> :: <span class="type">Int</span> -&gt; <span class="type">Maybe</span> <span class="type">Bool</span></span><br></pre></td></tr></table></figure>

<p><code>Monad</code>是个类型类</p>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; :info <span class="type">Monad</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad</span> (<span class="title">m</span> :: * -&gt; *) <span class="keyword">where</span></span></span><br><span class="line">  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line">  (&gt;&gt;) :: m a -&gt; m b -&gt; m b</span><br><span class="line">  return :: a -&gt; m a</span><br><span class="line">  fail :: <span class="type">String</span> -&gt; m a</span><br></pre></td></tr></table></figure>
<p>简化一下</p>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line">  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line">  return :: a -&gt; m a</span><br></pre></td></tr></table></figure>
<p>当我们说<code>Maybe</code>是一个<code>Monad</code>的时候，一方面指 Maybe 属于 Monad 这个类型类<code>instance Monad Maybe where ...</code>。另一方面指<code>Maybe(数据结构)</code>，<code>(&gt;&gt;=)::Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b (函数)</code>，<code>return::a -&gt; Maybe a (函数)</code>这三者构成了一个满足某些条件的数学结构，这些条件被称为<a href="https://wiki.haskell.org/Monad_laws" target="_blank" rel="noopener">Monad Laws</a>。事实上，Haskell编译器不会检查 Monad Laws 是否满足，你可以胡乱写一些数据结构和函数，然后将其塞入 Monad 这个类型类中。换句话说，Haskell中的Monad就是一个接口，任何实现接口的数据类型都可以称其为Monad。</p>
<p>回到<code>Maybe</code>上，现在你想把这两个会失败的函数连接在一起</p>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">func3</span> :: <span class="type">Float</span> -&gt; <span class="type">Maybe</span> <span class="type">Bool</span></span><br><span class="line"><span class="comment">-- 错误示范，类型不匹配</span></span><br><span class="line"><span class="comment">-- func3 = func2.func1</span></span><br><span class="line"><span class="comment">-- 正确示范</span></span><br><span class="line"><span class="title">func3</span> n = <span class="keyword">case</span> (func1 n) <span class="keyword">of</span></span><br><span class="line">    <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></span><br><span class="line">    <span class="type">Just</span> n' -&gt; func2 n'</span><br></pre></td></tr></table></figure>
<p>看上去不错，我们需要一种操作，能把任意两个可失败的函数连在一起，这样以后再碰到这种情况直接复用就行了。如果第一个函数类型是<code>a-&gt;Maybe b</code>，第二个函数类型是<code>b-&gt;Maybe c</code>，那么复合函数的类型应该是<code>a-&gt;Maybe c</code></p>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">composite</span> :: (b -&gt; <span class="type">Maybe</span> c) -&gt; (a -&gt; <span class="type">Maybe</span> b) -&gt; (a -&gt; <span class="type">Maybe</span> c)</span><br><span class="line"><span class="title">composite</span> f g = \x -&gt;</span><br><span class="line">    <span class="keyword">case</span> g x <span class="keyword">of</span></span><br><span class="line">        <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></span><br><span class="line">        <span class="type">Just</span> y  -&gt; f y</span><br><span class="line"></span><br><span class="line"><span class="title">func3'</span> = composite func2 func1</span><br></pre></td></tr></table></figure>
<p>看上去不错，不过有个小问题，执行的第一步<code>g x</code>并不需要<code>composite</code>函数来操心，完全可以由调用者算好了传进来，于是我们再简化下</p>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">composite</span> :: (b -&gt; <span class="type">Maybe</span> c) -&gt; (<span class="type">Maybe</span> b) -&gt; (<span class="type">Maybe</span> c)</span><br><span class="line"><span class="title">composite</span> f gx =</span><br><span class="line">    <span class="keyword">case</span> gx <span class="keyword">of</span></span><br><span class="line">        <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></span><br><span class="line">        <span class="type">Just</span> y  -&gt; f y</span><br><span class="line"></span><br><span class="line"><span class="title">func3''</span> x = composite func2 (func1 x)</span><br></pre></td></tr></table></figure>
<p>只要交换一下两个参数的顺序，我们就有了<code>Monad Maybe</code>的<code>&gt;&gt;=</code>函数。对于<code>Maybe</code>来说，它恰好有一个操作能满足Monad的定义，于是<code>Maybe</code>就是一个Monad。</p>
<h1 id="做得越多，写得越少"><a href="#做得越多，写得越少" class="headerlink" title="做得越多，写得越少"></a>做得越多，写得越少</h1><p><code>do</code>是Haskell中的一个关于<code>&gt;&gt;=</code>的语法糖，考虑有多个“可失败”函数需要调用的情况</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f1</span> x = <span class="type">Just</span> (x+<span class="number">1</span>)</span><br><span class="line"><span class="title">f2</span> x = <span class="type">Just</span> (x*<span class="number">2</span>)</span><br><span class="line"><span class="title">f3</span> x = <span class="type">Just</span> (x<span class="number">-3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 &gt;&gt;= 函数</span></span><br><span class="line"><span class="title">just16</span> = (<span class="type">Just</span> <span class="number">5</span>)</span><br><span class="line">         &gt;&gt;= (\x -&gt; f1 (x+<span class="number">1</span>))</span><br><span class="line">         &gt;&gt;= (\y -&gt; f2 (y+<span class="number">2</span>))</span><br><span class="line">         &gt;&gt;= (\z -&gt; f3 (z+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 do 语法</span></span><br><span class="line"><span class="title">just16'</span> = <span class="keyword">do</span></span><br><span class="line">    x &lt;- <span class="type">Just</span> <span class="number">5</span></span><br><span class="line">    y &lt;- f1 (x+<span class="number">1</span>)</span><br><span class="line">    z &lt;- f2 (y+<span class="number">2</span>)</span><br><span class="line">    f3 (z+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><code>do</code>会按照规则展开成<code>&gt;&gt;=</code>函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do x &lt;- expr</span><br><span class="line">   more_exprs</span><br><span class="line">会被展开成</span><br><span class="line">expr &gt;&gt;&#x3D; (\x -&gt; more_exprs)</span><br></pre></td></tr></table></figure>
<p>因此两者是等价的。但是<code>do</code>语法更加整齐易于阅读。</p>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul>
<li><a href="https://www.haskell.org/documentation/" target="_blank" rel="noopener">一大堆的资料</a></li>
<li><a href="http://learnyouahaskell.com/chapters" target="_blank" rel="noopener">Learn You a Haskell for Great Good!</a>: 是一本 Haskell 教程</li>
<li><a href="https://hoogle.haskell.org/" target="_blank" rel="noopener">Hoogle</a>：Haskell 函数查询工具</li>
<li><a href="https://www.google.com" target="_blank" rel="noopener">Google</a>：你永远的好伙伴 ;-)</li>
</ul>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/Programming/">Programming</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/编程/">编程</a>, <a href="/tags/教程/">教程</a>, <a href="/tags/Haskell/">Haskell</a>
  </div>

        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript>
  </div>
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:recursiveg.me">
  </form>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2020/04/winrar-best-practice/">WinRAR 恢复记录添加及使用教程</a>
      </li>
    
      <li>
        <a href="/2020/03/cmake-environment-script/">CMake 项目生成脚本</a>
      </li>
    
      <li>
        <a href="/2020/01/simple-kernel-dev-environment/">简易内核开发环境</a>
      </li>
    
      <li>
        <a href="/2019/12/build-amd-3960x-pc/">AMD Threadripper 3960X 装机</a>
      </li>
    
      <li>
        <a href="/2019/03/haskell-intro/">Haskell 简易指南</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/Life/">Life</a><small>2</small></li>
  
    <li><a href="/categories/Mathematics/">Mathematics</a><small>1</small></li>
  
    <li><a href="/categories/Programming/">Programming</a><small>26</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/ACM/" style="font-size: 10px;">ACM</a> <a href="/tags/AMD/" style="font-size: 10px;">AMD</a> <a href="/tags/Black-Technology/" style="font-size: 13.33px;">Black Technology</a> <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/CMake/" style="font-size: 10px;">CMake</a> <a href="/tags/Chrome/" style="font-size: 10px;">Chrome</a> <a href="/tags/Epoll/" style="font-size: 10px;">Epoll</a> <a href="/tags/GFW/" style="font-size: 10px;">GFW</a> <a href="/tags/GRE-Tunnel/" style="font-size: 10px;">GRE Tunnel</a> <a href="/tags/Haskell/" style="font-size: 10px;">Haskell</a> <a href="/tags/Hello-World/" style="font-size: 10px;">Hello World!</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/IPsec/" style="font-size: 10px;">IPsec</a> <a href="/tags/IPv6/" style="font-size: 10px;">IPv6</a> <a href="/tags/Java/" style="font-size: 11.67px;">Java</a> <a href="/tags/Kernel/" style="font-size: 10px;">Kernel</a> <a href="/tags/Linux/" style="font-size: 18.33px;">Linux</a> <a href="/tags/MinGW/" style="font-size: 10px;">MinGW</a> <a href="/tags/Minecraft/" style="font-size: 11.67px;">Minecraft</a> <a href="/tags/Networking/" style="font-size: 10px;">Networking</a> <a href="/tags/PTRACE/" style="font-size: 16.67px;">PTRACE</a> <a href="/tags/Pascal/" style="font-size: 10px;">Pascal</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/RSA/" style="font-size: 10px;">RSA</a> <a href="/tags/Site-Management/" style="font-size: 11.67px;">Site Management</a> <a href="/tags/Socket/" style="font-size: 10px;">Socket</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/WinRAR/" style="font-size: 10px;">WinRAR</a> <a href="/tags/Written-In-English/" style="font-size: 11.67px;">Written In English</a> <a href="/tags/iDevice/" style="font-size: 10px;">iDevice</a> <a href="/tags/%E4%B8%9C%E6%96%B9Project/" style="font-size: 10px;">东方Project</a> <a href="/tags/%E4%B9%B1%E7%A0%81/" style="font-size: 10px;">乱码</a> <a href="/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/" style="font-size: 10px;">交叉编译</a> <a href="/tags/%E5%8A%A0%E5%AF%86/" style="font-size: 10px;">加密</a> <a href="/tags/%E6%8A%80%E6%9C%AF%E5%AE%85/" style="font-size: 11.67px;">技术宅</a> <a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 20px;">教程</a> <a href="/tags/%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">编程</a> <a href="/tags/%E7%BD%91%E7%9B%98/" style="font-size: 13.33px;">网盘</a> <a href="/tags/%E8%84%9A%E6%9C%AC/" style="font-size: 10px;">脚本</a> <a href="/tags/%E8%A3%85%E6%9C%BA/" style="font-size: 10px;">装机</a>
  </div>
</div>


  <div class="widget blogroll">
  <h3 class="title">友情链接</h3>
  <ul class="entry">
  
    <li><a href="https://exz.me" target="_blank" rel="noopener" title="Epix Sphere">Epix Sphere</a></li>
  
    <li><a href="https://farseerfc.me" target="_blank" rel="noopener" title="FarseerFc">FarseerFc</a></li>
  
    <li><a href="https://im.librazy.org" target="_blank" rel="noopener" title="Librazy">Librazy</a></li>
  
  </ul>
</div>


  <div class="widget copyleft">
    <h3 class="title">原创声明 / Licensing</h3>
    <div class="entry">
        <center>
            <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">
                <img class="nofancybox nolightbox" alt="CC-BY-NC 4.0" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" />
            </a>
        </center>
        除非特别声明，本站文章均由RecursiveG原创，均采用<a rel="license noopener" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可。
        <p>
        Unless stated otherwise, RecursiveG is the author of all articles on this website. All articles are licensed under a <a rel="license noopener" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">Creative Commons Attribution-NonCommercial 4.0 International License</a>.
        <p>
        本站所有的代码，包括行内代码以及代码块中的代码，使用 CC 与 <a rel="license noopener" href="https://opensource.org/licenses/MIT" target="_blank">MIT</a> 双许可发布，你可任选其一使用。
        <p>
        All codes on this website, inline or in codeblocks, are dual-licensed under CC and <a rel="license noopener" href="https://opensource.org/licenses/MIT" target="_blank">MIT</a>. You can use whichever license that meets your needs.
        </p>
    </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2020 RecursiveG
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.aspnetcdn.com/ajax/jQuery/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
if((window.location.origin.indexOf("localhost")==-1)&&(window.location.origin.indexOf("127.0.0.1")==-1)){
  var disqus_shortname = 'developmentinprogress';
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  }());
}
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
