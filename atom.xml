<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RECURSIVE LAND</title>
  
  <subtitle>A Blog of Recursive G</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://recursiveg.me/"/>
  <updated>2019-03-21T20:26:08.597Z</updated>
  <id>http://recursiveg.me/</id>
  
  <author>
    <name>RecursiveG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Haskell 简易指南</title>
    <link href="http://recursiveg.me/2019/03/haskell-intro/"/>
    <id>http://recursiveg.me/2019/03/haskell-intro/</id>
    <published>2019-03-20T18:00:00.000Z</published>
    <updated>2019-03-21T20:26:08.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>用任何你喜欢的方法安装 <a href="https://www.haskell.org/" target="_blank" rel="noopener">Glasgow Haskell Compiler</a> (a.k.a. GHC)。Cabal 之类的<br>依赖管理系统就用不着了。 <del>因为我也不会用。</del> 保证能够执行<code>ghc</code>和<code>ghci</code>命令就行。</p><h1 id="GHCi基础"><a href="#GHCi基础" class="headerlink" title="GHCi基础"></a>GHCi基础</h1><p>首先，把以下文件保存成<code>helloworld.hs</code>。</p><figure class="highlight haskell"><figcaption><span>helloworld.hs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> = <span class="string">"hello, world"</span></span><br></pre></td></tr></table></figure><p>然后执行<code>ghci helloworld.hs</code>，然后在<code>&gt;</code>提示符后输入<code>foo</code>并回车</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GHCi, version 8.6.3: http://www.haskell.org/ghc/  :? for help</span><br><span class="line">[1 of 1] Compiling Main             ( helloworld.hs, interpreted )</span><br><span class="line">Ok, one module loaded.</span><br><span class="line">*Main&gt; foo</span><br><span class="line">&quot;hello, world&quot;</span><br><span class="line">*Main&gt;</span><br></pre></td></tr></table></figure><p>你可以使用<code>:r</code>来重新载入文件，也可以使用<code>:l &lt;文件名&gt;</code>来载入代码。</p><a id="more"></a><h1 id="基础表达式"><a href="#基础表达式" class="headerlink" title="基础表达式"></a>基础表达式</h1><p>你可以修改你的代码文件，并在GHCi中观察程序行为。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里是注释</span></span><br><span class="line"></span><br><span class="line"><span class="title">foo</span> = <span class="string">"hello, world"</span>  <span class="comment">-- 名称绑定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义一个函数，返回参数加一</span></span><br><span class="line"><span class="title">plus1</span> x=x+<span class="number">1</span></span><br><span class="line"><span class="comment">-- 函数调用的格式为 &lt;函数名&gt; &lt;参数1&gt; &lt;参数2&gt; ……</span></span><br><span class="line"><span class="comment">-- *Main&gt; plus1 41</span></span><br><span class="line"><span class="comment">-- 42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 递归调用，定义的顺序很重要，在前面的定义优先考虑</span></span><br><span class="line"><span class="title">fact</span> <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="title">fact</span> n = n * fact (n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列表 (a.k.a. 数组)</span></span><br><span class="line"><span class="title">list1</span> = [<span class="string">"I"</span>, <span class="string">"am"</span>, <span class="string">"a"</span>, <span class="string">"list"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 元组</span></span><br><span class="line"><span class="title">tuple1</span> = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="title">triple1</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 元组的模式匹配</span></span><br><span class="line"><span class="title">sumOfTuple</span> (x1, x2) = x1+x2</span><br><span class="line"><span class="comment">-- *Main&gt; sumOfTuple tuple1</span></span><br><span class="line"><span class="comment">-- 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列表与列表合并</span></span><br><span class="line"><span class="title">list2</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">list3</span> = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="title">list4</span> = list2 ++ list3</span><br><span class="line"><span class="comment">-- *Main&gt; list4</span></span><br><span class="line"><span class="comment">-- [1,2,3,4,5,6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串是字符组成的列表</span></span><br><span class="line"><span class="title">str1</span> = <span class="string">"foo"</span> ++ ['b','a','r']</span><br><span class="line"><span class="comment">-- *Main&gt; str1</span></span><br><span class="line"><span class="comment">-- "foobar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列表头部插入, 以下四种表达方式等价</span></span><br><span class="line"><span class="title">list5</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">list6</span> = <span class="number">1</span>:[<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">list7</span> = <span class="number">1</span>:<span class="number">2</span>:[<span class="number">3</span>]</span><br><span class="line"><span class="title">list8</span> = <span class="number">1</span>:<span class="number">2</span>:<span class="number">3</span>:[]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列表的模式匹配</span></span><br><span class="line"><span class="title">sumOfList</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">sumOfList</span> (headElement:remainingElements) = headElement + sumOfList remainingElements</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 强制前缀表达式</span></span><br><span class="line"><span class="title">three</span> = (+) <span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 强制中缀表达式，mod为取模函数</span></span><br><span class="line"><span class="title">four</span> = <span class="number">18</span> `mod` <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数部分求值 (Partial application)，以下两个函数等价</span></span><br><span class="line"><span class="comment">-- 单引号没有特殊意义，是合法函数名的一部分</span></span><br><span class="line"><span class="title">plus2</span>  x = (+) <span class="number">2</span> x</span><br><span class="line"><span class="title">plus2'</span>   = (+) <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- if 条件 (类似三目运算符)</span></span><br><span class="line"><span class="title">five</span> = <span class="keyword">if</span> <span class="type">False</span> <span class="keyword">then</span> <span class="number">4</span> <span class="keyword">else</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- let 名称绑定</span></span><br><span class="line"><span class="title">six</span>  = <span class="keyword">let</span> x = <span class="number">7</span> <span class="keyword">in</span> x<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Guard</span></span><br><span class="line"><span class="title">sign</span> x</span><br><span class="line">    | x &lt; <span class="number">0</span>     = <span class="number">-1</span></span><br><span class="line">    | x == <span class="number">0</span>    = <span class="number">0</span></span><br><span class="line">    | otherwise = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数复合</span></span><br><span class="line"><span class="title">plus4</span>  x = plus2 (plus2 x)</span><br><span class="line"><span class="title">plus4'</span> x = (plus2 . plus2) x</span><br><span class="line"><span class="title">plus4''</span>  = plus2 . plus2</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Lambda表达式 (a.k.a. 匿名函数)</span></span><br><span class="line"><span class="title">sum'</span>  = (\x y -&gt; x+y)</span><br><span class="line"><span class="title">plus5</span> = (\x   -&gt; sum' x <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>这里仅列出了极少数基本用法。更多关于语言本身的以及数据结构的特定语法规则请参考相关Haskell教程。</p><h1 id="类型标记"><a href="#类型标记" class="headerlink" title="类型标记"></a>类型标记</h1><p>Haskell 是一门具有类型推导的静态类型语言。每个表达式都有自己的类型，在 GHCi 的交互模式下，可以使用<code>:t &lt;表达式&gt;</code>来检查表达式的类型。类型注记通常写为<code>&lt;表达式&gt; :: &lt;类型&gt;</code>。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 布尔型</span></span><br><span class="line">*<span class="type">Main</span>&gt; :t <span class="type">True</span></span><br><span class="line"><span class="type">True</span>::<span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 元组</span></span><br><span class="line">*<span class="type">Main</span>&gt; :t (<span class="type">True</span>, <span class="type">False</span>)</span><br><span class="line">(<span class="type">True</span>, <span class="type">False</span>) :: (<span class="type">Bool</span>, <span class="type">Bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列表</span></span><br><span class="line">*<span class="type">Main</span>&gt; :t <span class="string">"123"</span></span><br><span class="line"><span class="string">"123"</span> :: [<span class="type">Char</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数</span></span><br><span class="line">*<span class="type">Main</span>&gt; :t (+)</span><br><span class="line">(+) :: <span class="type">Num</span> a =&gt; a -&gt; a -&gt; a</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 部分求值后，新的函数只需要一个参数</span></span><br><span class="line">*<span class="type">Main</span>&gt; :t (+) <span class="number">1</span></span><br><span class="line">(+) <span class="number">1</span> :: <span class="type">Num</span> a =&gt; a -&gt; a</span><br></pre></td></tr></table></figure><p>函数类型以 <code>(参数1的类型) -&gt; (参数2的类型) -&gt; ... -&gt; (返回值的类型)</code> 形式表达。不明显区分参数和返回值。<code>Num</code>是代表数字的类型类，可以近似理解成Java中的接口。<code>Num a =&gt;</code> 表示 “在后续的类型定义中，<code>a</code>可以被替换成任何满足<code>Num</code>的类型”。整数<code>Int</code>和浮点数<code>Float</code>都是<code>Num</code>类型类的成员，所以加法函数既可以将整数相加，也可以将浮点数相加。</p><p>类型箭头都是右结合，但是你可以手动添加括号来改变类型的意义</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 接受一个整型参数，返回一个新函数。这个新函数接受一个整型，返回一个整型</span></span><br><span class="line"><span class="title">product'</span> :: <span class="type">Int</span> -&gt; (<span class="type">Int</span> -&gt; <span class="type">Int</span>)</span><br><span class="line"><span class="title">product'</span> x y = x * y</span><br><span class="line"><span class="title">timesThree</span> = product' <span class="number">3</span></span><br><span class="line"><span class="title">nine</span> = timesThree <span class="number">3</span></span><br><span class="line"><span class="title">nine'</span> = (product' <span class="number">3</span>) <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 接受一个参数，该参数是“接受一个整型，返回一个整型”的函数，然后返回一个整型</span></span><br><span class="line"><span class="title">some_func</span> :: (<span class="type">Int</span> -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">some_func</span> f = f <span class="number">42</span></span><br><span class="line"><span class="comment">-- *Main&gt; some_func (* 2)</span></span><br><span class="line"><span class="comment">-- 84</span></span><br></pre></td></tr></table></figure><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>Haskell 中定义新类型的基本语法是<code>data &lt;新类型名&gt; [类型参数..] = &lt;构造函数1&gt; [成员类型...] | &lt;构造函数2&gt; [成员类型...] | ...</code>。类型名和构造函数都需要首字母大写。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">NameAndAge</span> = <span class="type">MakeNameAndAge</span> <span class="type">String</span> <span class="type">Int</span></span></span><br><span class="line"><span class="comment">-- *Main&gt; :t MakeNameAndAge</span></span><br><span class="line"><span class="comment">-- MakeNameAndAge :: String -&gt; Int -&gt; NameAndAge</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">IntOrBool</span> = <span class="type">MakeInt</span> <span class="type">Int</span> | <span class="type">MakeBool</span> <span class="type">Bool</span></span></span><br><span class="line"><span class="comment">-- *Main&gt; :t MakeInt</span></span><br><span class="line"><span class="comment">-- MakeInt :: Int -&gt; IntOrBool</span></span><br><span class="line"><span class="comment">-- *Main&gt; :t MakeBool</span></span><br><span class="line"><span class="comment">-- MakeBool :: Bool -&gt; IntOrBool</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Weekends</span> = <span class="type">Saturday</span> | <span class="type">Sunday</span></span></span><br><span class="line"><span class="comment">-- Saturday :: Weekends</span></span><br><span class="line"><span class="comment">-- Sunday :: Weekends</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">TupleOf</span> a = <span class="type">MakeTupleOf</span> a a</span></span><br><span class="line"><span class="comment">-- MakeTupleOf :: a -&gt; a -&gt; TupleOf a</span></span><br><span class="line"><span class="comment">-- MakeTupleOf False True :: TupleOf Bool</span></span><br><span class="line"><span class="comment">-- MakeTupleOf 1 2 :: Num a =&gt; TupleOf a</span></span><br><span class="line"><span class="comment">-- MakeTupleOf plus1 plus2 :: Num a =&gt; TupleOf (a -&gt; a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 你可以使用函数的模式匹配来提取数据结构中的成员</span></span><br><span class="line"><span class="title">printNameAndAge</span> :: <span class="type">NameAndAge</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">printNameAndAge</span> (<span class="type">MakeNameAndAge</span> name age) =</span><br><span class="line">    <span class="string">"I'm "</span> ++ name ++ <span class="string">" and I'm "</span> ++ (show age) ++ <span class="string">" years old."</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 你也可以使用模式匹配来判断是哪一个构造函数</span></span><br><span class="line"><span class="title">printIntOrBool</span> :: <span class="type">IntOrBool</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">printIntOrBool</span> (<span class="type">MakeInt</span> n) = <span class="string">"Wow, an integer: "</span> ++ (show n)</span><br><span class="line"><span class="title">printIntOrBool</span> (<span class="type">MakeBool</span> b) = <span class="string">"Wow, a boolean: "</span> ++ (show b)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 你甚至可以进行递归类型定义 。当然，你需要一个终止条件。</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">ListOf</span> a = <span class="type">EmptyList</span> | <span class="type">AppendList</span> (<span class="type">ListOf</span> <span class="title">a</span>) a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 相关操作也需要使用递归函数来完成</span></span><br><span class="line"><span class="title">contains</span> :: (<span class="type">Eq</span> a) =&gt; <span class="type">ListOf</span> a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">contains</span> <span class="type">EmptyList</span> _ = <span class="type">False</span></span><br><span class="line"><span class="title">contains</span> (<span class="type">AppendList</span> list x') x =</span><br><span class="line">    <span class="keyword">if</span> x == x' <span class="keyword">then</span> <span class="type">True</span> <span class="keyword">else</span> contains list x</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为 ListOf a 类型实现 Eq 类型类</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Eq</span> a =&gt; <span class="type">Eq</span> (<span class="type">ListOf</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    <span class="type">EmptyList</span> == <span class="type">EmptyList</span>                   = <span class="type">True</span></span><br><span class="line">    (<span class="type">AppendList</span> l1 a1) == (<span class="type">AppendList</span> l2 a2) = a1 == a2 &amp;&amp; l1 == l2</span><br><span class="line">    _ == _                                   = <span class="type">False</span></span><br></pre></td></tr></table></figure><p>注意：<code>a</code>是一个类型，<code>ListOf a</code>是一个类型，但是 <strong><em>ListOf 不是类型，ListOf 不是类型，ListOf 不是类型。</em></strong> 这个定义表示：<code>ListOf a</code>满足<code>Eq</code> 仅当 <code>a</code>满足<code>Eq</code>。要查看类型的相关信息，可以在 GHCi 中执行<code>:info</code>指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*Main&gt; :info Eq</span><br><span class="line">class Eq a where</span><br><span class="line">  (==) :: a -&gt; a -&gt; Bool</span><br><span class="line">  (/=) :: a -&gt; a -&gt; Bool</span><br><span class="line">  &#123;-# MINIMAL (==) | (/=) #-&#125;</span><br><span class="line">  -- Defined in ‘GHC.Classes’</span><br><span class="line">instance [safe] Eq a =&gt; Eq (ListOf a) -- Defined at [omitted]</span><br><span class="line">[... omitted ...]</span><br></pre></td></tr></table></figure><h1 id="也许是个单子"><a href="#也许是个单子" class="headerlink" title="也许是个单子"></a>也许是个单子</h1><p><code>Maybe a</code>类似Java中的<code>Optional&lt;T&gt;</code>，常用于表示“会失败”的函数。</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Maybe</span> a = <span class="type">Nothing</span> | <span class="type">Just</span> a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一些函数</span></span><br><span class="line"><span class="title">func1</span> :: <span class="type">Float</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">func2</span> :: <span class="type">Int</span> -&gt; <span class="type">Maybe</span> <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p><code>Monad</code>是个类型类</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; :info <span class="type">Monad</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad</span> (<span class="title">m</span> :: * -&gt; *) <span class="keyword">where</span></span></span><br><span class="line">  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line">  (&gt;&gt;) :: m a -&gt; m b -&gt; m b</span><br><span class="line">  return :: a -&gt; m a</span><br><span class="line">  fail :: <span class="type">String</span> -&gt; m a</span><br></pre></td></tr></table></figure><p>简化一下</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line">  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line">  return :: a -&gt; m a</span><br></pre></td></tr></table></figure><p>当我们说<code>Maybe</code>是一个<code>Monad</code>的时候，一方面指 Maybe 属于 Monad 这个类型类<code>instance Monad Maybe where ...</code>。另一方面指<code>Maybe(数据结构)</code>，<code>(&gt;&gt;=)::Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b (函数)</code>，<code>return::a -&gt; Maybe a (函数)</code>这三者构成了一个满足某些条件的数学结构，这些条件被称为<a href="https://wiki.haskell.org/Monad_laws" target="_blank" rel="noopener">Monad Laws</a>。事实上，Haskell编译器不会检查 Monad Laws 是否满足，你可以胡乱写一些数据结构和函数，然后将其塞入 Monad 这个类型类中。换句话说，Haskell中的Monad就是一个接口，任何实现接口的数据类型都可以称其为Monad。</p><p>回到<code>Maybe</code>上，现在你想把这两个会失败的函数连接在一起</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">func3</span> :: <span class="type">Float</span> -&gt; <span class="type">Maybe</span> <span class="type">Bool</span></span><br><span class="line"><span class="comment">-- 错误示范，类型不匹配</span></span><br><span class="line"><span class="comment">-- func3 = func2.func1</span></span><br><span class="line"><span class="comment">-- 正确示范</span></span><br><span class="line"><span class="title">func3</span> n = <span class="keyword">case</span> (func1 n) <span class="keyword">of</span></span><br><span class="line">    <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></span><br><span class="line">    <span class="type">Just</span> n' -&gt; func2 n'</span><br></pre></td></tr></table></figure><p>看上去不错，我们需要一种操作，能把任意两个可失败的函数连在一起，这样以后再碰到这种情况直接复用就行了。如果第一个函数类型是<code>a-&gt;Maybe b</code>，第二个函数类型是<code>b-&gt;Maybe c</code>，那么复合函数的类型应该是<code>a-&gt;Maybe c</code></p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">composite</span> :: (b -&gt; <span class="type">Maybe</span> c) -&gt; (a -&gt; <span class="type">Maybe</span> b) -&gt; (a -&gt; <span class="type">Maybe</span> c)</span><br><span class="line"><span class="title">composite</span> f g = \x -&gt;</span><br><span class="line">    <span class="keyword">case</span> g x <span class="keyword">of</span></span><br><span class="line">        <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></span><br><span class="line">        <span class="type">Just</span> y  -&gt; f y</span><br><span class="line"></span><br><span class="line"><span class="title">func3'</span> = composite func2 func1</span><br></pre></td></tr></table></figure><p>看上去不错，不过有个小问题，执行的第一步<code>g x</code>并不需要<code>composite</code>函数来操心，完全可以由调用者算好了传进来，于是我们再简化下</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">composite</span> :: (b -&gt; <span class="type">Maybe</span> c) -&gt; (<span class="type">Maybe</span> b) -&gt; (<span class="type">Maybe</span> c)</span><br><span class="line"><span class="title">composite</span> f gx =</span><br><span class="line">    <span class="keyword">case</span> gx <span class="keyword">of</span></span><br><span class="line">        <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></span><br><span class="line">        <span class="type">Just</span> y  -&gt; f y</span><br><span class="line"></span><br><span class="line"><span class="title">func3''</span> x = composite func2 (func1 x)</span><br></pre></td></tr></table></figure><p>只要交换一下两个参数的顺序，我们就有了<code>Monad Maybe</code>的<code>&gt;&gt;=</code>函数。对于<code>Maybe</code>来说，它恰好有一个操作能满足Monad的定义，于是<code>Maybe</code>就是一个Monad。</p><h1 id="做得越多，写得越少"><a href="#做得越多，写得越少" class="headerlink" title="做得越多，写得越少"></a>做得越多，写得越少</h1><p><code>do</code>是Haskell中的一个关于<code>&gt;&gt;=</code>的语法糖，考虑有多个“可失败”函数需要调用的情况</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f1</span> x = <span class="type">Just</span> (x+<span class="number">1</span>)</span><br><span class="line"><span class="title">f2</span> x = <span class="type">Just</span> (x*<span class="number">2</span>)</span><br><span class="line"><span class="title">f3</span> x = <span class="type">Just</span> (x<span class="number">-3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 &gt;&gt;= 函数</span></span><br><span class="line"><span class="title">just16</span> = (<span class="type">Just</span> <span class="number">5</span>)</span><br><span class="line">         &gt;&gt;= (\x -&gt; f1 (x+<span class="number">1</span>))</span><br><span class="line">         &gt;&gt;= (\y -&gt; f2 (y+<span class="number">2</span>))</span><br><span class="line">         &gt;&gt;= (\z -&gt; f3 (z+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 do 语法</span></span><br><span class="line"><span class="title">just16'</span> = <span class="keyword">do</span></span><br><span class="line">    x &lt;- <span class="type">Just</span> <span class="number">5</span></span><br><span class="line">    y &lt;- f1 (x+<span class="number">1</span>)</span><br><span class="line">    z &lt;- f2 (y+<span class="number">2</span>)</span><br><span class="line">    f3 (z+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><code>do</code>会按照规则展开成<code>&gt;&gt;=</code>函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do x &lt;- expr</span><br><span class="line">   more_exprs</span><br><span class="line">会被展开成</span><br><span class="line">expr &gt;&gt;= (\x -&gt; more_exprs)</span><br></pre></td></tr></table></figure><p>因此两者是等价的。但是<code>do</code>语法更加整齐易于阅读。</p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul><li><a href="https://www.haskell.org/documentation/" target="_blank" rel="noopener">一大堆的资料</a></li><li><a href="http://learnyouahaskell.com/chapters" target="_blank" rel="noopener">Learn You a Haskell for Great Good!</a>: 是一本 Haskell 教程</li><li><a href="https://hoogle.haskell.org/" target="_blank" rel="noopener">Hoogle</a>：Haskell 函数查询工具</li><li><a href="https://www.google.com" target="_blank" rel="noopener">Google</a>：你永远的好伙伴 ;-)</li></ul>]]></content>
    
    <summary type="html">
    
      Haskell 简易指南
    
    </summary>
    
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="编程" scheme="http://recursiveg.me/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="教程" scheme="http://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Haskell" scheme="http://recursiveg.me/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>编写一个简易的Chrome扩展</title>
    <link href="http://recursiveg.me/2017/05/simple-chrome-extension/"/>
    <id>http://recursiveg.me/2017/05/simple-chrome-extension/</id>
    <published>2017-05-12T09:30:00.000Z</published>
    <updated>2017-08-25T04:27:51.435Z</updated>
    
    <content type="html"><![CDATA[<p>时隔半年的毫无诚心的流水帐作品。<br>假设读者有基础的Javascript能力。</p><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>常去的某资源站的某资源发布者喜欢把重要的内容加上花里胡哨的特殊效果并藏在页面的角落里。<br>虽说要尊重资源的发布者，不过这种给人添堵的行为实在令我感到不爽，于是研究了一下Chrome的扩展程序（Extension）。</p><h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><p>要干的事情有两件：</p><ol><li>将内容移到页面的显著位置</li><li><del>去掉辣眼睛的特殊效果</del> 好吧，其实这条并不重要，毕竟内容已经被移到显著位置了</li></ol><p>很自然的，直接用Javascript操纵DOM树即可实现希望的效果。<br>那么要怎么自动载入脚本呢？</p><a id="more"></a><h1 id="编写扩展"><a href="#编写扩展" class="headerlink" title="编写扩展"></a>编写扩展</h1><p>感谢Chrome提供了强大的扩展系统。自动载入脚本这种功能自然是小菜一碟啦。<br>首先编写一个脚本<code>content_script.js</code>操纵页面元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (page_require_modification()) &#123;</span><br><span class="line">    <span class="keyword">var</span> content = <span class="built_in">document</span>.getElementById(<span class="string">"hidden-div"</span>).innerHTML;</span><br><span class="line">    <span class="keyword">var</span> clean_content = <span class="built_in">document</span>.createElement(<span class="string">"p"</span>);</span><br><span class="line">    clean_content.append(<span class="built_in">document</span>.createTextNode(content));</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"main-div"</span>).append(clean_content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有魔法，想干啥就写啥，就像是HTML本身引用了一个JS文件一样。也不需要考虑<code>document.ready</code>的问题，因为Chrome默认会在文档加载完成后再加载自定义的JS。</p><p>接着需要一个<code>manifest.json</code>文件，这样Chrome才能将其作为一个Extension加载。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"manifest_version"</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"在这里填上扩展的名称"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"这里填一些描述"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">"content_scripts"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="attr">"matches"</span>: [<span class="string">"https://www.google.com/*"</span>],</span><br><span class="line">          <span class="attr">"js"</span>: [<span class="string">"content_script.js"</span>]</span><br><span class="line">      &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>你觉得我会把实际的URL写出来嘛？肯定不会啦！</del><br>Chrome把这种注入到页面中的脚本称做<code>content_scripts</code>。当页面的URL符合<code>matches</code>中的pattern时，就自动加载<code>js</code>中指定的脚本。当然，脚本的文件名可以自由决定，只要前后一致即可。</p><p>最后一步，将<code>manifest.json</code>和<code>content_script.js</code>放入同一个文件夹。然后在<code>chrome://extensions</code>选择<code>加载已解压的扩展程序</code>即可加载扩展啦。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>manifest.json</code>文件指示了一个Chrome扩展</li><li>Chrome扩展能将自定义脚本注入到符合指定URL的页面中</li><li>这种单纯的脚本注入任务可能Greasemonkey更适合一些，不过这次就先研究Chrome扩展啦~ 有机会再研究油猴脚本。</li><li>Chrome扩展可以和浏览器本身做到更紧密的结合，比如提供菜单项或者是GUI之类的，不过这篇文章完全没有涉及。</li><li><a href="https://developer.chrome.com/extensions" target="_blank" rel="noopener">Google的官方扩展指南</a>永远是你的好伙伴</li></ul>]]></content>
    
    <summary type="html">
    
      编写一个简易的Chrome扩展以修改页面内容
    
    </summary>
    
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="编程" scheme="http://recursiveg.me/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="技术宅" scheme="http://recursiveg.me/tags/%E6%8A%80%E6%9C%AF%E5%AE%85/"/>
    
      <category term="教程" scheme="http://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Chrome" scheme="http://recursiveg.me/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>借助IPsec和strongSwan建立隧道并分配IPv6地址</title>
    <link href="http://recursiveg.me/2016/12/assign-ipv6-through-ipsec-and-strongswan/"/>
    <id>http://recursiveg.me/2016/12/assign-ipv6-through-ipsec-and-strongswan/</id>
    <published>2016-12-24T07:54:08.000Z</published>
    <updated>2017-08-13T04:55:25.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>在一年前，我写过一篇<a href="/2015/09/get-ipv6-via-gre-tunnel/">文章</a>，介绍利用GRE隧道将一台服务器的IPv6地址“分配”给另一台电脑，令其能访问IPv6网络的方法。<br>不过那种方法存在一些问题：</p><ul><li>不能通过NAT</li><li>数据不加密</li><li>需要在服务器手动更新IP</li></ul><p>于是热爱折腾<del>作死</del>的我研究了一下使用IPsec配合IKEv2对流量进行加密的方法。</p><p>服务器与本地均为ArchLinux（Arch大法好），strongSwan软件包可从AUR安装。<br>服务器需要至少有一个公网IPv4和一段Routed IPv6 Subnet。</p><a id="more"></a><h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><p>我们一共需要三对“密钥-证书”对：</p><ul><li>CA密钥和证书：用于签署其它的证书，同时CA证书需要分发到所有机器上。</li><li>服务器密钥和证书</li><li>客户端密钥和证书</li></ul><p>我使用了ECC证书，因为其具有更短的长度。如果老版本不支持ECC的，也可以使用RSA证书。<br>先生成三把私钥：</p><pre><code>certtool --generate-privkey --ecc --outfile ca.keycerttool --generate-privkey --ecc --outfile server.keycerttool --generate-privkey --ecc --outfile client.key</code></pre><p>然后自签名CA证书，<code>Common Name</code>可以随意填，但是和之后的配置一定要统一：</p><pre><code>certtool --generate-self-signed --load-privkey ca.key --outfile ca.crt</code></pre><p>接着再用CA证书签名其它两把密钥，<code>Common Name</code>同样可以随意填，但是不要一样：</p><pre><code>certtool --generate-certificate --load-ca-privkey ca.key --load-ca-certificate ca.crt --load-privkey server.key --outfile server.crtcerttool --generate-certificate --load-ca-privkey ca.key --load-ca-certificate ca.crt --load-privkey client.key --outfile client.crt</code></pre><p>这样就一共产生了六个文件，保存备用。</p><h2 id="服务端设置"><a href="#服务端设置" class="headerlink" title="服务端设置"></a>服务端设置</h2><p>首先需要把密钥文件放到对应的位置：</p><ul><li><code>ca.crt</code>放入<code>/etc/ipsec.d/cacerts/</code></li><li><code>server.key</code>放入<code>/etc/ipsec.d/private/</code></li><li><code>server.crt</code>放入<code>/etc/ipsec.d/certs/</code></li></ul><p>然后编辑<code>/etc/ipsec.secrets</code>文件，注意空格</p><pre><code>&quot;CN=IPsec server&quot; : ECDSA &quot;server.key&quot;</code></pre><p>前面<code>CN=...</code>那一串是证书的Subject，CN即Common Name，可以通过<code>certtool -i &lt; server.crt</code>查看。</p><p>最后编辑<code>/etc/ipsec.conf</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">config setup</span><br><span class="line">    charondebug=&quot;cfg 2, dmn 2, ike 2, net 2&quot;</span><br><span class="line"></span><br><span class="line">conn serverconn #此处是链接名称，可以自由填写</span><br><span class="line">    left=%any</span><br><span class="line">    leftcert=server.crt</span><br><span class="line">    leftid=&quot;&#123;这边填入server.crt的Subject&#125;&quot;</span><br><span class="line">    leftca=&quot;&#123;这边填入ca.crt的Subject&#125;&quot;</span><br><span class="line">    leftsubnet=::/0     #表示整个IPv6网络都在这端</span><br><span class="line"></span><br><span class="line">    right=%any</span><br><span class="line">    rightca=&quot;&#123;这边填入ca.crt的Subject&#125;&quot;</span><br><span class="line">    rightsourceip=2001:abc:def:123:456::/80 #客户端IP所在的/80段</span><br><span class="line"></span><br><span class="line">    auto=add</span><br><span class="line">    keyexchange=ikev2</span><br><span class="line">    ike=aes256gcm128-sha2_512-modp4096! #选择你喜欢的加密方法</span><br></pre></td></tr></table></figure><p>然后打开IPv6 Forwarding并启动服务</p><pre><code>sudo sysctl net.ipv6.conf.all.forwarding=1sudo systemctl start strongswan</code></pre><h2 id="客户端设置"><a href="#客户端设置" class="headerlink" title="客户端设置"></a>客户端设置</h2><p>步骤基本相同。</p><ul><li><code>ca.crt</code>放入<code>/etc/ipsec.d/cacerts/</code></li><li><code>client.key</code>放入<code>/etc/ipsec.d/private/</code></li><li><code>client.crt</code>放入<code>/etc/ipsec.d/certs/</code></li><li>编辑<code>ipsec.secrets</code>为<code>&quot;CN=...&quot; : ECDSA &quot;client.key&quot;</code></li></ul><p>编辑<code>/etc/ipsec.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">config setup</span><br><span class="line">    charondebug=&quot;cfg 2, dmn 2, ike 2, net 2&quot;</span><br><span class="line"></span><br><span class="line">conn clientconn #此处是链接名称，可以自由填写</span><br><span class="line">    left=%any</span><br><span class="line">    leftcert=client.crt</span><br><span class="line">    leftsourceip=%config6 #从服务器获取一个IPv6地址</span><br><span class="line"></span><br><span class="line">    right=&#123;这里填上你服务器的IPv4地址&#125;</span><br><span class="line">    rightid=&quot;&#123;这边填入server.crt的Subject&#125;&quot;</span><br><span class="line">    rightsubnet=::/0 #表示整个IPv6网络都在另一端</span><br><span class="line"></span><br><span class="line">    auto=start        #自动连接</span><br><span class="line">    dpdaction=restart #自动重连</span><br><span class="line">    keyexchange=ikev2</span><br><span class="line">    ike=aes256gcm128-sha2_512-modp4096!</span><br></pre></td></tr></table></figure><p>然后执行<code>sudo ipsec start --nofork</code>，如果出现<code>keeping connection path</code>字样应该就连接成功了。网卡上会出现一个新的IPv6地址，然后就可以直接访问IPv6网络了。</p><p>如果连接不成功或者是无法访问网络，可以考虑检查一下防火墙是不是把数据包drop了。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://wiki.strongswan.org/projects/strongswan/wiki" target="_blank" rel="noopener">strongSwan Wiki</a> strongSwan的官方文档库，同时提供了很多IPsec的资料</li><li><a href="https://www.gnutls.org/manual/html_node/certtool-Invocation.html" target="_blank" rel="noopener">certtool使用手册</a></li></ul>]]></content>
    
    <summary type="html">
    
      Setup an IPv6 tunnel through IPsec &amp; strongSwan
    
    </summary>
    
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="教程" scheme="http://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="IPsec" scheme="http://recursiveg.me/tags/IPsec/"/>
    
      <category term="Networking" scheme="http://recursiveg.me/tags/Networking/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境TCP Socket与Epoll使用备忘</title>
    <link href="http://recursiveg.me/2015/12/linux-socket-epoll-demo/"/>
    <id>http://recursiveg.me/2015/12/linux-socket-epoll-demo/</id>
    <published>2015-12-25T11:15:13.000Z</published>
    <updated>2017-08-13T04:55:25.222Z</updated>
    
    <content type="html"><![CDATA[<p>流水帐式地记录了 Linux 下 TCP Socket 通信的方法和基本的 Epoll 使用方法。<br>没有错误处理。</p><h2 id="地址解析"><a href="#地址解析" class="headerlink" title="地址解析"></a>地址解析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">listen_addr</span>;</span> <span class="comment">//存放解析结果。参见`man getaddrinfo`</span></span><br><span class="line">getaddrinfo(<span class="string">"0.0.0.0"</span>, <span class="string">"55553"</span>, <span class="literal">NULL</span>, &amp;listen_addr); <span class="comment">// getaddrinfo([主机名],[端口],[hint],[结果])。成功返回 `0`</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">freeaddrinfo(listen_addr); <span class="comment">//释放资源，返回void</span></span><br></pre></td></tr></table></figure><h2 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h2><p>这种方式只能同时处理一个连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// int socket(int domain, int type, int protocol); 参见`man 3 socket` 创建文件描述符， 出错返回-1</span></span><br><span class="line">bind(fd, listen_addr-&gt;ai_addr, listen_addr-&gt;ai_addrlen);</span><br><span class="line">    <span class="comment">// int bind(int socket, const struct sockaddr *address,socklen_t address_len);</span></span><br><span class="line">    <span class="comment">// 绑定地址，出错返回-1，参见`man 3 bind`</span></span><br><span class="line">listen(fd, SOMAXCONN);</span><br><span class="line">    <span class="comment">// int listen(int fd, int backlog(最大队列长度))</span></span><br><span class="line">    <span class="comment">// 开始监听，出错返回-1</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> new_fd = accept(fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// accept([fd], [监听地址], [监听地址结构体长度]) 第2，3个参数同bind()</span></span><br><span class="line">        <span class="comment">// 接受连接请求，若无请求则阻塞(也有可能是EAGAIN,取决于你需要什么)</span></span><br><span class="line">        <span class="comment">// 返回用于和对端通信的新的文件描述符,出错返回-1</span></span><br><span class="line">    <span class="comment">// ... handle(new_fd);</span></span><br><span class="line">    close(new_fd); <span class="comment">// 关闭文件描述符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">server_addr</span>;</span></span><br><span class="line">getaddrinfo(<span class="string">"127.0.0.1"</span>, <span class="string">"55553"</span>, <span class="literal">NULL</span>, &amp;server_addr);</span><br><span class="line"><span class="keyword">int</span> server_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">connect(server_socket, server_addr-&gt;ai_addr, server_addr-&gt;ai_addrlen)</span><br><span class="line">    <span class="comment">// 基本同bind() 参见 man 3 connect</span></span><br><span class="line">    <span class="comment">// 成功后可用server_socket与服务器通信</span></span><br><span class="line"><span class="comment">// ... send(...)</span></span><br><span class="line"><span class="comment">// ... recv(...)</span></span><br><span class="line">close(server_socket);</span><br><span class="line">freeaddrinfo(server_addr);</span><br></pre></td></tr></table></figure><h2 id="传送数据"><a href="#传送数据" class="headerlink" title="传送数据"></a>传送数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *payload = <span class="string">"hello"</span></span><br><span class="line">send(new_fd, payload, <span class="built_in">strlen</span>(payload), <span class="number">0</span>); <span class="comment">// send([fd], [buffer], [需发送消息长度], [flag]) 返回实际发送的消息长度</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">255</span>];</span><br><span class="line">recv(new_fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>); <span class="comment">// send([fd], [buffer], [最大接收消息长度], [flag]) 返回实际接收的消息长度。阻塞模式下，若无消息则阻塞</span></span><br></pre></td></tr></table></figure><h2 id="多进程请求处理"><a href="#多进程请求处理" class="headerlink" title="多进程请求处理"></a>多进程请求处理</h2><p>对于每一个请求fork()一个新的进程进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> new_fd = accept(fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123; <span class="comment">// fork()返回0说明是子进程</span></span><br><span class="line">        <span class="comment">// ... handle(new_fd);</span></span><br><span class="line">        close(new_fd);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> epollfd = epoll_create(<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">// 创建epoll文件描述符，出错返回-1</span></span><br><span class="line">    <span class="comment">// int epoll_create(int size) 从Linux2.6.8开始，size值被忽略，不过为保持兼容需要设定为一个正整数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span> <span class="comment">// 记录套接字相关信息</span></span><br><span class="line">ev.events = EPOLLIN; <span class="comment">// 监视有数据可读事件</span></span><br><span class="line">ev.data.fd = fd; <span class="comment">// 文件描述符数据，其实这里可以放任何数据。</span></span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;ev);</span><br><span class="line">    <span class="comment">// int epoll_ctl([Epoll FD], [Operation], [fd], [epoll_event]);</span></span><br><span class="line">    <span class="comment">// 加入监听列表，当fd上有对应事件产生时，epoll_wait会将epoll_event填充到events_in数组里</span></span><br><span class="line">    <span class="comment">// 出错返回-1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events_in</span>[16];</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> event_count = epoll_wait(epollfd, events_in, <span class="number">16</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 等待事件，epoll_wait会将事件填充至events_in内</span></span><br><span class="line">        <span class="comment">// int epoll_wait([epoll fd], struct epoll_event *events, [最大事件数量], int timeout);</span></span><br><span class="line">        <span class="comment">// 返回 获得的事件数量，若超时且没有任何事件返回0，出错返回-1。timeout设置为-1表示无限等待。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;event_count; i++) &#123; <span class="comment">// 遍历所有事件</span></span><br><span class="line">        <span class="keyword">if</span> (events_in[i].data.fd == fd) &#123; <span class="comment">// 新连接请求</span></span><br><span class="line">            <span class="keyword">int</span> new_fd = accept(fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            ev.events = EPOLLIN; <span class="comment">// 参见man 7 epoll 如果要使用Edge Trigger还需将new_fd设为非阻塞</span></span><br><span class="line">            ev.data.fd = new_fd;</span><br><span class="line">            epoll_ctl(epollfd, EPOLL_CTL_ADD, new_fd, &amp;ev); <span class="comment">// 将新连接加入监视列表</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> new_fd = events_in[i].data.fd;</span><br><span class="line">            <span class="comment">// ... handle(new_fd);</span></span><br><span class="line">            epoll_ctl(epollfd, EPOLL_CTL_DEL, new_fd, <span class="literal">NULL</span>); <span class="comment">// 不再监听fd，最后一个参数被忽略</span></span><br><span class="line">            close(new_fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><ul><li><a href="http://www.linux-mag.com/id/308/" target="_blank" rel="noopener">Blocking 与 Non-Blocking I/O</a></li><li><a href="http://www.ccvita.com/515.html" target="_blank" rel="noopener">Epoll 的 Edge-Trigger 与 Level-Trigger</a></li></ul>]]></content>
    
    <summary type="html">
    
      流水帐式地记录了 Linux 下 TCP Socket 通信的方法和基本的 Epoll 使用方法。
    
    </summary>
    
    
      <category term="Programming" scheme="http://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Linux" scheme="http://recursiveg.me/tags/Linux/"/>
    
      <category term="教程" scheme="http://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Epoll" scheme="http://recursiveg.me/tags/Epoll/"/>
    
      <category term="Socket" scheme="http://recursiveg.me/tags/Socket/"/>
    
      <category term="TCP" scheme="http://recursiveg.me/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Linux下建立GRE隧道并获取IPv6地址</title>
    <link href="http://recursiveg.me/2015/09/get-ipv6-via-gre-tunnel/"/>
    <id>http://recursiveg.me/2015/09/get-ipv6-via-gre-tunnel/</id>
    <published>2015-09-19T06:35:10.000Z</published>
    <updated>2017-08-13T04:55:25.222Z</updated>
    
    <content type="html"><![CDATA[<p>虽然HE有提供免费的Tunnelbroker，不过那速度实在不怎么样。于是考虑在有IPv6地址托管主机上建立一个GRE Tunnel。<br>GRE Tunnel需要有内核模块<code>ip_gre</code>支持。远程主机有一段/64的IPv6，我将其中的一段/80分配给自己的机器。<br>使用iproute2工具。当然，你自己的机器需要有一个公网IPv4地址。</p><ol><li>服务器的公网IPv4是<code>$server_ipv4</code></li><li>自己电脑（或者路由器）的公网IPv4是<code>$client_ipv4</code>。</li><li>服务器的IPv6段是<code>a:b:c:d::/64</code></li><li>要分配下去的IPv6段是<code>a:b:c:d:e::/80</code></li></ol><h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><p>脚本如下，需要root，建议用<code>sudo -i</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip tunnel add gre-tunnel mode gre remote <span class="variable">$client_ipv4</span> ttl 64</span><br><span class="line">ip link <span class="built_in">set</span> gre-tunnel up</span><br><span class="line">ip addr add a:b:c:d:e::1/80 dev gre-tunnel</span><br></pre></td></tr></table></figure><ul><li>第一行建立隧道，<code>gre-tunnel</code>是隧道名称，可以按自己喜欢的来，记得其他的也要一起改</li><li>第二行激活隧道</li><li>第三行分配IP地址</li></ul><a id="more"></a><h2 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h2><p>脚本如下，和服务端配置几乎一样，同样需要root：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip tunnel add gre-tunnel mode gre remote <span class="variable">$server_ipv4</span> ttl 64</span><br><span class="line">ip link <span class="built_in">set</span> gre-tunnel up</span><br><span class="line">ip addr add a:b:c:d:e::2/80 dev gre-tunnel</span><br><span class="line">ip -6 route add default dev gre-tunnel</span><br></pre></td></tr></table></figure><ul><li>第一行建立隧道，隧道名称不必和服务器的一样</li><li>第二行激活隧道</li><li>第三行分配IP地址，注意不要和服务器的冲突，这个IP也是将要暴露在网络上的IP</li><li>第四行设定路由，让IPv6流量都走隧道</li></ul><h2 id="访问网络"><a href="#访问网络" class="headerlink" title="访问网络"></a>访问网络</h2><p>现在，两台机器应该可以互ping了。有的比较奇葩的情况可能需要手动<code>ip link set gre0 up</code>一下，gre0似乎是内核模块自动加入的玩意儿，具体怎么回事我也不清楚–_–|<br>但是现在还不能访问外网，还需要在服务器执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv6.conf.all.forwarding=1</span><br><span class="line">sysctl net.ipv6.conf.all.proxy_ndp=1</span><br><span class="line">ip -6 neigh add proxy a:b:c:d:e::2 dev eth0</span><br></pre></td></tr></table></figure><p>第一行开启forward<br>二三行和IPv6的NDP(邻居发现)有关，又是个没搞明白的东西真是残念……<br>eth0是服务器实际连接网络的接口。</p><h2 id="删除-amp-修改"><a href="#删除-amp-修改" class="headerlink" title="删除 &amp; 修改"></a>删除 &amp; 修改</h2><p>要删除Tunnel，在两端均执行:</p><pre><code>ip link set gre-tunnel downip tunnel del gre-tunnel</code></pre><p>如果客户端IP变化:</p><pre><code>ip tunnel change gre-tunnel remote $new_client_ipv4</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>虽然叫做“隧道”，但是内容依然是<em>明文</em>，对保密要求高的同学们要注意了。<br>另外直接用命令建立的隧道在重启后会没有，所以可以考虑用networkd之类的东西来管理。<br>Linux在访问有IPv6地址的域名时会优先使用IPv6，所以要当心服务器流量爆炸。当然配置成IPv4优先也是可以的。<br>如果你的本地IPv4经常变动的话，你可能需要些脚本之类的东西自动更新服务器的Remote IP。<br>对于每一个新的IP(新的设备)，都需要在服务端执行<code>ip -6 neigh add</code>，有知道怎么解决这个问题的请务必留言…</p>]]></content>
    
    <summary type="html">
    
      如何在Linux服务器上建立隧道并获得IPv6地址
    
    </summary>
    
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="Linux" scheme="http://recursiveg.me/tags/Linux/"/>
    
      <category term="GRE Tunnel" scheme="http://recursiveg.me/tags/GRE-Tunnel/"/>
    
      <category term="IPv6" scheme="http://recursiveg.me/tags/IPv6/"/>
    
  </entry>
  
  <entry>
    <title>IDEA下建立Forge开发环境的正确姿势</title>
    <link href="http://recursiveg.me/2014/12/setup-forge-workspace-with-idea/"/>
    <id>http://recursiveg.me/2014/12/setup-forge-workspace-with-idea/</id>
    <published>2014-12-11T06:17:48.000Z</published>
    <updated>2019-10-18T05:47:18.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>见过不少教程都是基于Eclipse的，而基于IDEA的文章少得可怜，遂决定写此文。<br>本文通篇基于Linux/IntellijIDEA进行讲解，Windows/MAC/Eclipse用户请自行依葫芦画瓢。</p><h1 id="设置Forge工作区"><a href="#设置Forge工作区" class="headerlink" title="设置Forge工作区"></a>设置Forge工作区</h1><p>当然，你得首先去<a href="http://files.minecraftforge.net/" target="_blank" rel="noopener">MinecraftForge</a>下载一份源代码。我这里用的是最新的<code>forge-1.7.10-10.13.2.1258-src.zip</code><br>接着，找个地方建立一个文件夹，这将是你的工程目录，我的叫做<code>Forge1.7.10-1258</code>。然后再在里面建立一个目录，比方说就叫<code>forge-1.7.10-10.13.2.1258-src</code>，把你的Forge源码解压进去。<br>现在，你的文件夹层次应该看起来是这样的：</p><pre><code>Forge1.7.10-1258└── forge-1.7.10-10.13.2.1258-src     ├── build.gradle     ├── CREDITS-fml.txt     ├── eclipse     ├── forge-1.7.10-10.13.2.1258-changelog.txt     ├── gradle     ├── gradlew     ├── gradlew.bat     ├── LICENSE-fml.txt     ├── MinecraftForge-Credits.txt     ├── MinecraftForge-License.txt     ├── README.txt     └── src</code></pre><p>你可以先按自己喜好改动一下<code>build.gradle</code>。比如，我喜欢手动指定一下mappings的版本：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">minecraft &#123;</span><br><span class="line">    version = <span class="string">"1.7.10-10.13.2.1258"</span></span><br><span class="line">    runDir = <span class="string">"eclipse"</span></span><br><span class="line">    mappings = <span class="string">"stable_12"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，cd到forge-1.7.10-10.13.2.1258-src目录下，执行如下两条命令：</p><pre><code>gradle -i setupDecompWorkspacegradle -i ideaModule</code></pre><p>然后请耐心等待指令完成，可以去喝杯牛奶睡个觉什么的。</p><a id="more"></a><h1 id="导入到IDEA"><a href="#导入到IDEA" class="headerlink" title="导入到IDEA"></a>导入到IDEA</h1><p>等以上操作完成后，就可以打开IDEA，选“Create New Project”，注意要建立一个<strong>空工程</strong>（Empty Project）</p><p><img src="/images/setup-forge-workspace-with-idea-1.png" alt="Create New Project"><br>“Project Name”自然可以随意填写，”Project Location”则是之前创建的目录，下方的”Project Format”推荐选”Directory Based”<br>点”Finish”之后应该会自动打开”Project Structure”窗口，如果没有的话可以按Ctrl+Alt+Shift+S或是从菜单栏”File –&gt; Project Structure”<br>打开窗口之后我们首先要选择SDK版本：先点左边的”Project”，然后在右边”Project SDK”里选一个，我是选了Java8，你当然可以选择任何版本（不要低于Java6）<br><img src="http://0f4529-files.oss-cn-hangzhou.aliyuncs.com/blog/setup-forge-idea/2.png" alt="Select Project SDK"><br>接着点左边的”Modules”,再点那个绿色的“+”号，接着选”Import Module”<br><img src="http://0f4529-files.oss-cn-hangzhou.aliyuncs.com/blog/setup-forge-idea/3.png" alt="Location of &quot;Import Module&quot;"><br>然后选forge-1.7.10-10.13.2.1258-src目录下的<code>forge-1.7.10-10.13.2.1258-src.iml</code>文件就好。<br>Import完了之后检查下有没有报错，如果没问题就可以点右下角OK。</p><p>重新cd到forge-1.7.10-10.13.2.1258-src目录下，执行如下三条命令让gradle自动建立运行配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ln -s ../.idea .</span><br><span class="line">gradle -i genIntellijRun</span><br><span class="line">rm .idea</span><br></pre></td></tr></table></figure><p>回到IDEA，然后有必要的话重新加载一下Project。继续选菜单栏”Run –&gt; Edit Configurations”,点左侧的”Minecraft Client”，修改”Working Directory”到<code>forge-1.7.10-10.13.2.1258-src/eclipse</code>。<br><img src="http://0f4529-files.oss-cn-hangzhou.aliyuncs.com/blog/setup-forge-idea/4.png" alt="Edit Configuration"><br>你也可以像我一样指定一个username。接着对”Minecraft Server”也如法炮制。然后右下角”OK”退出。</p><p>现在Forge应该就可以运行了，在IDEA的主界面右上角有这么一片区域，选”Minecraft Client”然后点右侧那个绿色的三角箭头即可<br><img src="http://0f4529-files.oss-cn-hangzhou.aliyuncs.com/blog/setup-forge-idea/5.png" alt="Execution Control Bar"></p><h1 id="一个Mod！"><a href="#一个Mod！" class="headerlink" title="一个Mod！"></a>一个Mod！</h1><p>如果之前的步骤都没有问题，你就可以继续了<br>为了更好地演示运行配置以及发布流程，我决定写一个Mod，添加一种矿石：“Xp Ore”,顾名思义，挖掉后能得到大量经验。</p><p>我们需要新建一个Module来写我们的代码：菜单栏”File –&gt; New Module”<br>我就叫XpOre好了，然后继续打开”Project Structure”，将<code>forge-1.7.10-10.13.2.1258-src</code>添加成为它的依赖。<br><img src="http://0f4529-files.oss-cn-hangzhou.aliyuncs.com/blog/setup-forge-idea/6.png" alt="Add to Dependencies"><br>那个菜单同样是点右边的绿色加号出来，点”Module Dependency”后在弹出来的窗口里选”forge-1.7.10-10.13.2.1258-src”然后”OK”即可。</p><p>之后就可以写Mod了！至于具体Mod怎么写我就不在这里提了，请各位参考其他文章。<br>这是我的代码和目录层次结构，请自行调整，我就不把每一步的细节都写出来了。<br>请记得把<code>java</code>和<code>resources</code>两个目录设置成代码根目录和资源根目录，具体方法是在文件夹上右键然后”Mark Directory As”<br><img src="http://0f4529-files.oss-cn-hangzhou.aliyuncs.com/blog/setup-forge-idea/7.png" alt="The Module Tree"><br>（xp_ore.png是矿石的材质，其实就是拿金矿石的材质把几个像素涂成绿色让它看起来比较像附魔瓶的颜色）<br>为了防止图挂，我再拿文本形式列一下目录</p><pre><code>XpOre├── src│   └── main│       ├── java (Sources Root)│       │   └── org│       │       └── devinprogress│       │           └── xpore│       │               └── XpOre.java│       └── resources (Resources Root)│           ├── assets│           │   └── xpore│           │       ├── lang│           │       │   └── en_US.lang│           │       └── textures│           │           └── blocks│           │               └── xp_ore.png│           └── mcmod.info└── XpOre.iml</code></pre><p>要想让这个Mod在IDEA里运行起来，有两种方式。第一种比较简单，直接菜单栏”Run –&gt; Edit Configurations –&gt; ‘Minecraft Client’ –&gt; Use classpath of mod …”下拉列表里选”XpOre”，保存退出运行即可。这种方式比较适合只开发一个Mod的情况。<br>当有N个Module互相依赖的时候，我推荐创建另一个Module，比方说，叫”Run”。然后令其依赖<code>forge-1.7.10-10.13.2.1258-src</code>和你需要加载的其他Module，然后”Use classpath of mod”选择”Run”即可。</p><h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><p>发布其实相当方便，把forge-1.7.10-10.13.2.1258-src文件夹里的<code>build.gradle</code>复制到<code>XpOre</code>文件夹下面<br>按自己喜好修改其中的<code>version</code>,<code>group</code>和<code>archivesBaseName</code>即可。比方说我的是：</p><pre><code>version = &quot;v0.1&quot;group= &quot;org.devinprogress.xpore&quot;archivesBaseName = &quot;XpOre-1.7.10&quot;</code></pre><p>然后在XpOre文件夹下<code>gradle build</code>即可。运行完成后，就能在<code>XpOre/build/libs/</code>文件夹下找到编译好的jar了。</p><p>最后来一张Mod的效果图<br><img src="http://0f4529-files.oss-cn-hangzhou.aliyuncs.com/blog/setup-forge-idea/8.png" alt="XpOre Mod"></p>]]></content>
    
    <summary type="html">
    
      Minecraft mod developing in seperated folders under linux with IDEA.
    
    </summary>
    
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="教程" scheme="http://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Minecraft" scheme="http://recursiveg.me/tags/Minecraft/"/>
    
      <category term="Java" scheme="http://recursiveg.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Minecraft Coremod开发杂事记</title>
    <link href="http://recursiveg.me/2014/11/minecraft-modding-with-asm/"/>
    <id>http://recursiveg.me/2014/11/minecraft-modding-with-asm/</id>
    <published>2014-11-04T13:48:53.000Z</published>
    <updated>2017-08-13T04:55:25.222Z</updated>
    
    <content type="html"><![CDATA[<p>表示最近时间荒废得厉害，主要都是耗在了<a href="http://www.minecraft.net" target="_blank" rel="noopener">Minecraft</a>这款游戏上。<br>Minecraft的一大魅力在于其几乎无穷的MODs，于是我也小试了一下Mod开发，顺便学习一下Java。<del>于是掉入了万劫不复的深坑</del><br>当然，我要做点和加个方块、改个合成表之类的不一样的事。<br>（教程中不少内容都参考了szszss的<a href="http://www.hakugyokurou.net/wordpress/?page_id=126" target="_blank" rel="noopener">博客</a>，在此表示深深的感谢）</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>关于这篇文章，不适合特别特别新的新人，我假设各位读者都有一些基础的编程经验。如果你是入门级别的，在MCBBS论坛的<a href="http://www.mcbbs.net/thread-54579-1-1.html" target="_blank" rel="noopener">编程开发板块</a>有不少不错的入门教程。<br>我假设各位读者都具备以下能力:</p><ul><li>会安装软件</li><li>了解基本的程序流程控制，比如判断、循环等</li><li>了解基本的OOP概念，比如类，继承等 （其实这条不是那么重要，Java看多了就自然会了 <del>一个原C程序员如是说</del>）</li><li>了解命令行、终端的基本使用方法</li><li>有方法正常访问国际互联网，如Facebook等</li><li>了解基本英语单词（这条似乎也不是那么重要，主要是希望大家能够在遇到问题时不要怕阅读英文资料）</li><li>（本教程面向Linux用户，Mac用户大同小异，Windows用户自己看着办）</li></ul><a id="more"></a><p>然后再来介绍一下要用到的工具:</p><ul><li><a href="http://mcp.ocean-labs.de/" target="_blank" rel="noopener">MCP</a>(Minecraft Coders’ Pack)主要负责反混淆Minecraft的代码，同时向Forge提供对应的文档</li><li><a href="http://files.minecraftforge.net/fml/" target="_blank" rel="noopener">FML</a>(Forge Mod Loader)提供了一些底层功能，如Mod加载，ASM等。</li><li><a href="http://www.minecraftforge.net" target="_blank" rel="noopener">Forge</a>提供了更高级的接口，如增加方块，修改合成表等。</li><li>ForgeGradle帮助建立开发环境和发布</li></ul><p>一般来说，FML都会附带在Forge里，在某些情况下，比如现在（2014年11月5日）1.8的Forge还未完成，但FML已放出，就可以单独只安装FML，先开始Coremod的开发。</p><h1 id="Intellij-IDEA配置教程"><a href="#Intellij-IDEA配置教程" class="headerlink" title="Intellij IDEA配置教程"></a>Intellij IDEA配置教程</h1><p>网上大部分教程都是讲Eclipse的，但是个人偏好IDEA，所以讲一下IDEA的配置流程。</p><ol><li><p>安装IDEA，没有必要找破解版，免费的Community Edition足够</p></li><li><p><a href="http://files.minecraftforge.net/" target="_blank" rel="noopener">下载</a>Forge代码，就是Src那个链接。请选择自己需要的版本，我以<code>1.7.10-Recommended</code>为例</p></li><li><p>解压到一个你看着顺眼的地方，然后依次执行以下命令</p><pre><code>gradle setupDecompWorkspacegradle ideagradle genIntellijRun</code></pre><p>没有装gradle也不想装的，可以用<code>./gradlew</code><br>强烈建议挂着代理或VPN做这事，否则将是极端痛苦的过程。<br>你也可以加上<code>-i</code>选项看滚滚的数据输出以不至于那么无聊。</p></li><li><p>打开IDEA，直接Open Project，选择目录下的.ipr文件应该就好了，你可以试着Run一下看看有没有什么问题。</p></li></ol><p>注：直接<code>gradle idea</code>现在是不被推荐的，可以尝试用<code>gradle ideaModule</code>代替，具体方法在<a href="http://www.devinprogress.org/2014/12/setup-forge-workspace-with-idea/" target="_blank" rel="noopener">我的另一篇日志</a>里有讲。<br>如果需要Socks代理的，可以这么来<code>gradle -DsocksProxyHost={代理服务器地址} -DsocksProxyPort={代理端口}</code></p><h1 id="代码管理与开发"><a href="#代码管理与开发" class="headerlink" title="代码管理与开发"></a>代码管理与开发</h1><p><del>源代码和资源文件都是放在<code>src</code>文件夹里的，有时要在多个不同的Mod间切换开发，我目前的解决方法是将代码统一放在别处，将src文件夹做软链接进来。同时我也非常推荐也用这种方法处理<code>build.gradle</code>文件。将代码放在别处还有个好处，就是可以用<code>git</code>来管理版本，而且可以用分支方便地管理对不同Minecraft版本做的修改。不管什么方式，自己习惯就好。</del></p><p>用了<code>gradle ideaModule</code>后，代码本身就分开放置了，不再需要这种方法了。</p><p>对于开发这一部分，自己深感无力(其实就是懒)，请参阅szszss的系列教程。<br>另外，现在已经没有Coremod文件夹了，所以所有Mod都放在Mods文件夹下，不同之处只在于<code>MANIFEST.MF</code>文件。</p><h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><p>感谢ForgeGradle，打包发布不再需要手动拷贝压缩一大堆文件了。首先，你需要修改下<code>build.gradle</code>文件，这也是我为什么推荐用软链接来管理它的原因。<br>以原始的文件为例：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version = <span class="string">"1.0"</span></span><br><span class="line">group= <span class="string">"com.yourname.modid"</span> <span class="comment">// http://maven.apache.org/guides/mini/guide-naming-conventions.html</span></span><br><span class="line">archivesBaseName = <span class="string">"modid"</span></span><br><span class="line"></span><br><span class="line">minecraft &#123;</span><br><span class="line">    version = <span class="string">"1.7.10-10.13.2.1230"</span></span><br><span class="line">    runDir = <span class="string">"eclipse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>archivesBaseName</code>和第一行<code>version</code>都可以自由修改，只会影响输出的jar文件的名字，关于<code>group</code>用途不明，有了解的求留言告知。<br>如果你打算把Mod升级到一个新的Forge版本，请务必修改<code>minecraft.version</code>和你的开发环境一致，否则会出现奇奇怪怪的问题。<br>修改好后，就可以用<code>gradle build</code>来编译了，同样建议开代理。编译好的jar在<code>build/libs</code>下。</p><p>如果是需要对MANIFEST进行修改的，比如Coremod，需要在<code>build.gradle</code>中minecraft块之后添加jar块:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jar &#123;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes <span class="string">'FMLCorePlugin'</span>: <span class="string">'org.devinprogress.uniskinmod.SkinCore'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你的一个jar包里既有普通Mod（以<code>@Mod</code>作Annotation的）又有Coremod，你还需要</p><pre><code>attributes &apos;FMLCorePluginContainsFMLMod&apos;: true</code></pre><p>否则普通Mod不会被载入。</p><h1 id="ASMTransformer"><a href="#ASMTransformer" class="headerlink" title="ASMTransformer"></a>ASMTransformer</h1><p>因为MCP坑爹的反混淆机制，开发者在处理Method或Field时需要对付三种不同的名字：</p><ol><li>形似<code>a</code>这样的混淆名，<code>obfName</code></li><li>形似<code>func_xxxx_a</code>这样的半混淆名，有时也称作<code>srgName</code></li><li>形似<code>doTick</code>这样的反混淆名，或称<code>mcpName</code></li></ol><p>关于为什么要有srgName，MCP是这么解释的：因为mcpName是任何人都可以贡献的（这是真的），所以会出现这么一种情况，有时为了更好地描述某个函数的功能，在次要版本升级时（比如1.7.1升级1.7.2），mcpName会发生变化，如果直接以mcpName进行编译，那么为1.7.1编译的Mod就无法在1.7.2上使用，即使其他方面都没有问题。于是为了解决这个问题，引入了相对固定的srgName。FML是这么处理名称的，在<code>gradle build</code>时，代码中所有的mcpName均会被混淆成srgName。然后在玩家运行游戏时，所有的obfName均被反混淆成srgName，即<code>RuntimeDeobfuscation</code>，运行时反混淆。</p><p>在你修改某个方法之前，首先必须定位它（废话）。定位一个方法需要四个信息：</p><ul><li>方法所在的类的完全限定名（这里这里指的是反混淆了的类名）</li><li>方法的srgName</li><li>方法的mcpName(用于在开发时确定方法，有时和srgName相同)</li><li>方法的Description，或者说，参数列表。</li></ul><p>类很好确定，每当一个新的类被加载时，都会调用<code>IClassTransformer</code>接口的<code>transform</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IClassTransformer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] transform(String obfuscatedClassName, String transformedClassName, <span class="keyword">byte</span>[] bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个参数就是反混淆了的类名，并且是点分割，大小写正确的，可以直接用<code>equals()</code>来判断。<br>但是方法名的判断就比较复杂，因为在ASM转换时，运行时反混淆还没有被执行，所以方法名全部都是obfName。更要命的是，如果方法的参数里有Minecraft的类，那么这个类名也是被混淆了的类名。</p><p>不过谢天谢地，我们有<code>FMLDeobfuscatingRemapper</code>，你可以用<code>FMLDeobfuscatingRemapper.INSTANCE</code>来取得实例。这个类提供了几个重要的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">mapMethodName</span><span class="params">(String obfedClassName, String obfedMethodName, String obfedMethodDescription)</span></span></span><br><span class="line"><span class="function">String <span class="title">mapFieldName</span><span class="params">(String obfedClassName, String obfedFieldName, String obfedFieldDescription)</span></span></span><br><span class="line"><span class="function">String <span class="title">mapMethodDesc</span><span class="params">(String obfedMethodDescription)</span></span></span><br></pre></td></tr></table></figure><p>其中<code>mapMethodName</code>和<code>mapFieldName</code>返回对应方法和字段的srgName，<code>mapMethodDesc</code>返回反混淆了的Description，也就是将<code>(Lbee;F)V</code>这种变为<code>(Lnet/minecraft/client/gui/GuiMainMenu;F)V</code>。</p><p>如果你需要在某个方法中添加大段的代码，我极度不推荐写长长的代码将所有这些操作码全部加到目标方法里去，这种方法枯燥至极，又不直观，还难于调试。我一般的方法是，使用<code>INVOKESTATIC</code>调用自己写好的函数，并将需要修改的变量作为参数传递，这样需要的代码不多，也易于调试和维护。</p><p>在向代码中添加操作，尤其是费时的操作时（比如网络IO）请务必谨慎选择插入的位置。因为大部分代码会在主线程中执行，一旦卡住轻则界面冻结，重则直接被服务器超时踢出。</p><p>我不是非常推荐让ASM自动计算栈大小和本地变量区大小，因为碰到一些比较复杂的类时会悲剧，比如<code>AbstractClientPlayer</code></p><p>如果你想清空一个方法让它什么都不做，请还是不要忘记加上RETURN</p><p>有时，开发环境下编译出的class和原始的class会有区别，所以还是建议用javap之类的工具看一下原始的字节码。</p><h1 id="AccessTransformer"><a href="#AccessTransformer" class="headerlink" title="AccessTransformer"></a>AccessTransformer</h1><p>有时，我们需要频繁调用某个private的Method或是Field，使用反射会有性能损失，而ASMTransformer也无效(因为无法通过编译)，这就到了AccessTransformer大显身手的时候了。<br>AccessTransformer用于将private或是protected的Method和Field变为public，这样在代码中就可以直接使用了。<br>你需要首先创建一个<code>*_at.cfg</code>的配置文件放在resources目录（就是放<code>mcmod.info</code>的目录）下，然后将其软链接到根目录下（和<code>build.gradle</code>同目录）。<br>配置文件的语法类似这样（这是<code>fml_at.cfg</code>的一部分）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> net.minecraft.entity.<span class="function">EntityList <span class="title">func_75618_a</span><span class="params">(Ljava/lang/Class;Ljava/lang/String;I)</span>V</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> net.minecraft.entity.EntityList field_75625_b #nameToClassMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> net.minecraft.item.crafting.CraftingManager <span class="title">func_92103_a</span><span class="params">(Lnet.minecraft.item.ItemStack;[Ljava/lang/Object;)</span>Lnet.minecraft.item.crafting.ShapedRecipes</span>;</span><br></pre></td></tr></table></figure><p>接着重建工作区：</p><pre><code>gradle clean setupDecompWorkspace idea --refresh-dependencies</code></pre><p>同样建议挂代理，用eclipse的同学把<code>idea</code>换成<code>eclipse</code>，有强迫症的同学可以加上<code>-i</code>选项。这样，开发环境下代码的改动就完成了。我在挂着代理的情况下大约需要8分钟。</p><p>为了让其在混淆环境下也能正常工作，你需要创建一个新的类，继承<code>AccessTransformer</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyATransformer</span> <span class="keyword">extends</span> <span class="title">AccessTransformer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyATransformer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"mymod_at.cfg"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的字符串就是配置文件名，然后在实现了<code>IFMLLoadingPlugin</code>的类里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAccessTransformerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MyATransformer.class.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外需要注意的是，AccessTransformer不会自动转换衍生类，所以在转换基类时请务必当心，否则会编译不通过。</p><p>在1.7.10及以上的版本中，可以在build.gradle文件的中加入以下内容，这样就不必再写IFMLLoadingPlugin了。其中的<code>mymod_at.cfg</code>文件要放在META-INF文件夹下。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jar &#123;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes <span class="string">'FMLAT'</span>: <span class="string">'mymod_at.cfg'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他杂七杂八的东西"><a href="#其他杂七杂八的东西" class="headerlink" title="其他杂七杂八的东西"></a>其他杂七杂八的东西</h1><ul><li>如果你想给MCP贡献mcpName，可以去IRC esper#mcp 找 MCPBot_Reborn</li><li>最新的反混淆名对应表可以在<a href="http://export.mcpbot.bspk.rs/" target="_blank" rel="noopener">MCPBot Export</a>找到</li><li>如果你厌倦了用文本编辑器搜索字符串来找srgName的话，可以试试<a href="https://github.com/bspkrs/MCPMappingViewer/" target="_blank" rel="noopener">MCPMappingViewer</a></li><li><a href="https://bitbucket.org/mstrobel/procyon" target="_blank" rel="noopener">Procyon</a>是个极好的Java反编译器</li></ul>]]></content>
    
    <summary type="html">
    
      Some notes on developing coremods for Minecraft, mainly about ASM &amp; AccessTransformer
    
    </summary>
    
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="教程" scheme="http://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Minecraft" scheme="http://recursiveg.me/tags/Minecraft/"/>
    
      <category term="Java" scheme="http://recursiveg.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>域名注册商更换</title>
    <link href="http://recursiveg.me/2014/07/domain-name-registrar-switched/"/>
    <id>http://recursiveg.me/2014/07/domain-name-registrar-switched/</id>
    <published>2014-07-16T05:43:25.000Z</published>
    <updated>2017-08-13T04:55:25.222Z</updated>
    
    <content type="html"><![CDATA[<p>昨天折腾了一天，把域名从Godaddy转移到了Name.com<br>表示基本没遇到什么麻烦，信用卡借用了家长的，付款也很方便。<br>关键是便宜啊。转入9美刀，续期11美刀,比Godaddy坑爹的18刀便宜太多了啊<del>~<br>而且还有免费的WHOIS保护啊</del>优惠码<code>PRIVACYPLEASE</code>超好记有木有！<br>虽然不是最便宜的但是Name.com的控制台相当美观呐~<br>结尾吐槽一句：在万网注册的都是真的勇士。</p>]]></content>
    
    <summary type="html">
    
      A note to the switch of domain name registrar
    
    </summary>
    
    
      <category term="Site Management" scheme="http://recursiveg.me/categories/Site-Management/"/>
    
    
      <category term="Site Management" scheme="http://recursiveg.me/tags/Site-Management/"/>
    
  </entry>
  
  <entry>
    <title>Programming with PTRACE, Part6 - 时间控制</title>
    <link href="http://recursiveg.me/2014/07/programming-with-ptrace-part6/"/>
    <id>http://recursiveg.me/2014/07/programming-with-ptrace-part6/</id>
    <published>2014-07-07T08:51:03.000Z</published>
    <updated>2017-08-13T04:55:25.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="不同的时间计算方法"><a href="#不同的时间计算方法" class="headerlink" title="不同的时间计算方法"></a>不同的时间计算方法</h1><p>程序运行会占用一小段时间（废话），事实上，我们有不止一种方法来表示一个程序运行了多长时间。最直观的应该是“墙上时间”，也就是说，你掐个秒表，看看程序从开始到结束用了多长时间。除此之外，还有“用户态时间”和“内核态时间”，这两个时间都是以CPU实际运算的时间，也就是CPU周期，来计数的。“用户态时间”就是程序在用户态执行的时间，包括程序所引用的库中的代码（比如STL），“内核态时间”就是指程序在内核态执行的时间，一般是各种系统调用（比如各种IO操作）。这两种时间和墙上时间的区别在于，因为CPU其实是在多个程序中快速切换的，所以在运行某个程序的时间里，CPU也处理了属于其他进程的任务，而且CPU切换任务也需要一定的时间（真的很短）。如果处于被调试状态，tracer的运行时间也会被计算在内，这些不属于这个进程的时间片也会被计算在这个进程的“墙上时间”里。所以一般以用户态时间和内核态时间的总和作为进程的运行时间。</p><p>在Linux系统里有一个叫<code>time</code>的命令可以查看一个命令执行了多长时间。这个命令有两个版本，一个是shell内置的，另一个是独立的可执行文件，可以用<code>type time</code>命令查看。虽然可执行版本功能更强一点，但内置的功能足够，这一点区别可以不管。用法是： <code>time [命令] &lt;参数&gt;</code>。给个例子：</p><pre><code>time ffmpeg -i sample.mp4 target.mp3...5.42s user0.10s system100% cpu5.520 total</code></pre><a id="more"></a><h1 id="动手写个带时限的time"><a href="#动手写个带时限的time" class="headerlink" title="动手写个带时限的time"></a>动手写个带时限的time</h1><p>还在对上个PART的<code>setrlimit</code>耿耿于怀么？我们现在就来用它！相关的定义位于<code>sys/resource.h</code>头文件里。我们这次要用到<code>RLIMIT_CPU</code>,这个选项限制进程所能占用的CPU时间，以秒为单位，可以把它理解为用户态时间和内核态时间的和。我们首先要使用<code>getrlimit</code>获得当前的限制：</p><pre><code>struct rlimit TimeL;getrlimit(RLIMIT_CPU,&amp;TimeL);</code></pre><p><code>rlimit</code>结构有两个成员:</p><ul><li><code>rlim_cur</code> 软限制</li><li><code>rlim_max</code> 硬限制</li></ul><p>系统一般会用比较平和的方式对待那些达到软限制的进程，比如发个SIGSEGV什么的。而那些达到硬限制的进程会被直接SIGKILL。我们接下来要修改软限制，注意单位是秒。</p><pre><code>TimeL.rlim_cur=Timeout;</code></pre><p>以上工作都要在<code>fork()</code>之前完成，之后要在<em>子进程</em>里应用这个限制（没错就是exec那里）</p><pre><code>setrlimit(RLIMIT_CPU,&amp;TimeL);</code></pre><p>这样，如果子进程超过软限制，系统就会发送<code>SIGXCPU</code>信号给子进程。当然，因为ptrace的原因，信号会被先发送给父进程，这样就可以用part3里介绍的方法进行处理。这样子进程是要清蒸还是油炸就都由父进程决定了。<br>当然，我们还有别的方法获取时间信息。一是用<code>gettimeofday()</code>函数配合<code>timeval</code>结构，可以获得当前时间，精确到微秒（百万分之一秒）。在程序开始时调用下，结束时调用下，相减即可得到墙上时间。另一种方法是利用<code>wait4</code>里的<code>ru</code>参数，它其实是个<code>rusage</code>结构,成员<a href="http://man7.org/linux/man-pages/man2/getrusage.2.html" target="_blank" rel="noopener">见此</a>。其中的<code>ru_utime</code>和<code>ru_stime</code>成员是<code>timeval</code>结构，分别记录了用户态时间和内核态时间，同样精确到微秒。</p><h1 id="程序睡着了"><a href="#程序睡着了" class="headerlink" title="程序睡着了"></a>程序睡着了</h1><p><code>RLIMIT_CPU</code>大多数情况下都能正常工作，配合<code>timeval</code>结构甚至能进一步提高精度。但是有两个例外（如果有更多请务必告诉我）：</p><ol><li>程序主动调用<code>sleep()</code></li><li>交互状态下<code>scanf()</code>一类的函数等待键盘输入</li></ol><p>在这两种情况下：进程不占用CPU时间，<code>RLIMIT_CPU</code>管不着；没有系统调用，<code>wait4()</code>不返回。为了能够在这种情况下依然能够限制时间，我想出了两种方法。一是限制和<code>sleep()</code>相关的系统调用，二是父进程设置ALARM。我在这里讲一下第二种方法。<br>Linux提供了一个<code>alarm()</code>函数，可以在指定的秒数<strong>(墙上时间)</strong>后给这个进程本身发送<code>SIGALRM</code>信号。而且，我们可以给信号绑定一个处理函数（就是当信号到达时调用的函数），在这个处理函数里，可以用<code>kill</code>命令给子进程发送信号（比如<code>SIGUSR1</code>），这样就能使父进程里的<code>wait4()</code>返回，就可以控制子进程了。以下是一个简要指导：<br>首先我们需要一个信号处理函数,记得把pid改成全局变量：</p><pre><code>void AlarmIn(int sig){    if(sig==SIGALRM)    kill(pid,SIGUSR1);}</code></pre><p>然后在子程序开始执行的时候绑定信号并设置Alarm，我在这设置超时一秒:</p><pre><code>signal(SIGALRM,AlarmIn);alarm(1);</code></pre><p>然后请根据part3所讲的内容在while循环里正确处理<code>SIGUSR1</code>。最后记得取消Alarm，如果没超时的话：</p><pre><code>alarm(0);</code></pre><h1 id="完整代码？"><a href="#完整代码？" class="headerlink" title="完整代码？"></a>完整代码？</h1><p>表示完整代码太长了，放这儿太不美观，<del>我会稍后贴到gist上去。</del>代码被幽幽子吃掉了大家自己写把。</p><h1 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h1><ul><li><a href="http://zh.wikipedia.org/wiki/%E6%95%B0%E9%87%8F%E7%BA%A7_%28%E6%97%B6%E9%97%B4%29" target="_blank" rel="noopener">Wikipedia - 数量级 (时间)</a> 我把这个链接放这儿是因为老有人把微秒缩写成<code>ms</code>然后和毫秒搞混</li><li><a href="http://blog.csdn.net/xwdok/article/details/542109" target="_blank" rel="noopener">协同式多任务与抢占式多任务</a></li><li><a href="http://www.cnblogs.com/iceocean/articles/1650929.html" target="_blank" rel="noopener">Linux时间管理</a></li><li><a href="http://russelltao.iteye.com/blog/1405353" target="_blank" rel="noopener">浅谈时间函数gettimeofday的成本</a></li></ul>]]></content>
    
    <summary type="html">
    
      Sixth part of serial of tutorial: Programming with PTRACE
    
    </summary>
    
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="Linux" scheme="http://recursiveg.me/tags/Linux/"/>
    
      <category term="PTRACE" scheme="http://recursiveg.me/tags/PTRACE/"/>
    
      <category term="教程" scheme="http://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Programming with PTRACE, Part5 - 内存管理</title>
    <link href="http://recursiveg.me/2014/05/programming-with-ptrace-part5/"/>
    <id>http://recursiveg.me/2014/05/programming-with-ptrace-part5/</id>
    <published>2014-05-26T02:00:32.000Z</published>
    <updated>2017-08-13T04:55:25.222Z</updated>
    
    <content type="html"><![CDATA[<p>这个part主要讲解Linux的内存管理机制，以及如何查看并限制子进程的内存使用。</p><h1 id="内存的划分"><a href="#内存的划分" class="headerlink" title="内存的划分"></a>内存的划分</h1><p>（嘛。。。这一部分也算是现学现卖的，如果大家觉得有什么讲的不到位的请翻下方的拓展阅读部分）<br>大家都知道，32位系统最大可以寻址4GB的地址空间（不考虑<a href="http://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E6%89%A9%E5%B1%95" target="_blank" rel="noopener">物理地址扩展</a>），那么这个“地址”究竟指的是哪儿的地址呢？你可以写一个小程序，malloc一点内存，然后把地址打印出来，重复几次，你会发现，分配的内存几乎都在同一个位置。这是因为，对于程序来说，这些地址都是虚拟地址，虚拟地址空间对于每个进程都是独立的，也就是说，对于不同的进程，同样虚拟地址上的数据是不同的。<br>当然，数据肯定是存放在内存条上的，我们把可以直接读写内存条的地址叫做物理地址。物理地址以一定的方式映射到虚拟地址上，所以当程序试图访问虚拟地址时，系统要以一定方式把虚拟地址变成物理地址，这项工作通常是由<a href="http://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83" target="_blank" rel="noopener">MMU(内存管理单元)</a>来完成的。内存的映射不是大块大块的，而是一小片一小片分别映射的，所以在虚拟地址上连续的地址可能在物理地址上相差十万八千里，这些一小片一小片的内存被称为“页”。<br>页的存在给内存分配带来了极大的灵活性，页可以存储在内存里，也可以存储在交换分区里，可以将同一块物理内存映射到不同进程的虚拟空间里（动态库经常这么干），甚至可以映射到磁盘上的某个文件。光说可能有点抽象，于是给幅图(来自Wikipedia)<br><img src="http://upload.wikimedia.org/wikipedia/commons/3/32/Virtual_address_space_and_physical_address_space_relationship.svg" alt="内存页映射是不连续的"><br>虚拟地址被分成多个段，数据有序存放于其中。这是32位Linux的新内存布局(Linux 2.6.7之后):<br><img src="http://static.duartes.org/img/blogPosts/linuxFlexibleAddressSpaceLayout.png" alt="Linux新内存布局"><br>如果你研究过可执行文件的结构，你就会发现，虚拟地址的段就是按可执行文件的段来填充的。另外，由于代码段的起点地址是固定的(0x08048000)，所以编译器就可以预先算出函数的地址了。顺带一提，因为动态库加载时的虚拟地址是不固定的，不能预先计算出函数地址，所以要在编译时使用<code>-fPIC</code>选项生成位置无关代码，否则每次被一个新进程使用时都要进行重定位(可以理解为重新计算函数地址)，并生成该动态库的一个副本，这样压根没有起到节约内存的作用。<br>扯远了，回来。尽管每个进程的虚拟地址空间时互相独立的，但并不意味着进程想访问哪儿就能访问的，比如3GB以上的区域，那儿是内核的领地。即使是堆段，也只能访问已申请的内存部分，非法的内存访问将会引发段错误(Segmentation Fault)。回到<code>malloc()</code>函数上，malloc最终会调用<code>brk</code>或<code>mmap</code>系统调用，brk用于在堆中分配小块内存，mmap则用于在Memory Mapping Segment中分配大块内存。但是并不是每次malloc都会调用brk，这是因为分配的内存实在是太小了，而brk只能分配大一点的内存，所以C运行库(比如glibc)在收到一个malloc时会先用brk向系统“批发”一块大一点的内存，而收到后续分配请求时则把这块大内存“零售”给程序，直到售完再次brk。<br>如果有一个程序死循环单纯malloc内存，内存会不会被吃光呢？答案是不会(我不清楚是不是真的有如此单纯的系统真的会挂掉)，因为系统发现，你只是分配了内存，却没有使用，于是它很机智地将那片内存设置为“可访问”，却没有把它映射到任何一个实际的内存页上！</p><a id="more"></a><h1 id="你用了多少内存？"><a href="#你用了多少内存？" class="headerlink" title="你用了多少内存？"></a>你用了多少内存？</h1><p>还记得之前的<code>rusage</code>结构么？其成员可在<a href="http://man7.org/linux/man-pages/man2/getrusage.2.html" target="_blank" rel="noopener">这里</a>找到。事实上，这是一种非常简陋的内存使用信息获取方式，我们只关心其中的<code>ru_maxrss</code>一项，RSS即”Resident Set Size”，表示该进程在物理内存中的占用大小，不包括交换分区中的内存大小，也不包含分配了却未使用而没有物理内存页的内存。为了获得更详细的内存信息，我们需要访问<code>/proc</code>目录。该目录下各文件的用途在<code>man 5 proc</code>里描述得很清楚，<a href="http://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="noopener">这里</a>是网页版本。关于这个目录的作用，我就偷懒，将man手册中的描述翻译如下：</p><blockquote><p><code>proc</code>文件系统是一个伪文件系统，提供了访问内核数据结构的接口。它通常被挂载在<code>/proc</code>上并且大部分是只读的，除了少数文件被允许用来改变内核参数。</p></blockquote><p><code>/proc</code>下有N多文件夹，大部分是按进程的pid来命名的，我们关心的是这些文件夹中的<code>status</code>文件。来看一个例子：<code>cat /proc/1/status|grep Vm</code></p><pre><code>VmPeak:      173616 kBVmSize:      107968 kBVmLck:           0 kBVmPin:           0 kBVmHWM:        3816 kBVmRSS:        3744 kBVmData:       83744 kBVmStk:         136 kBVmExe:        1140 kBVmLib:        2268 kBVmPTE:          72 kBVmSwap:           0 kB</code></pre><p>我们看到了两个令人感兴趣的东西：<code>VmData</code>和<code>VmStk</code>。分别代表了数据区和栈的大小，而且这两个数据是真正的可访问的虚拟内存大小，即不会像RSS那样，漏掉那些分配了而未访问的内存。当然，其他数据也都是很有趣的，有兴趣的人可以自己去翻man手册。这段代码计算给定进程的数据段和堆栈段内存使用总和。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getMemory</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pid_t</span> pid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> stat_loc[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">long</span> VmData,VmStk;</span><br><span class="line">    <span class="built_in">sprintf</span>(stat_loc,<span class="string">"/proc/%d/status"</span>,pid);</span><br><span class="line">    FILE *stat=fopen(stat_loc,<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">while</span>(EOF!=<span class="built_in">fscanf</span>(stat,<span class="string">"%[^\n]"</span>,line))&#123;</span><br><span class="line">        <span class="built_in">sscanf</span>(line,<span class="string">"VmData: %ld"</span>,&amp;VmData);</span><br><span class="line">        <span class="built_in">sscanf</span>(line,<span class="string">"VmStk: %ld"</span>,&amp;VmStk);</span><br><span class="line">        fgetc(stat);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> VmData+VmStk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="限制内存"><a href="#限制内存" class="headerlink" title="限制内存"></a>限制内存</h1><p>也许你们已经知道，有一个叫做<code>setrlimit</code>的函数可以用来限制资源使用，你们也许已经翻过了它的man手册，看到了<code>RLIMIT_AS</code> <code>RLIMIT_DATA</code> <code>RLIMIT_RSS</code>等一票似乎很有用的参数。现在，请你立刻忘掉他们！既然我们之前讲了<code>/proc</code>当然要用起来啦。我们不用<code>setrlimit</code>是因为，这种限制策略会导致malloc失败（确切的讲是brk和mmap失败），而大部分OIer都没有检查malloc返回值的的习惯，最终导致本应是MLE(Memory Limit Exceeded)的情况变成了由访问无效内存导致的RE(Runtime Error)。更糟糕的是，如果是系统栈增长被限制了，进程会被直接<code>SIGSEGV</code>，连errno都没有，这种情况下就更难分辨了。那么，有什么好的方法来限制内存呢？答案就是在每次分配内存的系统调用（不限于brk和mmap）时通过proc来检查内存使用，注意要在返回时检查哦。一旦超过，就由父进程直接杀死子进程，方法多种多样，你可以使用<code>ptrace(PTRACE_KILL,pid,0,0)</code>，或是用Part3所讲的方法发送信号，或是直接用<a href="http://man7.org/linux/man-pages/man2/kill.2.html" target="_blank" rel="noopener">kill函数</a>。这种方法看上去很不优雅，但确实很有效。至于那些对<code>setrlimit</code>耿耿于怀的同学，不要担心，下个part时间限制，将会大量用到。</p><h1 id="拓展阅读-amp-参考资料"><a href="#拓展阅读-amp-参考资料" class="headerlink" title="拓展阅读&amp;参考资料"></a>拓展阅读&amp;参考资料</h1><ul><li><a href="http://xixinfei.iteye.com/blog/1949123" target="_blank" rel="noopener">Linux内存管理详解</a></li><li><a href="http://www.itvane.net/?p=1240" target="_blank" rel="noopener">Linux进程地址空间详解</a></li><li><a href="http://www.cnblogs.com/clover-toeic/p/3754433.html" target="_blank" rel="noopener">Linux虚拟地址空间布局</a></li><li><a href="http://acm.tongji.edu.cn/cnfaqs" target="_blank" rel="noopener">OJ系统各状态含义</a>(见Question #6；应该还有一个RF:Restricted Function)</li><li><a href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/" target="_blank" rel="noopener">Anatomy of a Program in Memory</a></li><li>man手册</li></ul>]]></content>
    
    <summary type="html">
    
      Fifth part of serial of tutorial: Programming with PTRACE
    
    </summary>
    
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="Linux" scheme="http://recursiveg.me/tags/Linux/"/>
    
      <category term="PTRACE" scheme="http://recursiveg.me/tags/PTRACE/"/>
    
      <category term="教程" scheme="http://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Programming with PTRACE, Part4 - 系统调用进阶</title>
    <link href="http://recursiveg.me/2014/05/programming-with-ptrace-part4/"/>
    <id>http://recursiveg.me/2014/05/programming-with-ptrace-part4/</id>
    <published>2014-05-26T02:00:31.000Z</published>
    <updated>2017-08-13T04:55:25.222Z</updated>
    
    <content type="html"><![CDATA[<p>这个part是<a href="/2014/04/programming-with-ptrace-part2/">Part2</a>的延续，所以我强烈建议你弄明白Part2中的内容后再来看本part。那么进入正题，我将在这个部分讲解系统调用的参数传递顺序以及如何利用ptrace系统调用获得用户空间的数据。</p><h2 id="参数与寄存器"><a href="#参数与寄存器" class="headerlink" title="参数与寄存器"></a>参数与寄存器</h2><p>我在Part2中提到过，系统调用的参数是以一定顺序保存在寄存器里的，那么这个顺序是什么呢？在<code>man 2 syscall</code>中有两张表格解释了这个问题，你也可以在<a href="http://man7.org/linux/man-pages/man2/syscall.2.html" target="_blank" rel="noopener">这里</a>看到，就在”Architecture calling conventions”下面。我知道很多人很懒，所以我就把这两张表格复制过来了。</p><center><table><thead><tr><th align="left">arch/ABI</th><th align="left">instruction</th><th align="left">syscall #</th><th align="left">retval</th><th align="left">Notes</th></tr></thead><tbody><tr><td align="left">arm/OABI</td><td align="left">swi NR</td><td align="left">-</td><td align="left">a1</td><td align="left">NR is syscall #</td></tr><tr><td align="left">arm/EABI</td><td align="left">swi 0x0</td><td align="left">r7</td><td align="left">r0</td><td align="left"></td></tr><tr><td align="left">blackfin</td><td align="left">excpt 0x0</td><td align="left">P0</td><td align="left">R0</td><td align="left"></td></tr><tr><td align="left">i386</td><td align="left">int $0x80</td><td align="left">eax</td><td align="left">eax</td><td align="left"></td></tr><tr><td align="left">ia64</td><td align="left">break 0x100000</td><td align="left">r15</td><td align="left">r10/r8</td><td align="left">bool error/errno value</td></tr><tr><td align="left">parisc</td><td align="left">ble 0x100(%sr2, %r0)</td><td align="left">r20</td><td align="left">r28</td><td align="left"></td></tr><tr><td align="left">s390</td><td align="left">svc 0</td><td align="left">r1</td><td align="left">r2</td><td align="left">See below</td></tr><tr><td align="left">s390x</td><td align="left">svc 0</td><td align="left">r1</td><td align="left">r2</td><td align="left">See below</td></tr><tr><td align="left">sparc/32</td><td align="left">t 0x10</td><td align="left">g1</td><td align="left">o0</td><td align="left"></td></tr><tr><td align="left">sparc/64</td><td align="left">t 0x6d</td><td align="left">g1</td><td align="left">o0</td><td align="left"></td></tr><tr><td align="left">x86_64</td><td align="left">syscall</td><td align="left">rax</td><td align="left">rax</td><td align="left"></td></tr></tbody></table><table><thead><tr><th align="left">arch/ABI</th><th align="left">arg1</th><th align="left">arg2</th><th align="left">arg3</th><th align="left">arg4</th><th align="left">arg5</th><th align="left">arg6</th><th align="left">arg7</th></tr></thead><tbody><tr><td align="left">arm/OABI</td><td align="left">a1</td><td align="left">a2</td><td align="left">a3</td><td align="left">a4</td><td align="left">v1</td><td align="left">v2</td><td align="left">v3</td></tr><tr><td align="left">arm/EABI</td><td align="left">r0</td><td align="left">r1</td><td align="left">r2</td><td align="left">r3</td><td align="left">r4</td><td align="left">r5</td><td align="left">r6</td></tr><tr><td align="left">blackfin</td><td align="left">R0</td><td align="left">R1</td><td align="left">R2</td><td align="left">R3</td><td align="left">R4</td><td align="left">R5</td><td align="left">-</td></tr><tr><td align="left">i386</td><td align="left">ebx</td><td align="left">ecx</td><td align="left">edx</td><td align="left">esi</td><td align="left">edi</td><td align="left">ebp</td><td align="left">-</td></tr><tr><td align="left">ia64</td><td align="left">out0</td><td align="left">out1</td><td align="left">out2</td><td align="left">out3</td><td align="left">out4</td><td align="left">out5</td><td align="left">-</td></tr><tr><td align="left">parisc</td><td align="left">r26</td><td align="left">r25</td><td align="left">r24</td><td align="left">r23</td><td align="left">r22</td><td align="left">r21</td><td align="left">-</td></tr><tr><td align="left">s390</td><td align="left">r2</td><td align="left">r3</td><td align="left">r4</td><td align="left">r5</td><td align="left">r6</td><td align="left">r7</td><td align="left">-</td></tr><tr><td align="left">s390x</td><td align="left">r2</td><td align="left">r3</td><td align="left">r4</td><td align="left">r5</td><td align="left">r6</td><td align="left">r7</td><td align="left">-</td></tr><tr><td align="left">sparc/32</td><td align="left">o0</td><td align="left">o1</td><td align="left">o2</td><td align="left">o3</td><td align="left">o4</td><td align="left">o5</td><td align="left">-</td></tr><tr><td align="left">sparc/64</td><td align="left">o0</td><td align="left">o1</td><td align="left">o2</td><td align="left">o3</td><td align="left">o4</td><td align="left">o5</td><td align="left">-</td></tr><tr><td align="left">x86_64</td><td align="left">rdi</td><td align="left">rsi</td><td align="left">rdx</td><td align="left">r10</td><td align="left">r8</td><td align="left">r9</td><td align="left">-</td></tr></tbody></table></center><a id="more"></a>表格内容虽多，但其实我们关心的只有i386和x86_64（32位和64位）一共4行（因为有两张表格嘛）。精简提炼下，一共就两句话<blockquote><p>对于32位系统，系统调用号存放在EAX寄存器，参数依次放入EBX、ECX、EDX、ESI … 返回值位于EAX寄存器<br>  对于64位系统，系统调用号存放在RAX寄存器，参数依次放入RDI、RSI、RDX、R10 … 返回值位于RAX寄存器</p></blockquote><p>以64位系统下的<code>write()</code>调用为例:</p><pre><code>ssize_t write(int fd, const void *buf, size_t count);</code></pre><p>那么RAX是1(write的调用号)，RDI一般为1(stdout),RSI存储着指向用户空间中将要被输出的字符串的地址，RDX自然就是字符串长度啦。</p><h2 id="获取那个字符串"><a href="#获取那个字符串" class="headerlink" title="获取那个字符串"></a>获取那个字符串</h2><p>理论讲完了，进入实战。这次我们拿<code>open()</code>系统调用开刀，一是因为监视程序打开了什么文件比得知输出了什么更常用，二是因为传递给<code>open()</code>的字符串没有长度信息，只能自己通过<code>\0</code>判断，更有挑战性。我们这次要使用ptrace的一个新功能<code>PTRACE_PEEKTEXT</code>,其实还有另外一个叫做<code>PTRACE_PEEKDATA</code>的，不过根据man手册的描述，这两个的功能是一样的。它的用法是这样的</p><pre><code>data = ptrace(PTRACE_PEEKTEXT,pid,addr,0);</code></pre><p>即从子进程（由pid标识）的addr内存地址处取出对应字长(64位为8字节，32位4字节)的数据，做为返回值。也就是说，读取一次能得到八个字符。现在如果我们要取得从<code>base_addr</code>地址开始的一个字符串，那么我们只要8个字节8个字节读取，直到碰到<code>\0</code>为止。把这个功能写成函数就是这样：（32位系统不要忘记改那个define）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WORD_LEN 8</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">peek_str</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">long</span> base_addr,<span class="keyword">char</span> target[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">union</span>&#123;</span><br><span class="line">    <span class="keyword">long</span> word;</span><br><span class="line">    <span class="keyword">char</span> str[WORD_LEN];</span><br><span class="line">  &#125; data;<span class="comment">/*利用union把WORD_LEN字节的整数变为字符数组*/</span></span><br><span class="line">  <span class="keyword">long</span> offset=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> done=<span class="number">0</span>,i;</span><br><span class="line">  target[<span class="number">0</span>]=<span class="string">'\0'</span>;</span><br><span class="line">  <span class="keyword">while</span>(!done)&#123;<span class="comment">/*循环读取*/</span></span><br><span class="line">    data.word=ptrace(PTRACE_PEEKTEXT,pid,base_addr+offset,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">strncat</span>(target,data.str,WORD_LEN);<span class="comment">/*追加至多WORD_LEN个字符*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;WORD_LEN;i++)<span class="comment">/*检查是否有'\0'*/</span></span><br><span class="line">      <span class="keyword">if</span>(data.str[i]==<span class="string">'\0'</span>)</span><br><span class="line">        done=<span class="number">1</span>;</span><br><span class="line">    offset+=WORD_LEN;<span class="comment">/*准备读取下一个WORD_LEN字节*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主程序的大<code>while()</code>循环里的代码是这样的（我已经设置了<code>PTRACE_O_TRACESYSGOOD</code>标记）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">wait4(pid,&amp;sta,<span class="number">0</span>,&amp;ru);</span><br><span class="line"><span class="keyword">if</span>(WIFEXITED(sta))&#123;<span class="built_in">printf</span>(<span class="string">"Exited with code %d"</span>,WEXITSTATUS(sta));<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(WIFSIGNALED(sta))&#123;<span class="built_in">printf</span>(<span class="string">"Terminated by signal: %s"</span>,strsignal(WTERMSIG(sta)));<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">int</span> sig_no;<span class="keyword">if</span>(WIFSTOPPED(sta))sig_no=WSTOPSIG(sta);<span class="keyword">else</span>&#123;<span class="built_in">puts</span>(<span class="string">"Unknown Status"</span>);<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(sig_no!=(SIGTRAP|<span class="number">0x80</span>))&#123;ptrace(PTRACE_SYSCALL,pid,<span class="number">0</span>,sig_no);<span class="keyword">continue</span>;&#125;</span><br><span class="line"><span class="keyword">if</span> (intocall)&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> <span class="title">reg</span>;</span></span><br><span class="line">  ptrace(PTRACE_GETREGS,pid,<span class="number">0</span>,&amp;reg);</span><br><span class="line">  <span class="keyword">if</span> (reg.orig_rax==SYS_open)&#123;</span><br><span class="line">    <span class="keyword">char</span> file[<span class="number">255</span>];</span><br><span class="line">    peek_str(pid,reg.rdi,file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"open() opened: %s\n"</span>,file);</span><br><span class="line">  &#125;      </span><br><span class="line">&#125;</span><br><span class="line">intocall^=<span class="number">1</span>;</span><br><span class="line">ptrace(PTRACE_SYSCALL,pid,<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在这里我使用的<code>PTRACE_GETREGS</code>和<code>user_regs_struct</code>结构来一次性获得所有寄存器的值，该结构定义于<code>sys/user.h</code>头文件中。另外，我还使用了<code>SYS_open</code>来判断系统调用号，避免了Magic Number。<code>SYS_*</code>宏定义于<code>sys/syscall.h</code>头文件中。传递RDI寄存器也很容易理解，查询<code>man 2 open</code>可知open系统调用的路径是第一个参数。现在，重新编译你的<code>target</code>，不要加<code>-static</code>,然后运行，你应该能看到类似这样的输出。</p><pre><code>Parent startedChild PiD == 4717Child exec...Child execve() returned with 0open() opened: /usr/lib/tls/x86_64/libc.so.6open() opened: /usr/lib/tls/libc.so.6open() opened: /usr/lib/x86_64/libc.so.6open() opened: /usr/lib/libc.so.6Hello World!Exited with code 0</code></pre><p>可以很明显的看到程序搜索动态链接库的过程。<br>如果你觉得这还不够过瘾，那么你可以看<a href="http://www.kgdb.info/gdb/playing_with_ptrace_part_i/" target="_blank" rel="noopener">Playing with ptrace, part1</a>,后面提供了一个配合使用<code>PTRACE_PEEKTEXT</code>和<code>PTRACE_POKETEXT</code>来将<code>write</code>输出的字符串反转的例子</p><h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><ul><li><a href="http://godorz.info/2011/02/how-debuggers-work-part-1" target="_blank" rel="noopener">调试器是怎样工作的</a></li><li><a href="http://linuxgazette.net/issue81/sandeep.html" target="_blank" rel="noopener">Process Tracing Using Ptrace</a></li></ul><h2 id="不是后记的后记"><a href="#不是后记的后记" class="headerlink" title="不是后记的后记"></a>不是后记的后记</h2><p>不知不觉已经写到Part4了，期间一边查资料一边写代码做验证一边写这篇文章，又发现了好多好多之前遗漏的信息和好文章。同时深深感觉自己真是个蒟蒻，好多东西觉得很重要，想讲却心有余而力不足，而且越来越像是在翻译man手册了……我是不是一开始就应该去翻译手册而不是写这系列文章呢？（笑）<br>下个part开始，估计就要暂时和ptrce说再见，然后和内存管理开始较劲了。</p>]]></content>
    
    <summary type="html">
    
      Fourth part of serial of tutorial: Programming with PTRACE
    
    </summary>
    
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="Linux" scheme="http://recursiveg.me/tags/Linux/"/>
    
      <category term="PTRACE" scheme="http://recursiveg.me/tags/PTRACE/"/>
    
      <category term="教程" scheme="http://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Programming with PTRACE, Part3 - 进程的终止与信号</title>
    <link href="http://recursiveg.me/2014/05/programming-with-ptrace-part3/"/>
    <id>http://recursiveg.me/2014/05/programming-with-ptrace-part3/</id>
    <published>2014-05-25T10:26:20.000Z</published>
    <updated>2017-08-13T04:55:25.222Z</updated>
    
    <content type="html"><![CDATA[<p>在Part2中，我们粗略了解了如何使用<code>ptrace</code>获得系统调用信息，即在一个大循环里不断获取程序信息，如果程序退出则停止循环。当然，那个判断异常简陋，几乎无法处理任何特殊情况。我将在本Part中详细解说各种异常情况的处理，同时讲解各种信号相关的问题。</p><h2 id="一些重要的宏"><a href="#一些重要的宏" class="headerlink" title="一些重要的宏"></a>一些重要的宏</h2><p>在使用<code>wait4</code>后，程序的信息被存储在<code>sta</code>变量中，这些信息被存储在这个整数的不同二进制位上，这儿有一系列宏用于帮我们提取这些信息。以下信息是我对<code>man 3 wait</code>中相关部分的翻译,同时参考了<a href="http://www.manualpages.de/OpenBSD/OpenBSD-5.0/man2/WIFEXITED.2.html" target="_blank" rel="noopener">这个</a>页面</p><pre><code>WIFEXITED   如果进程正常退出，返回一个非0值(通常是进程调用了`exit()`或是`_exit()`)WIFSIGNALED 如果进程由于一个未被捕获的信号而被终止，返回一个非0值WIFSTOPPED  当进程被停止(非终止)时，返回一个非0值(通常发生在当进程处于`traced`状态时)WEXITSTATUS 当`WIFEXITED`为非0值，获得进程`main()`函数的返回值WTERMSIG    如果`WIFSIGNALED`为非0值，获得引起进程终止的信号代码WSTOPSIG    如果`WIFSTOPPED`为非0值，获得引起进程停止的信号代码</code></pre><p>除了这六个，还有<code>WIFCONTINUED</code>和<code>WCOREDUMP</code>两个宏，不过我们用不到，我也没仔细研究，就不说了。<br>当进程自行终止时，<code>WIFEXITED</code>即为<code>true</code>，配套使用<code>WEXITSTATUS</code>获得返回值，不做过多解释。当子进程进行系统调用时，<code>WIFSTOPPED</code>为<code>true</code>,同时<code>WSTOPSIG</code>等于<code>SIGTRAP</code>(信号代码为7),我们可以用这种方法区分<code>syscall-stop</code>和<code>signal-delivery-stop</code>。当有一个外部信号要发送给子进程，这个信号会先到达父进程，使<code>WIFSTOPPED</code>为<code>true</code>，同时<code>WSTOPSIG</code>等于该信号的信号代码。父进程可以选择将这个信号继续传递或是不传递，甚至传递另一个信号给子进程。一旦信号真正到达子进程，就进入子进程自己的处理流程或是系统默认动作，可能触发<code>WIFSIGNALED</code>，比如<code>SIGINT</code>。<br>在所有信号中，<code>SIGKILL</code>是一个例外，它不会经过父进程引发<code>WIFSTOPPED</code>，而是直接传递到子进程，引发<code>WIFSIGNALED</code>。</p><a id="more"></a><h2 id="信号的传递与修改"><a href="#信号的传递与修改" class="headerlink" title="信号的传递与修改"></a>信号的传递与修改</h2><p>之前提到，父进程需要将信号传递给子进程，这是由<code>ptrace(PTRACE_SYSCALL,pid,0,0)</code>的第四个参数决定的。如果为0,就不传递信号，否则传递对应代码的信号，比如<code>ptrace(PTRACE_SYSCALL,pid,0,9)</code>就将信号9(SIGKILL)传递给了子进程。<br>修改信号简直信手拈来，传一个你想要传的信号即可。</p><h2 id="strsignal-和代码"><a href="#strsignal-和代码" class="headerlink" title="strsignal()和代码"></a>strsignal()和代码</h2><p><code>strsignal()</code>接受一个整数参数，返回<code>const char*</code>，用于把信号代码变为对应的、人类可读的字符串描述，定义于<code>string.h</code>。下面给出判断程序退出的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wait4(pid,&amp;sta,<span class="number">0</span>,&amp;ru);</span><br><span class="line"><span class="keyword">if</span>(WIFEXITED(sta))&#123;<span class="built_in">printf</span>(<span class="string">"Exited with code %d"</span>,WEXITSTATUS(sta));<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(WIFSIGNALED(sta))&#123;<span class="built_in">printf</span>(<span class="string">"Terminated by signal: %s"</span>,strsignal(WTERMSIG(sta)));<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">int</span> sig_no;</span><br><span class="line"><span class="keyword">if</span>(WIFSTOPPED(sta))sig_no=WSTOPSIG(sta);</span><br><span class="line"><span class="keyword">if</span>(sig_no==SIGTRAP)sig_no=<span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line">ptrace(PTRACE_SYSCALL,pid,<span class="number">0</span>,sig_no);</span><br></pre></td></tr></table></figure><h2 id="来自ptrace的高级选项"><a href="#来自ptrace的高级选项" class="headerlink" title="来自ptrace的高级选项"></a>来自ptrace的高级选项</h2><p>你也许会纠结，如果外部传递了一个<code>SIGTRAP</code>信号，那么如何分辨呢？答案是使用<code>PTRACE_SETOPTIONS</code>设置<code>PTRACE_O_TRACESYSGOOD</code>标记，即在while之前，第一个wait之后，第一个<code>PTRACE_SYSCALL</code>之前，使用<code>ptrace(PTRACE_SETOPTIONS,pid,0,PTRACE_O_TRACESYSGOOD)</code>。这会使得<code>syscall-stop</code>导致的<code>WSTOPSIG</code>从<code>SIGTRAP</code>变为<code>SIGTRAP|0x80</code>，而普通的来自外部的<code>SIGTRAP</code>依然是<code>SIGTRAP</code>。</p>]]></content>
    
    <summary type="html">
    
      Third part of serial of tutorial: Programming with PTRACE
    
    </summary>
    
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="Linux" scheme="http://recursiveg.me/tags/Linux/"/>
    
      <category term="PTRACE" scheme="http://recursiveg.me/tags/PTRACE/"/>
    
      <category term="教程" scheme="http://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Programming with PTRACE, Part2 - 系统调用入门</title>
    <link href="http://recursiveg.me/2014/04/programming-with-ptrace-part2/"/>
    <id>http://recursiveg.me/2014/04/programming-with-ptrace-part2/</id>
    <published>2014-04-20T12:00:19.000Z</published>
    <updated>2017-08-13T04:55:25.222Z</updated>
    
    <content type="html"><![CDATA[<p>在这部分，我会介绍如何使用ptrace监控子进程的系统调用。我先将完整代码列在开头，你现在十有八九看不懂它，但我希望你在看完这篇文章后能彻底理解这段代码。（这段代码在64位系统上有效，32位系统请参照最后<code>给32位系统的Tip</code>手动修改源代码）</p><figure class="highlight c"><figcaption><span>demo4.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/reg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Parent started"</span>);</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  pid=fork();</span><br><span class="line">  <span class="keyword">if</span> (pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"fork() failed"</span>);</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pid==<span class="number">0</span>)&#123;</span><br><span class="line">    ptrace(PTRACE_TRACEME,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Child sleeping..."</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Child exec..."</span>);</span><br><span class="line">    execlp(<span class="string">"./target"</span>,<span class="string">"target"</span>,<span class="literal">NULL</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Child PiD == %d\n"</span>,pid);</span><br><span class="line">    <span class="keyword">int</span> sta=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rusage</span> <span class="title">ru</span>;</span></span><br><span class="line">    wait4(pid,&amp;sta,<span class="number">0</span>,&amp;ru);</span><br><span class="line">    <span class="keyword">long</span> rax_rt=ptrace(PTRACE_PEEKUSER,pid,<span class="number">8</span>*RAX,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Child execve() returned with %ld\n"</span>,rax_rt);</span><br><span class="line">    ptrace(PTRACE_SYSCALL,pid,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> intocall=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      wait4(pid,&amp;sta,<span class="number">0</span>,&amp;ru);</span><br><span class="line">      <span class="keyword">if</span> (WIFEXITED(sta))&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Child Exited"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">long</span> _ORIG_RAX=ptrace(PTRACE_PEEKUSER,pid,<span class="number">8</span>*ORIG_RAX,<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">long</span> _RAX=ptrace(PTRACE_PEEKUSER,pid,<span class="number">8</span>*RAX,<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (intocall)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Entering SYSCALL %ld .... "</span>,_ORIG_RAX);</span><br><span class="line">        intocall=<span class="number">0</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Exited with %ld\n"</span>,_RAX);</span><br><span class="line">        intocall=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ptrace(PTRACE_SYSCALL,pid,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="运行我们的程序"><a href="#运行我们的程序" class="headerlink" title="运行我们的程序"></a>运行我们的程序</h2><p>当然，如果你试图直接编译并运行上面这段程序肯定是失败的，因为你缺少一个用于被执行的“target”（就是execlp里的那个）。在这里，我们的第一个target是最经典的“Hello World!”程序：</p><figure class="highlight c"><figcaption><span>target.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Hello World!"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我建议你静态方式进行链接：</p><pre><code>gcc -static target.c -o target</code></pre><p>注意到我这里使用了<code>-static</code>参数，它的作用是将c运行时库静态链接入可执行文件中。你可以比较一下用两种方式编译的文件大小（几K和几百K的区别）。虽然用动态链接也可以，但是会和我之后的输出有一点点出入（因为动态链接文件需要根据环境变量搜索动态库）。现在把<code>target</code>和<code>demo4.c</code>放在同一目录下，然后</p><pre><code>gcc demo4.c -o demo4 &amp;&amp; ./demo4</code></pre><p>如果运行正确，你应该看到类似如下的输出</p><pre><code>Parent startedChild PiD == 9702Child sleeping...Child exec...Child execve() returned with 0Entering SYSCALL 63 .... Exited with 0Entering SYSCALL 12 .... Exited with 31248384Entering SYSCALL 12 .... Exited with 31252928Entering SYSCALL 158 .... Exited with 0Entering SYSCALL 89 .... Exited with 55Entering SYSCALL 12 .... Exited with 31388096Entering SYSCALL 12 .... Exited with 31391744Entering SYSCALL 5 .... Exited with 0Entering SYSCALL 9 .... Exited with 140378408579072Hello World!Entering SYSCALL 1 .... Exited with 13Entering SYSCALL 231 .... Child Exited</code></pre><h2 id="深入这段代码"><a href="#深入这段代码" class="headerlink" title="深入这段代码"></a>深入这段代码</h2><p>我先介绍一下各个头文件的用途：</p><ul><li><code>stdio.h</code>：（如果你不知道这个文件是干嘛的请重学C语言）</li><li><code>unistd.h</code>：提供<code>fork()</code>、<code>pid_t</code>、<code>execlp()</code>、<code>sleep()</code>等</li><li><code>sys/ptrace.h</code>：提供ptrace相关函数和宏定义</li><li><code>sys/wait.h</code>：提供<code>wait4()</code>和<code>WIFEXITED</code>宏</li><li><code>sys/resource.h</code>：提供<code>rusage</code>结构定义</li><li><code>sys/reg.h</code>：提供寄存器系列宏定义（<code>ORIG_RAX</code>等）</li></ul><p>看到代码的第15行，一个巨大的<code>if...else...</code>将代码清晰地分成了父子进程两个部分，16行的<code>ptrace(PTRACE_TRACEME,0,0,0);</code>首先吸引了我们的注意力。（为什么有一种在写春游作文的感觉）这个调用使得子进程被标记为<code>TRACED</code>并且使系统内核在子进程调用exec族函数<em>之后</em>通知父进程，这也是为什么17到19行的系统调用没有被追踪到的原因。<br>再看父进程部分，由于系统调用是一个从用户态到内核态再到用户态的过程，所以每进行一次系统调用都会触发两次<code>syscall_stop</code>,分别是进入时的<code>syscall_enter_stop</code>和离开内核时的<code>syscall_exit_stop</code>。这种子进程的状态的变化可以在父进程中使用<code>wait()</code>、<code>waitpid()</code>、<code>wait4()</code>等一票函数完成（还记得part1课后阅读中的僵尸进程么？）。值得注意的是，第一次的状态变化是由<code>execve()</code>调用返回导致的<code>syscall_exit_stop</code>，所以我在25到29行单独做了处理。我喜欢使用<code>wait4()</code>的原因是它还可以获得子进程的当前资源占用情况（就是那个<code>rusage</code>结构），这对于了解进程资源使用情况非常有用，只不过现在还用不到（我应该会在之后专门开几个part来讲系统资源的限制），所以我们只要关注那个<code>sta</code>就可以了。<br>注意下面那个大的<code>while</code>循环，在每次循环的开头等待，一旦<code>wait4()</code>返回，子进程就已经进入了暂停的状态（其实是内核给子进程发送了<code>SIGTRAP</code>信号，但因为子进程处于<code>TRACED</code>状态，所以这个信号被转交给了父进程，使父进程的<code>wait4()</code>返回，但这也意味着由其他方式引起的信号(比如<code>kill</code>命令)也会引起wait4的返回）。接着在32行使用<code>WIFEXITED</code>宏加上wait4收集的状态信息<code>sta</code>判断子进程是否已经退出，如果已退出，那么父进程也从循环中退出。当然这是一个非常粗糙的处理方式，更具完整的处理流程将在之后的part里介绍。接着，我们就可以使用各种各样的命令来调戏子进程了，这里我们只是简单的取得系统调用号和返回值。最后，在45行，让子进程继续执行，并要求子进程在下一个系统调用（进入或返回）停住，然后父进程开始等待下一次的<code>syscall_stop</code>。因为一次系统调用会导致两次<code>syscall_stop</code>，所以我使用变量<code>intocall</code>来分辨，并且在38到44行打印出不同的提示信息。顺带提一下，在输出中，<code>Hello World!</code>应该输出在<code>Entering SYSCALL 1</code>和<code>Exited with 13</code>中间，但因为缓冲区刷新的问题所以被输出到了前面。</p><p>终于到最激动人心的部分了！36、37两行代码是最重要的部分，可以看出，他们做的工作是差不多的，都是从子进程的内存空间中取一些数据。为了解释好这两行，我要讲一讲系统调用的调用过程。系统调用和普通的函数调用差不多，函数调用是将参数以约定好的顺序压入栈中，而系统调用则发生了一个类似上下文切换的过程：程序将需要调用的系统调用的调用号以及参数存入寄存器中，然后将所有寄存器存入栈中，进入内核态后，内核从栈中取得调用号和调用参数，并将返回值写入栈中对应寄存器的位置，最后还原寄存器的值并返回用户态，于是返回值就这样被“还原”到了寄存器里。在x86-64平台上，负责传递系统调用号和返回值的都是<code>RAX</code>寄存器，也就是说返回值会覆盖调用号，为了在系统调用返回时也能知道调用号，<code>RAX</code>寄存器在保存时被入栈两遍，一个是用于保存返回值的<code>RAX</code>，另一个是负责保存调用号的<code>ORIG_RAX</code>。现在，我们要获得寄存器的值，只要访问栈中的对应位置就可以了。而系统内核又会在系统调用时将栈中的这些信息复制一遍到一个叫做<code>u-area</code>(USER Area)的内存区域。在<code>sys/reg.h</code>头文件中定义了各寄存器保存时在<code>u-area</code>中的顺序，乘以每个寄存器的长度（64位系统自然就是8了嘛~~）就得到了我们所要访问的字节偏移量，<code>PTRACE_PEEKUSER</code>要求ptrace从指定偏移取出一个寄存器长度的数据（也就是8字节）作为返回值，于是<code>ptrace(PTRACE_PEEKUSER,pid,8*ORIG_RAX,0)</code>就能获得系统调用号啦！</p><h2 id="给32位系统的Tip"><a href="#给32位系统的Tip" class="headerlink" title="给32位系统的Tip"></a>给32位系统的Tip</h2><p>要让程序通过编译，需要做两个改动：</p><ol><li><p>在<code>int main()</code>之前加入这两个预处理命令：</p><pre><code>#define RAX EAX#define ORIG_RAX ORIG_EAX</code></pre></li><li><p>把26、36、37行ptrace第三个参数中的8全部改成4</p></li></ol><p>这是因为32位系统的寄存器长度是4字节，而且负责传递系统调用号和返回值的是<code>EAX</code>寄存器。</p><h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><ul><li><a href="http://sourceforge.net/projects/strace/" target="_blank" rel="noopener">strace</a>是一个用于监视并输出某程序系统调用情况的工具，比如<code>strace ./target</code></li><li><a href="http://man7.org/linux/man-pages/man7/signal.7.html" target="_blank" rel="noopener">Linux信号代码</a>：也可以通过查man手册得到<code>man 7 signal</code></li><li><a href="http://www.kgdb.info/gdb/playing_with_ptrace_part_i/" target="_blank" rel="noopener">Playing with ptrace</a>：Pradeep Padala 的关于ptrace的文章。</li><li><a href="http://blog.rchapman.org/post/36801038863/linux-system-call-table-for-x86-64" target="_blank" rel="noopener">x86_64 系统调用号列表</a>：也可以在<code>asm/unistd_64.h</code>头文件中找到，<code>asm/unistd_32.h</code>就是32位的</li><li><a href="http://www.hep.wisc.edu/~pinghc/Process_Memory.htm" target="_blank" rel="noopener">Process and Process Memory</a></li><li><strong>有问题或意见请务必留言啊啊啊啊~</strong>没人留言都不知道评论系统是否工作正常</li></ul>]]></content>
    
    <summary type="html">
    
      Second part of serial of tutorial: Programming with PTRACE
    
    </summary>
    
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="Linux" scheme="http://recursiveg.me/tags/Linux/"/>
    
      <category term="PTRACE" scheme="http://recursiveg.me/tags/PTRACE/"/>
    
      <category term="教程" scheme="http://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Programming with PTRACE, Part1 - 起步</title>
    <link href="http://recursiveg.me/2014/04/programming-with-ptrace-part1/"/>
    <id>http://recursiveg.me/2014/04/programming-with-ptrace-part1/</id>
    <published>2014-04-17T13:16:29.000Z</published>
    <updated>2017-08-13T04:55:25.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人作为一个信息学竞赛的参与者，在很久之前曾经试图自己写过一个Online Judge系统（允许用户上传源代码并在服务器上编译运行），考虑到安全因素，必须要对程序的行为进行限制，因此对ptrace进行了一番研究。网上有一份关于ptrace的很好的教程（<a href="http://www.kgdb.info/gdb/playing_with_ptrace_part_i/" target="_blank" rel="noopener">Playing with ptrace</a>）,但是时间有点久了，而且没有涉及64位操作系统。因此，我决定写这份教程，基于64位Linux，尽力介绍一些新加入的功能，同时兼顾一下32位系统。另外，由于一开始的目的是“对程序的行为进行<em>限制</em>”，所以不会涉及到诸如设置断点之类的内容，相反，可能会涉及到其他关于系统资源管理的内容。<br><code>ptrace()</code>是一个由Linux内核提供的系统调用。它允许一个用户态进程检查、修改另一个进程的内存和寄存器。这种技术被广泛用于<code>gdb</code>等调试器中。尽管这系列文章的标题叫做“Programming with PTRACE”，但在第一部分中，我将着重介绍Linux的进程和相关的几个重要函数。</p><h2 id="fork-vfork-与-clone"><a href="#fork-vfork-与-clone" class="headerlink" title="fork(), vfork() 与 clone()"></a>fork(), vfork() 与 clone()</h2><p>在Linux中，每一个进程都有一个唯一的编号，被称作<code>pid</code>(Process ID)。在Linux中，进程不能凭空产生（<code>init</code>进程是个例外），只能从一个已有进程衍生出来。原来的进程被称做父进程，衍生出来的进程叫子进程。一个系统中所有进程以父子关系相连接，形成一棵树，这棵“树”的树根就是<code>init</code>进程，它是在系统启动时被直接启动的，因此它没有父进程。并且系统中所有其他进程都直接或间接地是它的子进程。在Linux系统中，实现“把一个进程变成两个”这一功能的有三个系统调用，即<code>fork()</code>、<code>vfork()</code>和<code>clone()</code>。</p><p><code>fork()</code>的工作流程的确和叉子有几分相似之处，它将当前进程所有数据复制一份，产生一个和父进程一模一样的子进程。并在两个进程中返回不同的返回值。比如这段代码：</p><figure class="highlight c"><figcaption><span>demo1.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> return_val;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Program started."</span>);</span><br><span class="line">    return_val=fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork() returned %d\n"</span>,return_val);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将会输出</p><pre><code>Program started.fork() returned 5768fork() returned 0</code></pre><p>很明显地可以看到，<code>puts()</code>只被调用了一次而<code>printf()</code>被调用了两次，这说明在<code>fork()</code>前的一个进程变成了两个，而且<code>fork()</code>在两个进程中有不同的返回值（这就是“调用一次，返回两次”的来历）。<code>fork()</code>会返回0给子进程，返回子进程的pid给父进程，因此，我们很容易判断出<code>fork() returned 0</code>是由子进程打印的。在实际应用中，也通过<code>if</code>语句判断返回值的方法来决定执行不同的代码：</p><pre><code>int pid=fork();if (pid==0){  //子进程的工作}else{  //父进程的工作}</code></pre><p>一般来说，子进程的工作就是调用<code>exec</code>族函数，启动另一个程序(把自己替换掉)。如果子进程还在执行而父进程已结束，那么它就成为“孤儿”进程，成为<code>init</code>进程的子进程。另外，请不要纠结那个<code>if</code>判断带来的性能损失，Linux的内核开发者都不纠结，你纠结什么呢？</p><a id="more"></a><p><code>vfork()</code>的存在是一个历史遗留问题，在很久很久以前，<code>fork()</code>调用是没有<a href="http://en.wikipedia.org/wiki/Copy_on_write" target="_blank" rel="noopener">CoW</a>机制的，如果fork出的一个子进程又立即调用了<code>exec</code>族函数，那么辛辛苦苦拷贝出来的内存又立马被扔进了废纸篓里（这个比喻可能不太恰当，毕竟被从内存里抹去的数据是捡不回来的）。Linux的开发者当然不会允许效率如此低下的事情发生，于是他们创造出了<code>vfork()</code>。它和<code>fork()</code>最大的差别在于，vfork出的子进程，在执行<code>exec</code>族函数前和父进程<strong>共享同一块内存</strong>。也就是说，子进程对内存的修改也会体现在父进程上。只有当子进程执行了<code>exec</code>族函数，它才真正拥有一块属于自己的内存。这样就节省了<code>fork()</code>中那个无意义的内存拷贝。现在因为有了CoW，<code>fork()</code>和<code>vfork()</code>已经几乎没有性能差异了。</p><figure class="highlight c"><figcaption><span>demo2.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid,x=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"X=%d\n"</span>,x);</span><br><span class="line">    pid=vfork();</span><br><span class="line">    <span class="keyword">if</span> (pid==<span class="number">0</span>)&#123;</span><br><span class="line">        x+=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Child-X=%d\n"</span>,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        x+=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Parent-X=%d\n"</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码输出，而且一定输出</p><pre><code>X=1Child-X=2Parent-X=3</code></pre><p>很好地说明了内存的共享，如果换成<code>fork()</code>，那么父子进程就都输出X=2了。<br>也许有人会问，为什么不可能是父进程先输出呢？这涉及到<code>vfork()</code>的另一个特点。如果使用<code>vfork()</code>创建进程，那么在子进程使用<code>exec</code>族函数或是<code>_exit()</code>(这就是我为什么不用<code>return 0</code>的原因，但没有详细研究过原因，求大神指教)之前，父进程会始终等待vfork返回。比如以下代码：</p><figure class="highlight c"><figcaption><span>demo3.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    pid=vfork();</span><br><span class="line">    <span class="keyword">if</span> (pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Child Sleeping..."</span>);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Child Exit."</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Parent Exit."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><pre><code>Child Sleeping...//这里等了3秒Child Exit.Parent Exit.</code></pre><p>而改成<code>fork()</code>后输出</p><pre><code>Parent Exit.Child Sleeping...~$//这里等了3秒Child Exit.</code></pre><p>可以明显看出两者差别。(给Windows用户的Tip: 那个<code>~$</code>是Linux终端的提示符，类似cmd)</p><p><code>clone()</code>函数提供了更多的控制选项，可自由决定要执行哪个代码片段甚至是哪些内存共享，哪些内存要复制。但我没怎么用过，不敢乱说，有兴趣的读者可以自行实验。</p><h2 id="令人困惑的exec族函数"><a href="#令人困惑的exec族函数" class="headerlink" title="令人困惑的exec族函数"></a>令人困惑的exec族函数</h2><p>我在这篇文章之前的部分N次提到了一个叫<code>exec族函数</code>的东西，如果我们man手册里查找(<code>man 3 exec</code>)，我们会得到一大堆函数（是不是开始感到困惑了？）：</p><pre><code>int execl  (const char *path, const char *arg, ...);int execlp (const char *file, const char *arg, ...);int execle (const char *path, const char *arg, ..., char * const envp[]);int execv  (const char *path, char *const argv[]);int execve (const char *path, char *const argv[], char *const envp[]);int execvp (const char *file, char *const argv[]);int execvpe(const char *file, char *const argv[], char *const envp[]);</code></pre><p><code>exec族函数</code>就是这一“族”函数，全部以exec打头，他们都是对系统调用<code>execve()</code>的包装。他们的作用就是把某个进程（通常是fork出来的子进程）从里到外，完完整整，包括代码、堆栈，全部换成另一个程序，然后从头开始运行。它们的调用效果是一样的，区别在于调用方式。总的来说，大致的参数顺序是这样的：<code>exec*(可执行文件路径，程序参数表[,环境变量表])</code>，其中环境变量表是可选的。<br>去掉打头的exec，带<code>l</code>（代表list）的函数使用了一种比较接近人类方法来表示程序参数表，即以<code>NULL</code>作为结尾（man手册推荐使用<code>(char *)0</code>）的变参列表；而带<code>v</code>(代表vector)的则使用一个字符串数组来表示程序参数表，就像<code>int main(int argc,char *argv[])</code>里的<code>argv</code>一样。<br>如果结尾带<code>e</code>（environment），则该函数接受一个字符串数组表示的环境变量表；反之，则会默认传递所有当前环境变量。如果带有<code>p</code>，那么你就不必在第一个参数中列出完整路径，系统会自动检查当前目录和<code>PATH</code>环境变量（如果你非要手贱加个路径分割符进去，那么系统就会把它当成完整路径）。<br>值得一提的是，不管你使用那种方法表示程序参数表，第0个参数（C的数组下标从0开始，记得么？）都应当和可执行文件路径保持一致，虽然不一致依然可以正确运行，但有可能出现奇奇怪怪的问题。（博主继续偷懒，欢迎各位读者当小白鼠自行实验）。如果你已经混乱了，或是直接跳过了上面的一大堆说明直接到了这，那么我推荐你直接使用<code>execlp()</code>函数，比如说，你要运行一个叫<code>foo</code>的程序：</p><pre><code>execlp(&quot;foo&quot;,&quot;foo&quot;,NULL);</code></pre><p>或是列举出根目录下所有文件：</p><pre><code>execlp(&quot;ls&quot;,&quot;ls&quot;,&quot;/&quot;,NULL);</code></pre><h2 id="继续之前的其他一些准备"><a href="#继续之前的其他一些准备" class="headerlink" title="继续之前的其他一些准备"></a>继续之前的其他一些准备</h2><p>从本系列的下一篇开始，我将要开始讨论<code>ptraec()</code>这一强大的工具。但是，如果你有一下现象之一的，我建议你<em>不要</em>继续阅读并且从头学习有关<code>*nix</code>系列系统的知识：</p><ol><li>基本看不懂这篇文章的</li><li>不会C语言的</li><li>狂热的Windows爱好者</li><li>不会使用<a href="https://www.google.com" target="_blank" rel="noopener">Google</a>的</li><li>没有IDE就不会编译程序的</li><li>没有听说过<code>寄存器</code>，<code>堆栈</code>的</li></ol><p>另外，<code>ptrace()</code>相当接近系统底层，对内核版本，系统构架，指令长度，库头文件等有相当大的依赖性，如果你还在使用2.x系列的内核，你可能在之后遇到问题，因为一些功能在新版本内核才被加入。我在这里列出我的编程环境：</p><ul><li>系统: ArchLinux x86_64</li><li>内核: Linux 3.14.1</li><li>glibc 2.19</li><li>gcc 4.8.2</li></ul><p>另外，这里有更多关于进程的文章</p><ul><li><a href="http://www.cnblogs.com/vamei/archive/2012/09/20/2694466.html" target="_blank" rel="noopener">Linux进程基础</a> （我觉得其中关于食谱的那个比喻不太恰当，也许程序和进程的关系更像类和类的实例的关系？）</li><li><a href="http://www.ibm.com/developerworks/cn/linux/l-linux-process-management/" target="_blank" rel="noopener">Linux 进程管理剖析</a> (IBM developerWorks是我超喜欢的一个网站，有相当多高质量的文章)</li><li><a href="http://coolshell.cn/articles/656.html" target="_blank" rel="noopener">Linux 的僵尸(zombie)进程</a></li></ul>]]></content>
    
    <summary type="html">
    
      First part of serial of tutorial: Programming with PTRACE
    
    </summary>
    
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="Linux" scheme="http://recursiveg.me/tags/Linux/"/>
    
      <category term="PTRACE" scheme="http://recursiveg.me/tags/PTRACE/"/>
    
      <category term="教程" scheme="http://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>有屏幕的地方就有烂苹果</title>
    <link href="http://recursiveg.me/2014/03/bad-apple-character-player/"/>
    <id>http://recursiveg.me/2014/03/bad-apple-character-player/</id>
    <published>2014-03-19T11:55:49.000Z</published>
    <updated>2017-08-13T04:55:25.222Z</updated>
    
    <content type="html"><![CDATA[<p>如果你还不知道Bad Apple是什么东西，请移步<a href="http://zh.wikipedia.org/wiki/Bad_apple!!" target="_blank" rel="noopener">这里</a><br>播放的原理很简单，就是不停的打印清屏再打印清屏。任何一个略有编程基础的人都能做到。比较令人头大的是如何把原视频转化为一个易于解析而且又不占地方的文件。<br>其实，借助<code>FFmpeg</code>、<code>ImageMagick</code>和一点点的编程小技巧就可以轻松完成。</p><p>第一步当然是要去下一个视频文件，我已经下好了，叫做<code>BadApple.mkv</code>。</p><a id="more"></a><p>第二步要把视频变成一帧一帧的图片，请出FFmpeg来帮忙:</p><pre><code>ffmpeg -i BadApple.mkv -s 80x60 -r 15 Ba%d.png</code></pre><p>然后你就会得到<code>Ba1.png Ba2.png Ba3.png</code>等一大堆文件，这就是各帧了。注意我在这一步同时把大小缩小到了80*60和把帧速率调到了15帧每秒。</p><p>第三步用ImageMagick将图像转换成黑白图，然后再转换成<code>xpm</code>格式。XPM格式本质上是一个文本文档，可以直接被<code>#include</code>。我们这一步要用到一点点脚本技巧。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> *.png</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  convert <span class="variable">$x</span> -monochrome `basename -s .png <span class="variable">$x</span>`.xpm</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>最后写一段C语言小程序，利用游程编码进一步缩小文件体积。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;xpm.h&quot;</span><br><span class="line">void main()&#123;</span><br><span class="line">  FILE *f=fopen(&quot;BA.dat&quot;,&quot;a&quot;);</span><br><span class="line">  char count;</span><br><span class="line">  int t=ARR[0][6]==&apos;1&apos;?1:2;</span><br><span class="line">  for(int i=1+t;i&lt;61+t;i++)&#123;</span><br><span class="line">    count=1;</span><br><span class="line">    for(int j=1;j&lt;80;j++)&#123;</span><br><span class="line">      if(ARR[i][j]==ARR[i][j-1])&#123;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        if(ARR[i][j]==&apos;.&apos;)count=-count;</span><br><span class="line">        fprintf(f,&quot;%c&quot;,count);</span><br><span class="line">        count=1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ARR[i][79]==&apos; &apos;)count=-count;</span><br><span class="line">    fprintf(f,&quot;%c&quot;,count);</span><br><span class="line">    fprintf(f,&quot;%c&quot;,0);</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，离不了脚本和编译器的帮助，我这里使用了<code>tcc</code>进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (( i=1; i&lt;=3288; i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  cp Ba<span class="variable">$i</span>.xpm xpm.h</span><br><span class="line">  tcc -DARR=Ba<span class="variable">$i</span> bad_apple.c &amp;&amp; ./a.out</span><br><span class="line">  rm xpm.h</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>其中，那个3288就是总帧数。这样就得到了一个<code>BA.dat</code>文件。文件内容是一堆用二进制存储的数字，正数代表连续的白色，负数代表连续的黑色，零代表换行。一帧60行，总计3288帧。这样就把一个80多兆的视频压缩到了900多K。有了数据文件剩下的就好办了。</p><p><strong>未完待续。。。。。。</strong></p>]]></content>
    
    <summary type="html">
    
      A short tutorial on creating a character-base animation
    
    </summary>
    
    
      <category term="ACG" scheme="http://recursiveg.me/categories/ACG/"/>
    
    
      <category term="技术宅" scheme="http://recursiveg.me/tags/%E6%8A%80%E6%9C%AF%E5%AE%85/"/>
    
      <category term="东方Project" scheme="http://recursiveg.me/tags/%E4%B8%9C%E6%96%B9Project/"/>
    
  </entry>
  
  <entry>
    <title>在Linux下使用MinGW静态交叉编译带有zlib的libcurl</title>
    <link href="http://recursiveg.me/2014/02/how-to-cross-compile-libcurl-on-linux/"/>
    <id>http://recursiveg.me/2014/02/how-to-cross-compile-libcurl-on-linux/</id>
    <published>2014-02-28T13:17:41.000Z</published>
    <updated>2017-08-13T04:55:25.222Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://curl.haxx.se/" target="_blank" rel="noopener">libcurl</a>是一个跨平台的、易用的、强大的网络库。在大部分Linux发行版中都有编译好的二进制包可供使用，Mac系统更是将其作为了一个核心部件。但是在Windows平台上却需要手工编译，更不必说一些有特殊洁癖的人（比如说我）还特别讨厌多出来几个DLL,非要静态链接不可。本文作为我两个晚上折腾经历的一个小小总结，讲解如何在Linux下使用MinGW编译给Windows使用的libcurl静态库。</p><h3 id="STEP1-安装MinGW编译器"><a href="#STEP1-安装MinGW编译器" class="headerlink" title="STEP1 安装MinGW编译器"></a>STEP1 安装MinGW编译器</h3><p>这步我不打算多说，大部分Linux发行版的仓库应该都有，以我的ArchLinux为例，执行：</p><pre><code>~# pacman -S mingw-w64</code></pre><p>即可。如果你不需要交叉编译，要在Windows上直接编译，请自行去SourceForge上下载Windows版本。不要担心那个<code>w64</code>是不是64位版本，它既可以编译32位又可以编译64位程序。还是以我的版本为例:</p><pre><code>~# pacman -Ql mingw-w64-gcc| grep &apos;/usr/bin/.*gcc$&apos;mingw-w64-gcc /usr/bin/i686-w64-mingw32-gccmingw-w64-gcc /usr/bin/x86_64-w64-mingw32-gcc</code></pre><p>可以看到有两个gcc,用<code>i686-w64-mingw32-gcc</code>编译出来的程序就是32位的，而<code>x86_64-w64-mingw32-gcc</code>编译出来的就是64位的。现在，随便写个Hello World（你可以用我的<a href="http://www.devinprogress.org/2012/12/helloworld/" target="_blank" rel="noopener">Hello World代码</a> ^_^），然后编译试试：</p><pre><code>i686-w64-mingw32-gcc hello_world.c -o hello_world.exe</code></pre><p>把它拿到虚拟机或扔进Wine里，如果能正常运行，那么恭喜你，第一步完成了。</p><a id="more"></a><h3 id="STEP2-下载源码"><a href="#STEP2-下载源码" class="headerlink" title="STEP2 下载源码"></a>STEP2 下载源码</h3><p>很简单的步骤，如果自己搞不定的建议直接右上角。</p><ul><li><a href="http://curl.haxx.se/download.html" target="_blank" rel="noopener">LibCurl</a>:最上面的Source Archives</li><li><a href="http://www.zlib.net/" target="_blank" rel="noopener">zLib</a>:请下Source Code</li><li><a href="https://www.openssl.org/source/" target="_blank" rel="noopener">OpenSSL</a>:可选，如果没有必要就不要编译，会极大地增加文件体积</li></ul><p>把<code>curl-7.35.0</code>和<code>zlib-1.2.8</code>(可能还有<code>openssl-1.0.1f</code>)这几个文件夹放在同一个目录下，然后进行下一步。</p><h3 id="STEP3-编译源码"><a href="#STEP3-编译源码" class="headerlink" title="STEP3 编译源码"></a>STEP3 编译源码</h3><p>先打开<code>zlib/win32</code>文件夹下的<code>Makefile.gcc</code>文件,把<code>PREFIX =</code>这行改成STEP1里的gcc前缀，对于我来说就是<code>PREFIX = i686-w64-mingw32-</code>。把这个文件拷贝到<code>zlib</code>文件夹下，然后在<code>zlib</code>文件夹下<code>make -f Makefile.gcc</code>，你就应该能看到<code>libz.a</code>这个文件了。</p><p>如果你要编译OpenSSL,那么就去openssl文件夹下</p><pre><code>$ ./Configure no-shared --cross-compile-prefix=i686-w64-mingw32- mingw$ make</code></pre><p>即可，记得改prefix。生成<code>libssl.a</code>和<code>libcrypto.a</code></p><p>最后去libcurl里的lib文件夹里修改<code>Makefile.m32</code>文件，在<code>CC    = $(CROSSPREFIX)gcc</code>上加一行<code>CROSSPREFIX=i686-w64-mingw32-</code>（请按需修改），然后把下面<code>CFLAGS</code>那行改成这样<code>CFLAGS    = -g -O2 -Wall -DCURL_DISABLE_LDAP</code>，最后</p><pre><code>make -f Makefile.m32 CFG=-zlib</code></pre><p>或是</p><pre><code>make -f Makefile.m32 CFG=-zlib-ssl</code></pre><p>make到最后时会报个错，是因为文件没放对地方，手动挪一下即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> vtls/openssl.o vtls/gtls.o vtls/vtls.o vtls/nss.o vtls/qssl.o vtls/polarssl.o vtls/polarssl_threadlock.o vtls/axtls.o vtls/cyassl.o vtls/curl_schannel.o vtls/curl_darwinssl.o vtls/gskit.o</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    mv `basename <span class="variable">$x</span>` vtls</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>然后再make一下，<code>libcurl.a</code>文件应该就出现了。<br>如果生成dll出错也不要紧，我们要的是<code>.a</code>文件</p><h3 id="STEP4-测试"><a href="#STEP4-测试" class="headerlink" title="STEP4 测试"></a>STEP4 测试</h3><p>现在，你可以找一段libcurl的demo来测试了。注意要加上宏定义<code>CURL_STATICLIB</code></p><pre><code>i686-w64-mingw32-gcc -I. -L. -DCURL_STATICLIB curl_demo.c -lcurl -lz -lws2_32 -o curl_demo.exe</code></pre><p>如果你因为不知道gcc<code>-I</code>和<code>-L</code>选项的用法而编译不过，请自行Google。如果你加了ssl支持，你需要链接更多的库，具体请根据错误信息自行Google。最后提醒一点:<strong>请把<code>-lcurl</code>选项放在源文件后面</strong>，我当初就是因为这个死活链接不过。最后把<code>curl_demo.exe</code>拖进虚拟机里，如果一切正常，那么恭喜你，你成功了。</p>]]></content>
    
    <summary type="html">
    
      A short memo on how to cross-compile libcurl statically on linux.
    
    </summary>
    
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="Linux" scheme="http://recursiveg.me/tags/Linux/"/>
    
      <category term="MinGW" scheme="http://recursiveg.me/tags/MinGW/"/>
    
      <category term="交叉编译" scheme="http://recursiveg.me/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>记一次坑爹的乱码解决过程</title>
    <link href="http://recursiveg.me/2014/02/clear-a-special-kind-of-messy-code/"/>
    <id>http://recursiveg.me/2014/02/clear-a-special-kind-of-messy-code/</id>
    <published>2014-02-08T06:12:59.000Z</published>
    <updated>2017-08-13T04:55:25.222Z</updated>
    
    <content type="html"><![CDATA[<p>某日，我在网上下载了一些音乐，然后打开，发现了乱码。Linux系统上出现乱码本不是什么好大惊小怪的事，但是，在经过N种方法来回折腾依然无法解决的情况下，我意识到，这大约是我见过的最奇葩的一种乱码了。先上图：<br><img src="http://0f4529-files.oss-cn-hangzhou.aliyuncs.com/messy-code.png" alt="An Example of the Messy Code"></p><a id="more"></a><p>为了解释这个问题，我要先引入Python3中的字符串与字节序列的概念。在Python3中，一个字符串不存在‘编码类型’这种概念，每一个包含相同文字的字符串都是完全一样的(确切的讲,Python3中的字符串是以<a href="https://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">Unicode</a>编码的字节序列)。而字节序列和C中的char数组很像，它是字符串保存在文件系统上的真正形态。一个固定的字符串(即包含相同的文字)可以被编码(即Python中的<code>encode()</code>)成字节序列。如果对其使用不同的编码方式，生成的字节序列也不同。举个例子，一栋房子地面上的第一层，英国人叫它’ground floor’，而美国人叫它‘first floor’。这就是不同的编码方式。相反，解码(Python中的<code>decode()</code>)就是把一个字节序列变回字符串。在普通情况下，乱码是由于对一个字节序列使用了错误的编码方式进行解码，解码之后的内容自然无法阅读。就像一个英国人给一个美国人留了张便条，写着‘Meet me at first floor.’(二楼)，然后美国人去一楼转了半天都没找到。这种使用了错误的解码方式的问题一般是由于操作系统的默认设定造成的，比如Windows系统使用当地语言的编码(大陆GBK,台湾BIG5,日本SHIFT-JIS之类的)，而Linux普遍使用UTF-8编码。解决这种乱码的方法也很简单，你不是默认以UTF8方式解读么？而现在的字节序列又需要以GBK方式解读才能获得正确的内容，那么我们只要找到一个字节序列，让它被以UTF8解码时得到的内容和现在的字节序列被以GBK解码时得到的内容一样就行了。具体方法就是把当前的字节序列先以GBK解码，再以UTF-8编码，然后写回文件系统里，就搞定了。这个命令在Linux上就是<code>iconv -f GBK -t UTF-8</code>(记得加管道)。</p><p>但是，这次的乱码坑爹就坑爹在: 它的字节序列(字符串是以字节序列的形式保存在磁盘上的，还记得么？)无法以GBK方式解码，相反，它更像是一个根正苗红的UTF-8编码的字节序列。在多次尝试失败后，我开始无聊地“欣赏”乱码字符。注意到那些字符上的装饰了么？就是那些小点波浪尖角什么的？我也注意到了。然后我意识到，这是显著的西欧字符集的特征。也就是说，曾经有某个字节序列被以ISO-8859-1(一种西欧字符集)解码过一次，然后才表现出了现在的样子。那么，我们把现在的<strong>字符串</strong>用ISO-8859-1编码一次看看：<code>iconv -f UTF-8 -t ISO-8859-1</code>(因为我的系统的默认编码是UTF-8，所以需要‘-f UTF-8’)。然后得到了一坨问号，这正是GBK编码以UTF-8方式解码的结果，于是再接再厉：<code>iconv -f GBK -t UTF-8</code>。终于看到了熟悉的文字。最终，这个问题以两行命令被解决(因为是文件名乱码，所以用<code>convmv</code>命令)：</p><pre><code>convmv -f UTF-8 -t ISO-8859-1 --notest *convmv -f GBK -t UTF-8 --notest *</code></pre><p><strong>总结：</strong>这个乱码的产生原因也是对字节序列使用了错误的解码方式（对GBK字节序列使用ISO-8859-1解码），但是因为最终的字节序列是一个根正苗红的UTF-8编码，所以特别难以解决。这种问题特别容易发生在网络当中，比如，一个网站允许用户上传文件，因为一些原因，这个网站把所有的文件名都转成UTF-8存储，如果用户用西欧语言，那么这样就完全没关系，但如果一个中国用户上传了一个GBK文件名编码的文件，那么这种问题就发生了。</p><p>如果大家对排版或是图片之类的有什么意见建议请务必留言。<br><strong>做人要厚道，转载请注明出处</strong></p>]]></content>
    
    <summary type="html">
    
      Linux系统下一种特殊乱码的形成原因以及解决方案
    
    </summary>
    
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="Linux" scheme="http://recursiveg.me/tags/Linux/"/>
    
      <category term="乱码" scheme="http://recursiveg.me/tags/%E4%B9%B1%E7%A0%81/"/>
    
      <category term="Python" scheme="http://recursiveg.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>网站从Octopress迁移至Hexo</title>
    <link href="http://recursiveg.me/2013/12/site-migration-complete/"/>
    <id>http://recursiveg.me/2013/12/site-migration-complete/</id>
    <published>2013-12-24T13:26:08.000Z</published>
    <updated>2017-08-13T04:55:25.222Z</updated>
    
    <content type="html"><![CDATA[<p>经过我两个小时的折腾，总算是重新把网站弄起来了。Ruby实在是坑爹，各种gem装得目录结构乱七八糟的……（强迫性人格障碍的典型表现）而且速度还慢……<br>曾尝试用Python和Tornado模板自己写一个静态页面生成器，然后发现我想多了。我果然还是不适合写UI……<br>一通Google之后，最终决定使用Hexo。它使用node.js(也就是javascript)作为编程语言(这样说恰当么？反正就是这个意思啦),据说速度极快。最重要的是，AUR源里有Hexo打好的包，能用pacman管理就是好。<br>主题试了一圈下来还是默认的Light看着最舒心。<strong>以后千万不能再手贱自己写主题了！！</strong><br>膜拜一下Hexo的作者tommy351。自己改了一下高亮配色和Widgets，把以前Octopress的Markdown文档做了一点点修改，这样就算上线了吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经过我两个小时的折腾，总算是重新把网站弄起来了。Ruby实在是坑爹，各种gem装得目录结构乱七八糟的……（强迫性人格障碍的典型表现）而且速度还慢……&lt;br&gt;曾尝试用Python和Tornado模板自己写一个静态页面生成器，然后发现我想多了。我果然还是不适合写UI……&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Site Management" scheme="http://recursiveg.me/categories/Site-Management/"/>
    
    
      <category term="Hexo" scheme="http://recursiveg.me/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>通用存储及分布式文件共享系统的设想</title>
    <link href="http://recursiveg.me/2013/03/universal-storge/"/>
    <id>http://recursiveg.me/2013/03/universal-storge/</id>
    <published>2013-03-30T12:02:00.000Z</published>
    <updated>2017-08-13T04:55:25.222Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Update: 本计划已无限期暂停，在可预见的未来没有重启计划，如有需要资料的欢迎发邮件索取</strong></p><p>众所周知，网盘这东西对大众来说不可或缺，国内的在线存储服务也欣欣向荣。但是，由于各种原因，我们仍感到这些不能完全满足我们的要求。<br>比如各种限制、各种暂停分享、还有各种必须付钱才能用的VIP服务等。各大公司想挣钱无可非议，毕竟网络存储绝对是烧钱的主，但作为一个搞技术的人，决不能整天写登陆界面，对吧？<br>动机在<a href="/2013/01/data-structure-of-vdisk/">新浪微盘数据结构解析</a>中说了，在那之后我又研究了其他的网盘，萌生了这么一个设想。<br>简要的说，这个系统可以大大方便文件的传播与获取，延长资源的存活时间。</p><a id="more"></a><p>废话不多说，以下是我的构想：</p><ol><li>人肉解析各资源站链接协议，比如下载上传链接解析什么的。</li><li>写成模块，类库什么的，方便调用。</li><li>以统一的界面管理多处资源，进行下载、上传等。</li><li>以写成的库为基础，对资源进行自动管理，比如可以分块存储于不同的位置，或是创建多个备份等。</li><li>维护一个数据库，存储用户共享信息，实现全网资源搜索。其实，不仅文件可以是分布式的，数据库也可以是分布式的，技术细节正在努力构思中。</li><li>有条件的同学可以在自己的服务器上运行一个特殊的服务端，接受来自其他用户的请求，比如一些已被停止共享的文件的下载(比如115的VIP的离线下载功能)。</li></ol><p><strong>更多可能，任君想象</strong></p><p>可能你们已经注意到了，我尽可能的避免使用<code>网盘</code>这个字眼。没错，我的目标不仅是网盘，我还希望加入一些“只读”的资源，比如通过解析视频网站的地址来下载视频文件等。正如Bilibili所做的那样(不过也许他们有合作关系？)。<br>目前，统一管理界面正在书写中，使用Python3, 应该不久可以放出Alpha版和API。不过，最后，我要给大家浇盆冷水，<em>本计划仍处于设想阶段</em>，不要期望能瞬间完成。而且，我们需要考虑遭到封杀后的应对措施，以及如何保持协议更新后库的快速升级等问题。</p><p>PS：欢迎有兴趣和有能力的同学来信交流：<code>gzh.shadow@gmail.com</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Update: 本计划已无限期暂停，在可预见的未来没有重启计划，如有需要资料的欢迎发邮件索取&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;众所周知，网盘这东西对大众来说不可或缺，国内的在线存储服务也欣欣向荣。但是，由于各种原因，我们仍感到这些不能完全满足我们的要求。&lt;br&gt;比如各种限制、各种暂停分享、还有各种必须付钱才能用的VIP服务等。各大公司想挣钱无可非议，毕竟网络存储绝对是烧钱的主，但作为一个搞技术的人，决不能整天写登陆界面，对吧？&lt;br&gt;动机在&lt;a href=&quot;/2013/01/data-structure-of-vdisk/&quot;&gt;新浪微盘数据结构解析&lt;/a&gt;中说了，在那之后我又研究了其他的网盘，萌生了这么一个设想。&lt;br&gt;简要的说，这个系统可以大大方便文件的传播与获取，延长资源的存活时间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="Black Technology" scheme="http://recursiveg.me/tags/Black-Technology/"/>
    
      <category term="网盘" scheme="http://recursiveg.me/tags/%E7%BD%91%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>Pascal中鲜为人知的那些技巧</title>
    <link href="http://recursiveg.me/2013/01/cheat-with-pascal/"/>
    <id>http://recursiveg.me/2013/01/cheat-with-pascal/</id>
    <published>2013-01-31T13:46:00.000Z</published>
    <updated>2017-08-13T04:55:25.222Z</updated>
    
    <content type="html"><![CDATA[<p>做为一个搞信息学竞赛这么长时间的人，再加上估计很快就要转C++了，我觉得我有必要留下一些关于Pascal语言的资料，于是就有了这篇文章。我只负责解释用法，对基础概念不了解的请自行Google。所有这篇文章里的东西应该都能在Free Pascal自带的文档里找到，我写出来是为了众多不喜欢看英文的同学们，如果你愿意自己去看一下，一定会收益匪浅。</p><h3 id="不同进制的表示"><a href="#不同进制的表示" class="headerlink" title="不同进制的表示"></a>不同进制的表示</h3><p>平时我们写的常量都是十进制数，但我们有时需要写一个比如十六进制数怎么办呢？我们当然可以手动计算一下，但还有更优雅的方法。</p><pre><code>writeln($Ff,#32,&amp;10,#32,%100);</code></pre><p>你觉得它会输出什么呢？它输出<code>255 8 4</code>!所以以<code>$</code>开头的是16进制数，<code>&amp;</code>开头的是8进制数，<code>%</code>开头的是二进制数。顺带一提的是，以<code>#</code>开头的数会转变成对应ASCII码的字符，其实它可以和前面的三个符号共同使用，即<code>#$20</code>和<code>#%100000</code>都代表了空格。</p><a id="more"></a><h3 id="函数内联"><a href="#函数内联" class="headerlink" title="函数内联"></a>函数内联</h3><p>关于内联的解释请自己找资料，写法如下：</p><pre><code>function foo(bar:Type):ReturnType;inline;</code></pre><p>即在函数头后加<code>inline;</code>即可。测试证明确实有效，不过建议只用于诸如<code>min</code>或<code>max</code>这种函数。</p><h3 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h3><p>Pascal也是支持重载的，甚至可以重载系统函数！演示如下：</p><pre><code>procedure sort(var a:TArray;l,r:longint);begin  ...end;procedure sort(var a:TArray;r:longint);begin  sort(a,1,r)end;</code></pre><p>这样，调用<code>sort(arr,top)</code>就相当于调用<code>sort(arr,1,top)</code>.</p><h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><p>是不是对写高精度时的<code>plus(a,b)</code>感到厌倦？是不是想换一种更帅的书写方式？没问题，操作符重载能满足你的愿望！它可以让你用<code>a+b</code>的形式对高精度进行计算！</p><pre><code>operator + (a,b:Type) c:Type;operator := (a:Type1) b:Type2;operator &gt; (a,b:Type) c:boolean;</code></pre><p>需要注意的是</p><ul><li>比较操作符的返回值只能是<code>Boolean</code></li><li>二元操作符和赋值操作符如果两端类型不同不能随意交换位置</li><li>重载后优先级不变</li></ul><p>为了解决不能随意交换位置的问题，你可以这样写：</p><pre><code>operator + (a:Type1;b:Type2)c:ReturnType;begin  ...end;operator + (a:Type2;b:Type1)c:ReturnType;begin  c:=b+aend;</code></pre><h3 id="想重载str-和val-？"><a href="#想重载str-和val-？" class="headerlink" title="想重载str()和val()？"></a>想重载str()和val()？</h3><p>看完前面的函数重载，你是不是迫不及待地想要重载<code>val()</code>和<code>str()</code>这两个你看着不爽很久的函数了？但是却发现不能调用系统原来的函数了，Pascal把它当成了递归！解决方法很简单，在要用原始系统函数的地方加上<code>system.</code>即可。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">str</span><span class="params">(x:longint)</span>:</span><span class="keyword">string</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="comment">//str(x,str)&lt;--This is completely wrong!</span></span><br><span class="line">  system.str(x,str);<span class="comment">//&lt;--This is the right form</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>担心数组太大爆内存？但心数组太小存不下？动态数组解除你的忧虑！主要操作如下：</p><ol><li><code>a:array of Type;</code>：变量声明。</li><li><code>setlength(a,length)</code>：设定数组下标，范围为<code>[0..length-1]</code>，会自动清零。</li><li><code>b:=a</code>:看上去像是赋值，但其实不是赋值，只是复制地址而已，因此对<code>b</code>的修改就是对<code>a</code>的修改。</li><li><code>c:=copy(a,0,length(a))</code>：这就是真正的赋值了！还记得<code>copy()</code>和<code>length()</code>函数么？现在它们可以用于动态数组了！</li><li><code>d:array of array of Type</code>:二维动态数组声明。</li><li><code>setlength(d,length1,length2)</code>:不解释。</li><li><code>a:=d[1]</code>:<code>a</code>是一维动态数组，对<code>a[x]</code>的修改就是对<code>d[1][x]</code>的修改。</li><li><code>copy(d[x],0,length(d[x]))</code>:取出第<code>x</code>个一维动态数组。</li><li>二维动态数组可以用<code>d[x,y]</code>的方式访问，也可以用<code>d[x][y]</code>的方式访问。</li></ol><h3 id="取地址操作符"><a href="#取地址操作符" class="headerlink" title="取地址操作符"></a>取地址操作符</h3><p>想用C语言中的<code>&amp;</code>操作符？在Pascal中它是<code>@</code>!估计某年的NOIP坑了不少人。</p><h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>你还在定义<code>text</code>类型么？你还在用查找替换功能批量替换你的<code>readln()</code>么？赶快试试这个！</p><pre><code>assign(input,&apos;foo.in&apos;);reset(input);assign(output,&apos;foo.out&apos;);rewrite(output);...close(input);close(output);</code></pre><p>再也不用担心输入输出了！</p><h3 id="用动态数组实现伪变参"><a href="#用动态数组实现伪变参" class="headerlink" title="用动态数组实现伪变参"></a>用动态数组实现伪变参</h3><p>是不是很羡慕C中<code>printf</code>的变参？是不是很羡慕<code>writeln</code>可以有好多好多参数？利用动态数组可以实现类似的功能！</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">average</span><span class="params">(arr:<span class="keyword">array</span> <span class="keyword">of</span> longint)</span>:</span>real;</span><br><span class="line"><span class="keyword">var</span> i:longint;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  average:=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> high(arr) <span class="keyword">do</span></span><br><span class="line">    average:=average+arr[i];</span><br><span class="line">  average:=average/length(arr)</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>请注意其中<code>high()</code>和<code>length()</code>的区别。合法调用如下：</p><pre><code>var A:array[1..MAX]of longint;average([3]);average([1,2,3,4]);average(A);average(A[1..5]);</code></pre><h3 id="函数也是变量？！"><a href="#函数也是变量？！" class="headerlink" title="函数也是变量？！"></a>函数也是变量？！</h3><p>或许你对C++中的<code>sort()</code>已有所耳闻，或许你已经知道，它的比较函数是做为参数传进去的。配合<code>@</code>操作符，Pascal可以做到相同的效果。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TMyCompareFunc=<span class="function"><span class="keyword">Function</span><span class="params">(a,b:MyType)</span>:</span>boolean;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">largerthan</span><span class="params">(a,b:MyType)</span>:</span>boolean;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">sort</span><span class="params">(<span class="keyword">var</span> a:<span class="keyword">array</span> <span class="keyword">of</span> MyType;l,r:longint;f:TMyCompareFunc)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//Use `f(a[x],a[y])` to compare</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">compare(arr,<span class="number">1</span>,max,@largerthan);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><p>既然是变量，就能互相赋值，但是请注意：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TNoArgFunc=<span class="function"><span class="keyword">Function</span><span class="params">()</span>:</span>integer;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">  F:TNoArgFunc;</span><br><span class="line">  N:integer;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyFunc</span><span class="params">()</span>:</span>integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  MyFunc:=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">F:=MyFunc; <span class="comment">//F()成为MyFunc()的别名</span></span><br><span class="line">N:=MyFunc; <span class="comment">//N被赋值为3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//if F=MyFunc then</span></span><br><span class="line"><span class="comment">//  writeln('You will never see this');</span></span><br><span class="line"><span class="comment">//这个判断将导致`类型不匹配`编译错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> F=@MyFunc <span class="keyword">then</span></span><br><span class="line">  writeln(<span class="string">'这是同一个函数'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> F()=MyFunc <span class="keyword">then</span></span><br><span class="line">  writeln(<span class="string">'这两个函数的返回值相同'</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h3 id="C风格的操作符"><a href="#C风格的操作符" class="headerlink" title="C风格的操作符"></a>C风格的操作符</h3><p>我就不多介绍了<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>…考试时先试试能不能用。使用有风险，偷懒须谨慎。</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>知道C中的<code>(int)a</code>或是<code>int(a)</code>么？不知道没关系，Pascal中的强制类型转换是这样写的<code>TypeIdentifier(Variable)</code>。下面给几个例子：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntPtr=^integer;</span><br><span class="line">IntVal:=<span class="number">97</span>;</span><br><span class="line">RealVal:=<span class="number">3.7</span>;</span><br><span class="line">longint(IntVal);<span class="comment">//长版的IntVal</span></span><br><span class="line">real(IntVal);<span class="comment">//实数版IntVal，效果和赋值一样</span></span><br><span class="line">pointer(IntVal);<span class="comment">//一个指向内存地址97的无类型指针</span></span><br><span class="line">IntPtr(IntVal);<span class="comment">//一个指向内存地址97的Integer指针</span></span><br><span class="line">longint(@IntVal);<span class="comment">//IntVal地址的Longint版。注意，它是一个数，所以可以用writeln()输出</span></span><br><span class="line">writeln(IntPtr(@RealVal)^);<span class="comment">//你可以猜猜这句话输出什么（写程序时请绝对不要这么做）</span></span><br></pre></td></tr></table></figure><h3 id="无类型变量与无类型指针"><a href="#无类型变量与无类型指针" class="headerlink" title="无类型变量与无类型指针"></a>无类型变量与无类型指针</h3><p>标题写着<code>无类型变量</code>，其实应该叫做<code>多类型变量</code>更准确。他的主要工作原理就是在内部进行类型转换，因此效率极其低下，占用空间还特别大，连官方手册都不建议用。类型名为<code>Variant</code>。<br>无类型指针就是上一节提到的<code>Pointer</code>了。任何指针都可以赋值给它，它也可以赋值给任何指针，例子如下：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">  p:pointer;</span><br><span class="line">  r:real;</span><br><span class="line">  i:^integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  r:=<span class="number">3.7</span>;</span><br><span class="line">  p:=@r;</span><br><span class="line">  i:=p;</span><br><span class="line">  writeln(i^);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><p>看出来了么？这段文字和上一段的最后一句话等效。</p><h3 id="这玩意儿是类？！"><a href="#这玩意儿是类？！" class="headerlink" title="这玩意儿是类？！"></a>这玩意儿是类？！</h3><p>这是我最近才看到的一种写法，从来没用过。有愿意尝试的请自行研究。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span></span><br><span class="line">  TGetSum=<span class="keyword">object</span></span><br><span class="line">  a,b:longint;</span><br><span class="line">  <span class="function"><span class="keyword">procedure</span> <span class="title">Init</span><span class="params">(x,y:longint)</span>;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">GetSum</span><span class="params">()</span>:</span>longint;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">TGetSum</span>.<span class="title">Init</span><span class="params">(x,y:longint)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  a:=x;b:=y;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TGetSum</span>.<span class="title">GetSum</span><span class="params">()</span>:</span>longint;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  GetSum:=a+b;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">  sum:TGetSum;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  sum.Init(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">  writeln(sum.GetSum())</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><p>关于Object Pascal,推荐一本书:<a href="http://code-sd.com/books/startprog/" target="_blank" rel="noopener">Start Programming Using Object Pascal</a></p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>Pascal是不少OIer最开始使用的一种语言，仅以此文献给众多正在使用和曾经使用过Pascal的OIer。<br><strong>做人要厚道，转载请注明出处！</strong></p>]]></content>
    
    <summary type="html">
    
      Some special skills programming with pascal. Useful in ACM.
    
    </summary>
    
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="Pascal" scheme="http://recursiveg.me/tags/Pascal/"/>
    
      <category term="ACM" scheme="http://recursiveg.me/tags/ACM/"/>
    
      <category term="编程" scheme="http://recursiveg.me/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
