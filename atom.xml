<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RECURSIVE LAND</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://recursiveg.me/"/>
  <updated>2025-10-15T05:14:37.870Z</updated>
  <id>https://recursiveg.me/</id>
  
  <author>
    <name>RecursiveG</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在 MSI TRX40 主板上启用 SR-IOV</title>
    <link href="https://recursiveg.me/2025/10/msi-trx40-sriov-ari/"/>
    <id>https://recursiveg.me/2025/10/msi-trx40-sriov-ari/</id>
    <published>2025-10-14T15:30:00.000Z</published>
    <updated>2025-10-15T05:14:37.870Z</updated>
    
    <content type="html"><![CDATA[<p>最近继续折腾很早之前买的线程撕裂者（<a href="/2019/12/build-amd-3960x-pc/">装机回顾</a>）。主板用的是MSI TRX40 PRO 10G，BIOS里有IOMMU选项，显卡直通也一直正常所以没多想。直到最近想折腾一下网卡SR-IOV，然后GG：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root# echo 1 &gt; &#x2F;sys&#x2F;bus&#x2F;pci&#x2F;devices&#x2F;0000:21:00.0&#x2F;sriov_numvfs</span><br><span class="line">kernel: cxgb4 0000:21:00.0: Parent bridge 20:03.1 doesn&#39;t support ARI; can&#39;t instantiate Virtual Functions</span><br></pre></td></tr></table></figure><p>提示系统不支持 ARI (Alternative Routing-ID Interpretation)。看下PCIE根端口的状态，确实没开：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root# lspci -vv -s 20:03.1</span><br><span class="line">20:03.1 PCI bridge: Advanced Micro Devices, Inc. [AMD] Starship&#x2F;Matisse GPP Bridge (prog-if 00 [Normal decode])</span><br><span class="line">        Capabilities: [58] Express (v2) Root Port (Slot+), IntMsgNum 0</span><br><span class="line">                DevCap2: FRS- LN System CLS Not Supported, TPHComp+ ExtTPHComp- ARIFwd-</span><br><span class="line">                DevCtl2: Completion Timeout: 65ms to 210ms, TimeoutDis- ARIFwd-</span><br></pre></td></tr></table></figure><p>在网上搜了一圈以后发现这个设置应该在一个叫<code>AMD CBS</code>的菜单里，然而这块主板并没有……</p><p>于是开始折腾“破解”BIOS设置，终于在浪费N个小时后发现一个叫 <a href="https://winraid.level1techs.com/t/tool-universalamdformbrowser/40353" target="_blank" rel="noopener">Universal AMD Form Browser</a> (<a href="https://github.com/DavidS95/Smokeless_UMAF" target="_blank" rel="noopener">github</a>) 的工具。尝试了一下确实可用。在CBS的NBIO菜单里把&quot;ARI Support&quot;和&quot;ARI Enumeration&quot;都Enable后就可以看到 <code>ARIFwd</code> 的减号变加号了。于是重新尝试，然而再次失败：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel: cxgb4 0000:21:00.0: not enough MMIO resources for SR-IOV</span><br></pre></td></tr></table></figure><p>因为这个ARI功能是我们hack出来的，所以目测BIOS没有正确给VF预留足够的地址空间。只需要在内核参数加上<code>pci=realloc</code>，让Linux重新分配地址空间即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近继续折腾很早之前买的线程撕裂者（&lt;a href=&quot;/2019/12/build-amd-3960x-pc/&quot;&gt;装机回顾&lt;/a&gt;）。主板用的是MSI TRX40 PRO 10G，BIOS里有IOMMU选项，显卡直通也一直正常所以没多想。直到最近想折腾一下网卡SR-IOV，
      
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="HomeLab" scheme="https://recursiveg.me/tags/HomeLab/"/>
    
  </entry>
  
  <entry>
    <title>Server connector gallery</title>
    <link href="https://recursiveg.me/2024/12/server-connector-gallery/"/>
    <id>https://recursiveg.me/2024/12/server-connector-gallery/</id>
    <published>2024-12-20T11:00:00.000Z</published>
    <updated>2024-12-21T20:25:10.712Z</updated>
    
    <content type="html"><![CDATA[<p>Here&#39;s a list of some common connectors for PCs and servers. Many are named like <code>SFF-1234</code>. The corresponding standard doc may be found in the <a href="https://www.snia.org/technology-communities/sff/specifications" target="_blank" rel="noopener">SNIA website</a>.</p><h2 id="SAS-U-2-U-3"><a href="#SAS-U-2-U-3" class="headerlink" title="SAS / U.2 / U.3"></a>SAS / U.2 / U.3</h2><p><a href="https://members.snia.org/document/dl/25920" target="_blank" rel="noopener"><strong>SFF-8482</strong> <em>Serial Attachment 2X Unshielded Connector</em></a><br>Our good old SAS connector. Supports two links, though in most cases only 1 link is used.</p><p><img src="/images/server-connector-gallery/sas.avif" alt="SAS connector, image from SAS-4 INCITS 534"></p><a id="more"></a><p><a href="https://members.snia.org/document/dl/26489" target="_blank" rel="noopener"><strong>SFF-8639</strong> <em>Multifunction 6X Unshielded Connector</em></a><br>Commonly known as &quot;U.2&quot;. It has 6 lanes and can carry SAS or PCIe x4 signals, as long as the controller supports it. Note the first two SAS lanes are not shared with the 4 PCIe lanes. Ignoring MultiLink SAS (SAS2 &amp; SAS3) for now, and again commonly only one SAS lane (SAS0) is used.<br><img src="/images/server-connector-gallery/sas-u2.avif" alt="U.2 connector and drive, images from the Internet"></p><p><a href="https://members.snia.org/document/dl/26900" target="_blank" rel="noopener"><strong>SFF-TA-1001</strong> <em>Universal x4 Link Definition for SFF-8639</em></a><br>Commonly known as &quot;U.3&quot;, SFF-TA-1001 redefines the signal in the SFF-8639 connector and make SAS and PCIe share the same lanes. So only 4 lanes are needed. U.3 drives are required to support U.2 hosts, but U.2 drives won&#39;t work in U.3 hosts.</p><p><img src="/images/server-connector-gallery/sas-u3.avif" alt="U.2 and U.3 pinout"></p><h2 id="MiniSAS"><a href="#MiniSAS" class="headerlink" title="MiniSAS"></a>MiniSAS</h2><p><a href="https://members.snia.org/document/dl/25823" target="_blank" rel="noopener"><strong>SFF-8087</strong> <em>Mini Multilane 4X Unshielded Connector Shell and Plug</em></a><br>Internal MiniSAS, typically can be broken out into 4 SAS connectors.<br><img src="/images/server-connector-gallery/minisas-internal.avif" alt="Internal MiniSAS connector, image from 10Gtek"></p><p><a href="https://members.snia.org/document/dl/25824" target="_blank" rel="noopener"><strong>SFF-8088</strong> <em>Mini Multilane 4X Shielded Connector Shell and Plug</em></a><br>External MiniSAS, suitable for usage outside a case.<br><img src="/images/server-connector-gallery/minisas-external.avif" alt="External MiniSAS connector, image from AliExpress"></p><h2 id="MiniSAS-HD"><a href="#MiniSAS-HD" class="headerlink" title="MiniSAS HD"></a>MiniSAS HD</h2><p><a href="https://members.snia.org/document/dl/25951" target="_blank" rel="noopener"><strong>SFF-8643</strong> <em>Mini Multilane 4/8X 12 Gb/s Unshielded Connector (HD12un)</em></a><br>Internal MiniSAS HD is the successor to the MiniSAS connector. It also has 4 high speed signal lanes, and supports higher speed. Can be broken out into 4 SAS connectors or used for a PCIe x4 device. The actual protocol supported depends on the controller. It is a popular controller-side connector for U.2 SSDs, so it was, for a while, referred as the &quot;U.2&quot; connector. Now &quot;U.2&quot; usually referrs to SFF-8639.<br><img src="/images/server-connector-gallery/minisas-hd-internal.avif" alt="Internal MiniSAS HD, image from 10Gtek"></p><p><a href="https://members.snia.org/document/dl/25952" target="_blank" rel="noopener"><strong>SFF-8644</strong> <em>Mini Multilane 4/8X 12 Gb/s Shielded Cage/Connector (HD12sh)</em></a><br>External version of the MiniSAS HD connector.</p><p><img src="/images/server-connector-gallery/minisas-hd-external.avif" alt="External MiniSAS HD, image from the Internet"></p><p>Note there are multiple other specs defining basically the same thing:</p><ul><li><a href="https://members.snia.org/document/dl/25938" target="_blank" rel="noopener"><strong>SFF-8613</strong> <em>Mini Multilane 4/8X Unshielded Connector (HDun)</em></a><br>Defines the footprint and dimension of the unshielded connector.</li><li><a href="https://members.snia.org/document/dl/25939" target="_blank" rel="noopener"><strong>SFF-8614</strong> <em>Mini Multilane 4/8X Shielded Cage/Connector (HDsh)</em></a><br>Defines the footprint and dimension of the shielded connector.</li><li><a href="https://members.snia.org/document/dl/25966" target="_blank" rel="noopener"><strong>SFF-8673</strong> <em>Mini Multilane 4/8X 24 Gb/s Unshielded Connector (HD24un)</em></a><br>Almost the same as 8643, but for SAS-4 24Gbps rather than SAS-3 12Gbps.</li><li><a href="https://members.snia.org/document/dl/25967" target="_blank" rel="noopener"><strong>SFF-8674</strong> <em>Mini Multilane 4/8X 24 Gb/s Shielded Cage/Connector (HD24sh)</em></a><br>Almost the same as 8644, but for SAS-4 24Gbps rather than SAS-3 12Gbps.</li></ul><h2 id="SlimSAS"><a href="#SlimSAS" class="headerlink" title="SlimSAS"></a>SlimSAS</h2><p><a href="https://members.snia.org/document/dl/26744" target="_blank" rel="noopener"><strong>SFF-8654</strong> <em>0.6mm 4/8X Unshielded I/O Connector</em></a><br><a href="https://members.snia.org/document/dl/27380" target="_blank" rel="noopener"><strong>SFF-9402</strong> <em>Multi-Protocol Internal Cables for SAS and/or PCIe</em></a> contains the pinout for this and multiple other connectors.</p><p>SlimSAS comes in two different width called &quot;SlimSAS 8i&quot; or &quot;SlimSAS 4i&quot;, which have 8 or 4 high speed lanes respectively. The protocol running in the wire depends on the device, typically PCIe or SAS. For example, a SlimSAS 8i connector can connect to two PCIe x4 U.2 drives using a split cable.<br><img src="/images/server-connector-gallery/slimsas.avif" alt="SlimSAS connector"></p><p>Some SlimSAS connectors have extra plastic &quot;ears&quot; on the corners. These parts hold the metal piece of the socket and make the connection more sturdy.<br><img src="/images/server-connector-gallery/slimsas-extra-plastic.avif" alt="SlimSAS plug variation, images from Amazon"></p><p>Some manufactures make non-standard &quot;Low Profile&quot; SlimSAS connectors. They are not thinner but are shorter than the standard connector when the two parts are mated. The gold finger PCB retracts into the plug to about the same position as the metal latch. Not to be confused with the above one that has the &quot;ears&quot;, the PCB there still extends beyond the latch. The low-profile plug/socket is not compatible with the standard ones. Here&#39;s a picture and the datasheet from Amphenol <a href="/images/server-connector-gallery/SlimSAS_LP_CA_Tech_Datasheet.pdf">SlimSAS LP Cable Assemblies Technical Datasheet</a>.</p><p><img src="/images/server-connector-gallery/slimsas-low-profile.avif" alt="SlimSAS LP plug"></p><h2 id="MCIO"><a href="#MCIO" class="headerlink" title="MCIO"></a>MCIO</h2><p><a href="https://members.snia.org/document/dl/33768" target="_blank" rel="noopener"><strong>SFF-TA-1016</strong> <em>Internal Unshielded High Speed Connector System</em></a><br>MCIO is probably the successor of SlimSAS and is for highspeed PCIe/SAS signals and comes with multiple widths. The width is identified by their pin count rather than lane count:</p><ul><li>38 pin: 4 lanes. Note this pin count matches SlimSAS 4i.</li><li>74 pin: 8 lanes. Note this pin count matches SlimSAS 8i.</li><li>124 pin: 16 lanes.</li><li>148 pin: 16 lanes with more sideband signals.</li></ul><p><img src="/images/server-connector-gallery/mcio.avif" alt="MCIO connectors"></p><p><a href="https://members.snia.org/document/dl/51668" target="_blank" rel="noopener"><strong>SFF-TA-1033</strong> <em>Internal High-Speed Cable / Modular Connector System</em></a><br>A special type of socket derived from SFF-TA-1016, by bundling one or two 74 pin sockets and a power socket together.<br><img src="/images/server-connector-gallery/mcio-combo.avif" alt="MCIO sockets"></p><h2 id="CDFP"><a href="#CDFP" class="headerlink" title="CDFP"></a>CDFP</h2><p><a href="https://members.snia.org/document/dl/27465" target="_blank" rel="noopener"><strong>INF-TA-1003</strong> <em>400 Gb/s (16 x 25 Gb/s) Pluggable Transceiver</em></a> (a.k.a. CDFP MSA)<br><a href="https://members.snia.org/document/dl/37618" target="_blank" rel="noopener"><strong>SFF-TA-1032</strong> <em>Multi-lane External High Speed Cable System</em></a><br>CDFP is a relatively new external connector type designed for PCIe 5.0 and higher speeds. Recall that the external MiniSAS HD is only defined up to PCIe Gen4. The SFF-TA-1032 doc defines x4 and x8 width beyond the MSA (only x16).</p><p><img src="/images/server-connector-gallery/cdfp.avif" alt="CDFP connector, image from TE Connectivity"></p><h2 id="The-SFF-TA-1002-family"><a href="#The-SFF-TA-1002-family" class="headerlink" title="The SFF-TA-1002 family"></a>The SFF-TA-1002 family</h2><p><a href="https://members.snia.org/document/dl/27231" target="_blank" rel="noopener"><strong>SFF-TA-1002</strong> <em>Protocol Agnostic Multi-Lane High Speed Connector</em></a><br><a href="https://members.snia.org/document/dl/30384" target="_blank" rel="noopener"><strong>REF-TA-1012</strong> <em>Pin Assignment Reference for SFF-TA-1002 Connectors</em></a><br>Sometimes known as &quot;Gen-Z&quot;, SFF-TA-1002 is generally a connector designed for PCB edge connection. It&#39;s popular in datacenter and there are multiple different device form factors that utilize this connector. This connector also have multiple width:</p><ul><li>1C: generally carries 4 lanes</li><li>2C: generally carries 8 lanes</li><li>4C: generally carries 16 lanes</li><li>4C+: 16 lanes plus extra sideband signals.</li></ul><p><img src="/images/server-connector-gallery/genz.avif" alt="SFF-TA-1002 of different widths"></p><p><a href="https://members.snia.org/document/dl/31259" target="_blank" rel="noopener"><strong>SFF-TA-1020</strong> <em>Cables and Connector Variants Based on SFF-TA-1002</em></a><br>SFF-TA-1020 defines a new 4C-HP width for delivering power. It&#39;s similar to the 4C+ connector, but the plastic key width is different, preventing insertion of a wrong board. It also defines a cable plug, similar to MCIO.<br><img src="/images/server-connector-gallery/genz-cables.avif" alt="4C-HP and cable plugs"><br><img src="/images/server-connector-gallery/genz-cables2.avif" alt="Gen-Z cable plugs, images from TE Connectivity"></p><p><a href="https://www.opencompute.org/documents/ocp-nic-3-0-r1v00-20191219a-tn-no-cb-pdf" target="_blank" rel="noopener"><strong>OCP NIC 3.0 Design Specification</strong></a><br>OCP 3.0 is a standard specified by the Open Compute Project. It primarily defines a form factor for server NICs, and uses SFF-TA-1002 as the connector. ServeTheHome has a great article talking about OCP 3.0: <a href="https://www.servethehome.com/ocp-nic-3-0-form-factors-quick-guide-intel-broadcom-nvidia-meta-inspur-dell-emc-hpe-lenovo-gigabyte-supermicro/" target="_blank" rel="noopener">OCP NIC 3.0 Form Factors The Quick Guide</a></p><p><img src="/images/server-connector-gallery/ocp30-nic.avif" alt="An OCP 3.0 NIC, image from ServeTheHome"></p><p><a href="https://members.snia.org/document/dl/26956" target="_blank" rel="noopener"><strong>SFF-TA-1006</strong> <em>Enterprise and Datacenter 1U Short Device Form Factor (E1.S)</em></a><br><a href="https://members.snia.org/document/dl/26644" target="_blank" rel="noopener"><strong>SFF-TA-1007</strong> <em>Enterprise and Datacenter 1U Long Device Form Factor (E1.L)</em></a><br><a href="https://members.snia.org/document/dl/26716" target="_blank" rel="noopener"><strong>SFF-TA-1008</strong> <em>Enterprise and Datacenter Standard Form Factor (E3)</em></a><br><a href="https://members.snia.org/document/dl/26837" target="_blank" rel="noopener"><strong>SFF-TA-1009</strong> <em>Enterprise and Datacenter Standard Form Factor Pin and Signal Specification (EDSFF)</em></a></p><p>EDSFF (Enterprise and Datacenter Standard Form Factor) is a form factor designed for SSD storage devices. There&#39;s an introduction on the SNIA website: <a href="https://www.snia.org/forums/cmsi/knowledge/formfactors" target="_blank" rel="noopener">SSD form factors</a>. These devices also use the SFF-TA-1002 connector, typically 1C for 4 lanes.</p><p><img src="/images/server-connector-gallery/e1s.avif" alt="An E1.S drive, image from the Internet"><br><img src="/images/server-connector-gallery/e1s-pcb.avif" alt="EDSFF connector orientation"></p><h2 id="OCuLink"><a href="#OCuLink" class="headerlink" title="OCuLink"></a>OCuLink</h2><p><a href="https://members.snia.org/document/dl/27937" target="_blank" rel="noopener"><strong>SFF-8611</strong> <em>MiniLink 4/8X I/O Cable Assemblies</em></a> for the cable plug<br><a href="https://members.snia.org/document/dl/51522" target="_blank" rel="noopener"><strong>SFF-8612</strong> <em>MiniLink 4/8X Shielded Connector</em></a> for the receptacle<br>OCuLink is yet another connector capable of carrying SAS / PCIe signals up to PCIe 3.0. Despite being an internal connector, it&#39;s popular in the MiniPC market, as a replacement for Thunderbolt to connect external GPUs. It also has two width options: OCuLink 4i for 4 lanes and OCuLink 8i for 8 lanes.</p><p><img src="/images/server-connector-gallery/oculink.avif" alt="OCuLink 4i, image from the Internet"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Here&amp;#39;s a list of some common connectors for PCs and servers. Many are named like &lt;code&gt;SFF-1234&lt;/code&gt;. The corresponding standard doc may be found in the &lt;a href=&quot;https://www.snia.org/technology-communities/sff/specifications&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SNIA website&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;SAS-U-2-U-3&quot;&gt;&lt;a href=&quot;#SAS-U-2-U-3&quot; class=&quot;headerlink&quot; title=&quot;SAS / U.2 / U.3&quot;&gt;&lt;/a&gt;SAS / U.2 / U.3&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://members.snia.org/document/dl/25920&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;SFF-8482&lt;/strong&gt; &lt;em&gt;Serial Attachment 2X Unshielded Connector&lt;/em&gt;&lt;/a&gt;&lt;br&gt;Our good old SAS connector. Supports two links, though in most cases only 1 link is used.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/server-connector-gallery/sas.avif&quot; alt=&quot;SAS connector, image from SAS-4 INCITS 534&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="HomeLab" scheme="https://recursiveg.me/tags/HomeLab/"/>
    
  </entry>
  
  <entry>
    <title>使用 ascii-xfr 传输 rz 程序</title>
    <link href="https://recursiveg.me/2023/01/transfer-lrzsz-binary-using-ascii-xfr/"/>
    <id>https://recursiveg.me/2023/01/transfer-lrzsz-binary-using-ascii-xfr/</id>
    <published>2023-01-23T13:00:00.000Z</published>
    <updated>2023-01-24T04:03:16.485Z</updated>
    
    <content type="html"><![CDATA[<p>最近继续折腾一些嵌入式设备，需要通过 UART 传输一些文件。一般来说直接使用 rz/sz 即可，但不幸的是 rz applet 并没有编译进这个设备的 busybox。同时由于一些蛋疼的原因，我们也不能重新烧写设备的 rootfs 镜像或者是从网络安装，那么就只能自己想办法解决咯……</p><p>基本思路是自己静态编译一份 rz 程序，然后从串口发送给嵌入式设备，然后再利用这个 rz 接收 sz。然后就能双向发送文件了。</p><p>设备上至少需要有<code>cat</code>命令和<code>base64 -d</code>。如果没有base64可以试试<code>openssl base64 -d</code>。如果还是没有那这篇文章的方法就不适用于你了。另外在设备上最好还要有一个 gzip 之类的压缩程序，可以显著缩短初次传输时间，以及一个 checksum 程序用于检查。我这里用了<code>xz</code>和<code>md5sum</code>。</p><p>在主机上你需要有<code>ascii-xfr</code>程序。</p><h2 id="编译-rz"><a href="#编译-rz" class="headerlink" title="编译 rz"></a>编译 rz</h2><p>你需要有一个能用的工具链，我的设备是 AArch64，直接使用了源里的 gcc。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载代码</span></span><br><span class="line">wget <span class="string">'https://www.ohse.de/uwe/releases/lrzsz-0.12.20.tar.gz'</span></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar xaf lrzsz-0.12.20.tar.gz</span><br><span class="line"><span class="built_in">cd</span> lrzsz-0.12.20</span><br><span class="line"><span class="comment"># 静态编译</span></span><br><span class="line">CFLAGS=<span class="string">'-Oz -static'</span> CC=aarch64-linux-gnu-gcc  ./configure --target=arm64-linux</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>如果你有对应设备的工具链也可以动态编译，这样编译出来的文件会更小。</p><h2 id="使用-ascii-xfr-发送-rz"><a href="#使用-ascii-xfr-发送-rz" class="headerlink" title="使用 ascii-xfr 发送 rz"></a>使用 ascii-xfr 发送 rz</h2><p>我这里使用<code>picocom</code>连接设备，其他程序比如<code>minicom</code>，<code>screen</code>请自行查阅手册寻找使用方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 接上文</span></span><br><span class="line">cp src/lrz rz</span><br><span class="line"><span class="comment"># 进一步裁剪文件体积</span></span><br><span class="line">aarch64-linux-gnu-strip --strip-all rz</span><br><span class="line"><span class="comment"># 计算 checksum 备用</span></span><br><span class="line">md5sum rz</span><br><span class="line">ee96d7186db0f5240040c183636a8c9d</span><br><span class="line"><span class="comment"># 压缩</span></span><br><span class="line">xz -9 rz</span><br><span class="line"><span class="comment"># 编码成 BASE64</span></span><br><span class="line">base64 rz.xz &gt; rz.xz.64</span><br><span class="line"><span class="comment"># 连接设备，记得使用你自己设备的波特率</span></span><br><span class="line">picocom -b 1500000 -s <span class="string">'ascii-xfr -sn -c 1'</span> /dev/ttyUSB0</span><br><span class="line"><span class="comment"># 在设备中准备接收</span></span><br><span class="line">wimpy_board$ cat &gt; rz.xz.64</span><br><span class="line"><span class="comment"># 按 Ctrl-A Ctrl-S，然后输入要发送的文件的文件名</span></span><br><span class="line">*** file: rz.xz.64</span><br><span class="line"><span class="comment"># 等待字符滚完，然后按 回车 + Ctrl-D 退出 cat</span></span><br><span class="line"><span class="comment"># 传输速度是 1000Bps，我最终需要传输 420 多 KB，需要 7 分钟。</span></span><br><span class="line"><span class="comment"># 传输完毕后在设备上还原可执行文件</span></span><br><span class="line">wimpy_board$ base64 -d rz.xz.64 &gt; rz.xz</span><br><span class="line">wimpy_board$ xz -d rz.xz</span><br><span class="line">wimpy_board$ chmod +x rz</span><br><span class="line"><span class="comment"># 最后比较一下 md5 值，并确认可以正常运行</span></span><br><span class="line">wimpy_board$ md5sum rz</span><br><span class="line">ee96d7186db0f5240040c183636a8c9d</span><br><span class="line">wimpy_board$ ./rz</span><br><span class="line"><span class="comment"># 连按 5 次 Ctrl-X 退出</span></span><br></pre></td></tr></table></figure><h2 id="使用-rz-接收-sz"><a href="#使用-rz-接收-sz" class="headerlink" title="使用 rz 接收 sz"></a>使用 rz 接收 sz</h2><p>有经验的朋友到这里可以直接右上角退出了，不过我还是记录一下做个备忘。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按 Ctrl-A Ctrl-X 退出 picocom，然后再重新连接。</span></span><br><span class="line"><span class="comment"># 不带 -s 参数时 picocom 默认使用本机的 sz 发送文件。</span></span><br><span class="line">picocom -b 1500000 /dev/ttyUSB0</span><br><span class="line">wimpy_board$ ./rz</span><br><span class="line">waiting to receive.**</span><br><span class="line"><span class="comment"># 按 Ctrl-A Ctrl-S，然后输入要发送的文件的文件名</span></span><br><span class="line">*** file: src/lsz</span><br><span class="line">$ sz -vv src/lsz</span><br><span class="line">Sending: lsz</span><br><span class="line">Bytes Sent:1173536   BPS:144649                          </span><br><span class="line"></span><br><span class="line">Transfer complete</span><br><span class="line"></span><br><span class="line">*** <span class="built_in">exit</span> status: 0 ***</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近继续折腾一些嵌入式设备，需要通过 UART 传输一些文件。一般来说直接使用 rz/sz 即可，但不幸的是 rz applet 并没有编译进这个设备的 busybox。同时由于一些蛋疼的原因，我们也不能重新烧写设备的 rootfs 镜像或者是从网络安装，那么就只能自己想办
      
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="折腾" scheme="https://recursiveg.me/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="硬件" scheme="https://recursiveg.me/tags/%E7%A1%AC%E4%BB%B6/"/>
    
      <category term="脚本" scheme="https://recursiveg.me/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>折腾 RISC-V 单片机 Part1</title>
    <link href="https://recursiveg.me/2022/06/riscv-microcontroller-intro-part1/"/>
    <id>https://recursiveg.me/2022/06/riscv-microcontroller-intro-part1/</id>
    <published>2022-06-22T16:00:00.000Z</published>
    <updated>2022-06-23T06:58:48.216Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/riscv-microcontroller-intro-part1/01-board-pic.png" alt="SparkFun RED-V"></p><p>大约半年前在 SparkFun 上买了一块 RED-V 开发板。基本算是 HiFive1 Rev B 的克隆，比 Rev B 便宜一些，同样使用 SiFive 的 FE310-G002 处理器。SiFive 的 MCU 自带一套 SDK，不过要搭配指定的 IDE 才好用，作为有洁癖的 Linux 用户这当然是不行的，所以就有了这次的折腾。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我一开始是打算用 SDK 的代码，不过看了一圈感觉这样和玩 Arduino 也没区别了，失去了折腾的意义，所以决定放弃 SDK 直接用汇编艹寄存器。<br>这里是需要准备的文档和工具：</p><ul><li>SparkFun RED-V Schematic: 这是板子的电路图，用来看板子上的接口都具体连接到 MCU 的哪个针脚。</li><li><a href="https://www.sifive.com/documentation" target="_blank" rel="noopener">Freedom E310-G002 Datasheet/Manual</a>: 这两份文件可以从 SiFive 的网站上下载到，包含几乎所有重要信息。</li><li>Clang: 编译器。为啥不用 GCC？因为我不想单独折腾一份 GCC 的工具链。Clang 既可以编译出 x86 程序又可以编译出 RISC-V 程序，从软件源里装好就可以直接用了。</li><li>LLD: LLVM Linker。这下也不用配置 RISC-V 的 binutils 了</li><li>OpenOCD: 负责和板子通信，烧录程序，调试等。</li></ul><p>三份 PDF 文档需要自己下载，而其他三个程序应该能直接用包管理装。</p><a id="more"></a><h2 id="单片机基础"><a href="#单片机基础" class="headerlink" title="单片机基础"></a>单片机基础</h2><p>简单而言，单片机不像 CPU，有各种内存保护/分页机制等。所有的硬件控制/非易失存储（硬盘）/易失存储（内存）都位于同一个 Memory space。<br>详细信息可以在 Manual Chapter 4 中看到，比如说，<code>[0x20000, 0x21FFF]</code> 就属于 “OTP Memory Region”。</p><p><img src="/images/riscv-microcontroller-intro-part1/02-manual-chapter4.png" alt="Manual Chapter 4 的截图"></p><p>另外一些地址可以用于控制硬件，比如<code>[0x1001_2000, 0x1001_2FFF]</code>属于 GPIO，稍后可以看到，如果往某个特定的地址写<code>1</code>，那么芯片上的某个针脚的电平(电压)就会发生变化，如果这个针脚上连了一个 LED，那么它的亮灭状态也会发生变化。这些可以控制硬件行为的地址我一般称之为寄存器，注意不要和汇编语言里的寄存器搞混了。</p><h2 id="程序应该放在哪儿？"><a href="#程序应该放在哪儿？" class="headerlink" title="程序应该放在哪儿？"></a>程序应该放在哪儿？</h2><p>一个重要的问题是，单片机在启动的时候到底会执行哪条指令？查看 Manual Chapter 5.1 可知:</p><pre><code>On power-on, the core&apos;s reset vector is 0x1004.</code></pre><p>即会首先执行 0x1004 处的指令（练习：请翻阅 Memory Map 查看该地址属于哪片区域？）并且手册也列出了预先烧录在该地址的指令列表。不过很可惜我并没有找到文档里所说的 <code>MSEL pin</code> 在哪里，不过从调试结果来看，0x1018处的jr指令最终会跳转到0x10000处。</p><p>继续阅读 Manual 5.1.1, 0x10000处的指令会跳转到0x20000，继续阅读Datasheet Chapter 5 &quot;Boot code&quot;，我们最终会跳转到地址0x20000000，查看memory map，该地址属于QSPI 0 Flash，也就是非易失存储器，看上去这里就是我们应该写入代码的地方了。（PC程序员初次看到Program counter能直接指向外部存储设备实在是刷新三观）。</p><h2 id="编程器"><a href="#编程器" class="headerlink" title="编程器"></a>编程器</h2><p>向单片机写入程序的过程被称作 program（编程），所以用来编程的硬件也就叫做“编程器”了。还有一个我无论如何都无法理解的翻译叫做“仿真器”，英文叫 emulator, 这应该也是一个上古词汇，但是比起“编程器”，这个词更强调你可以调试单片机上的程序，比如下断点，单步执行等。现在一般用来指链接单片机和电脑的那根线。总而言之，你需要一个东西把单片机和电脑连起来，以便两者通信。</p><p>一般来说，这个硬件一头用JTAG等方式连接到单片机，另一头通过USB协议连接电脑，OpenOCD则是一个开源的程序允许你通过这个“编程器”以各种方式操纵各种单片机。当然也包括向 SPI Flash 中写入我们的程序。</p><p>在 RED-V 上，最大的芯片是一块 MK22FN128 的ARM单片机，这块单片机里预先写入了一个 <a href="link">J-Link OB</a> 的商业程序，这个程序让这个ARM单片机实现了编程器的功能，所以我们只要直接用普通的USB线连接板子和电脑就可以了。J-Link 使用一种特殊的协议与电脑通信，好在Segger公司公开了这种协议的spec，所以OpenOCD也能和编程器通信啦。</p><h2 id="TLDR"><a href="#TLDR" class="headerlink" title="TLDR"></a>TLDR</h2><ul><li>单片机通电后会经过一系列跳转，最终开始执行 0x20000000 处的指令。</li><li>该地址实际访问的是外部的存储器。</li><li>可以通过编程器向该存储器中写入数据。</li></ul><p>To be continued in part 2.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/riscv-microcontroller-intro-part1/01-board-pic.png&quot; alt=&quot;SparkFun RED-V&quot;&gt;&lt;/p&gt;
&lt;p&gt;大约半年前在 SparkFun 上买了一块 RED-V 开发板。基本算是 HiFive1 Rev B 的克隆，比 Rev B 便宜一些，同样使用 SiFive 的 FE310-G002 处理器。SiFive 的 MCU 自带一套 SDK，不过要搭配指定的 IDE 才好用，作为有洁癖的 Linux 用户这当然是不行的，所以就有了这次的折腾。&lt;/p&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;p&gt;我一开始是打算用 SDK 的代码，不过看了一圈感觉这样和玩 Arduino 也没区别了，失去了折腾的意义，所以决定放弃 SDK 直接用汇编艹寄存器。&lt;br&gt;这里是需要准备的文档和工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SparkFun RED-V Schematic: 这是板子的电路图，用来看板子上的接口都具体连接到 MCU 的哪个针脚。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.sifive.com/documentation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Freedom E310-G002 Datasheet/Manual&lt;/a&gt;: 这两份文件可以从 SiFive 的网站上下载到，包含几乎所有重要信息。&lt;/li&gt;
&lt;li&gt;Clang: 编译器。为啥不用 GCC？因为我不想单独折腾一份 GCC 的工具链。Clang 既可以编译出 x86 程序又可以编译出 RISC-V 程序，从软件源里装好就可以直接用了。&lt;/li&gt;
&lt;li&gt;LLD: LLVM Linker。这下也不用配置 RISC-V 的 binutils 了&lt;/li&gt;
&lt;li&gt;OpenOCD: 负责和板子通信，烧录程序，调试等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三份 PDF 文档需要自己下载，而其他三个程序应该能直接用包管理装。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="折腾" scheme="https://recursiveg.me/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="硬件" scheme="https://recursiveg.me/tags/%E7%A1%AC%E4%BB%B6/"/>
    
      <category term="RISC-V" scheme="https://recursiveg.me/tags/RISC-V/"/>
    
  </entry>
  
  <entry>
    <title>Rclone 同步 OneDrive for Business 共享</title>
    <link href="https://recursiveg.me/2022/01/rclone-onedrive-for-business/"/>
    <id>https://recursiveg.me/2022/01/rclone-onedrive-for-business/</id>
    <published>2022-01-29T17:30:00.000Z</published>
    <updated>2022-01-30T07:49:27.687Z</updated>
    
    <content type="html"><![CDATA[<p>使用 OneDrive for Business 的 WebDAV 接口访问，无需登录。先去浏览器访问你拿到的分享链接，地址栏应该会变成如下形式：</p><pre><code>https://[YOUR-DOMAIN]-my.sharepoint.com/personal/[YOUR-EMAIL]/_layouts/15/onedrive.aspx?[一堆别的东西]</code></pre><p>然后打开 F12 找到一个叫 <code>FedAuth</code> 的 Cookie：</p><pre><code>FedAuth=77u/......</code></pre><p>然后用命令行在 rclone 里添加一个 WebDAV 的远程地址。语法是这样的：</p><pre><code>rclone config create &lt;name&gt; &lt;type&gt; &lt;key&gt;=&lt;val&gt; &lt;key&gt;=&lt;val&gt; ...</code></pre><p>具体到这里就是：</p><pre><code>rclone config create &lt;随便&gt; webdav &apos;url=https://[YOUR-DOMAIN].sharepoint.com/personal/[YOUR-EMAIL]/Documents&apos; &apos;headers=Cookie,FedAuth=77u/...&apos;</code></pre><p>细节请根据浏览器里的信息自己调节，如果设置无误就可以在 Rclone 里查看文件了：</p><pre><code>rclone lsd &apos;&lt;你之前填的&gt;:&apos;</code></pre><p>几个注意事项：</p><ul><li>暂不清楚这个 Cookie 的有效期是多长，如果 Cookie 失效的话自然就不能访问了。</li><li>限速是存在的，如果 sync 的时候进度不动并且网络没流量通过，那大概是被限了。rclone 自己的速度计在速度为 0 的时候不会立即归零，而是 5MB,4MB,3MB... 这样慢慢下去，非常反直觉。限速时间还挺长的，暂时没有发现好办法能绕过。</li><li>暂不清楚是不是所有的分享链接都可以用这种方式访问，可能需要组织管理员开启 WebDAV 功能？</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用 OneDrive for Business 的 WebDAV 接口访问，无需登录。先去浏览器访问你拿到的分享链接，地址栏应该会变成如下形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://[YOUR-DOMAIN]-my.sharepoint.com/personal
      
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="网盘" scheme="https://recursiveg.me/tags/%E7%BD%91%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>LTO-5 磁带机折腾入门</title>
    <link href="https://recursiveg.me/2021/09/lto-tape-drive-intro/"/>
    <id>https://recursiveg.me/2021/09/lto-tape-drive-intro/</id>
    <published>2021-09-04T13:00:00.000Z</published>
    <updated>2021-09-05T05:04:58.238Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/lto-tape-drive-intro/00-lto5-cartridge.jpg" alt="LTO-5 Cartridge"><br>最近在 eBay 上捡了一台 HP 的 LTO-5 磁带机，型号是 BRSLA-0903-DC，这次就把折腾过程简单记录一下。<br>LTO 磁带机本体一般都是标准的 5.25 寸光驱位大小，接口类型一般是 Fiber Channel 或者是 SAS 加上供电用的 Molex 4Pin。<br>不管哪种接口你都需要一张对应的 HBA 卡插在 PCI-E 槽里，以及对应的光纤线或者是 SAS 线把磁带机接到卡上。<br>如果机箱带光驱位，SAS 的磁带机可以直接放在机箱里，FC 的应该就不行了，因为我还没找到接口朝内部的 FC HBA 卡。</p><a id="more"></a><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>（由于我懒得拍实物图，本文所有图都是网上找的）</p><p>我买到的是一台 FC 接口的磁带机，注意这张图里的磁带机外面还有一个转接架，是给磁带库用的，自己用需要拆掉。<br><img src="/images/lto-tape-drive-intro/01-lto5-fc-tape-drive.jpg" alt="LTO-5 Tape Drive"><br>对应的光纤通道 HBA 卡<br><img src="/images/lto-tape-drive-intro/02-fiber-channel-hba.jpg" alt="Fiber Channel HBA"><br>和光纤线<br><img src="/images/lto-tape-drive-intro/03-lc-lc-optic-cable.jpg" alt="LC-LC Fiber Optic Cable"><br>以及不知道从哪儿来的供电线<br><img src="https://upload.wikimedia.org/wikipedia/commons/1/13/Molex.jpg" alt="Molex Power Cable"><br>全部接上就可以开机了。</p><p>所有以上硬件再加上 5 盘磁带大概一共花了 300 美刀左右。顺便吐槽一下 LTO-6 磁带机的拍卖价格真疯狂（600+）。</p><h2 id="TAR-Tape-ARchive"><a href="#TAR-Tape-ARchive" class="headerlink" title="TAR (Tape ARchive)"></a>TAR (Tape ARchive)</h2><p>磁带机应该会在 Linux 下显示为<code>/dev/st0</code>和<code>/dev/nst0</code>设备，区别在于<code>st</code>设备会在任何操作后将磁带倒带回开头，而<code>nst</code>设备会将磁带停留在操作结束的地方。</p><p><code>tar</code>程序可以直接对设备进行操作，比如，将文件拷贝进磁带：</p><pre><code>tar -cvf /dev/nst0 filename</code></pre><p>将文件从磁带还原：</p><pre><code>tar -xvf /dev/nst0</code></pre><p>列出磁带上的文件：</p><pre><code>tar -tf /dev/st0</code></pre><p>更多操作可以参考这篇文档： <a href="http://hep.uchicago.edu/cdf/howto/TapeArchiving.html" target="_blank" rel="noopener">How to archive data using the AIT2 attached to CDF17</a></p><h2 id="LTFS-Linear-Tape-File-System"><a href="#LTFS-Linear-Tape-File-System" class="headerlink" title="LTFS (Linear Tape File System)"></a>LTFS (Linear Tape File System)</h2><p>LTO 从 LTO-5 开始支持 LTFS，你可以先将磁带“格式化”，然后用更为熟悉的目录结构来管理磁带上的文件。你需要自己从 <a href="https://github.com/LinearTapeFileSystem/ltfs" target="_blank" rel="noopener">LTFS 的 GitHub 源码</a> 编译。Arch 用户也可以直接用 <a href="https://aur.archlinux.org/packages/ltfs/" target="_blank" rel="noopener">AUR 包</a>。具体使用方法在 <a href="https://github.com/LinearTapeFileSystem/ltfs/wiki/Quick-start" target="_blank" rel="noopener">Quick Start</a> 里已经写得很清楚了：</p><p>1.列出设备（如果没有可以尝试手动<code>modprobe sg</code>）</p><pre><code>sudo ltfs -o device_list</code></pre><p>2.格式化磁带</p><pre><code>sudo mkltfs -d /dev/sgX</code></pre><p>3.挂载</p><pre><code>sudo ltfs -o devname=/dev/sgX /ltfs</code></pre><p>4.卸载</p><pre><code>sudo umount /ltfs</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>磁带机买来干什么？鉴于磁带的顺序读写以及需要手动换磁带（买带库的大佬请忽略）的特性，注定了它只适合于备份和归档用途。备份像是重疾保险，你希望永远也用不上；归档是你 6 岁时的玩具，舍不得丢但也不会再用。所以如果你说 NAS 空间不够，要用磁带来存你的电影，我觉得不太行。但如果你仓鼠症发作，打算收集世界上所有的电影，磁带大概可行。</p><p>我还顺便搜集了一下 HP 的官方文档，方便参考：</p><ul><li>HP LTO Ultrium tape drives technical reference manual, Volume 1~5, LTO5 drives:<ul><li><a href="/images/lto-tape-drive-intro/LTO5_Vol1_lto_ultrium.pdf">Volume 1: Hardware integration</a></li><li><a href="/images/lto-tape-drive-intro/LTO5_Vol2_E2_not_restricted.pdf">Volume 2: Software integration</a></li><li><a href="/images/lto-tape-drive-intro/LTO5_Vol3_E5b.pdf">Volume 3: Host Interface Guide</a></li><li><a href="/images/lto-tape-drive-intro/LTO5_Vol4_E4.pdf">Volume 4: Specifications</a></li><li><a href="/images/lto-tape-drive-intro/LTO5_Vol5_E3.pdf">Volume 5: UNIX, Linux and OpenVMS configuration guide</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/lto-tape-drive-intro/00-lto5-cartridge.jpg&quot; alt=&quot;LTO-5 Cartridge&quot;&gt;&lt;br&gt;最近在 eBay 上捡了一台 HP 的 LTO-5 磁带机，型号是 BRSLA-0903-DC，这次就把折腾过程简单记录一下。&lt;br&gt;LTO 磁带机本体一般都是标准的 5.25 寸光驱位大小，接口类型一般是 Fiber Channel 或者是 SAS 加上供电用的 Molex 4Pin。&lt;br&gt;不管哪种接口你都需要一张对应的 HBA 卡插在 PCI-E 槽里，以及对应的光纤线或者是 SAS 线把磁带机接到卡上。&lt;br&gt;如果机箱带光驱位，SAS 的磁带机可以直接放在机箱里，FC 的应该就不行了，因为我还没找到接口朝内部的 FC HBA 卡。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="折腾" scheme="https://recursiveg.me/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="硬件" scheme="https://recursiveg.me/tags/%E7%A1%AC%E4%BB%B6/"/>
    
      <category term="LTO" scheme="https://recursiveg.me/tags/LTO/"/>
    
  </entry>
  
  <entry>
    <title>USB4 与 Thunderbolt 4 备忘</title>
    <link href="https://recursiveg.me/2021/08/usb4-thunderbolt4-memo/"/>
    <id>https://recursiveg.me/2021/08/usb4-thunderbolt4-memo/</id>
    <published>2021-08-28T06:30:00.000Z</published>
    <updated>2021-08-28T21:23:27.553Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/usb4-thunderbolt4-memo/01-summary-diagram.png" alt="Summary"></p><p>最近研究了一些关于 USB4 以及 Thunderbolt 4 的资料，在此做个备忘。目前只考虑 USB Type-C 接口，并且忽略 Type-C 可以正反随意插带来的复杂性。</p><ol><li>USB Type-C 接口里有一对（两根）差分信号线，用于 USB 2.0 协议（USB 2.0, 480 Mbps）。</li><li>USB Type-C 接口里有四根 GND 以及四根 V_BUS 用于送电，具体电压和电流由两端使用 CC 线协商 (Power delivery)。</li><li>在 Type-C 接口里再取两对差分信号线，用于 USB 3.x 协议（USB 3.2 Gen 1, 5 Gbps）。</li><li>通过改进协议，可以将传输速度翻倍（USB 3.2 Gen 2, 10 Gbps）。</li><li>再把 Type-C 中最后剩下四根信号线也用上，传输一样的协议，可以将速度再次翻倍（USB 3.2 Gen 2x2, 20 Gbps）。</li><li>大家发现这八根高速信号线不止可以用于 USB，也可以用来传输其他信号。比如：电脑可以与显示器透过 CC 线协商，使用两对差分信号线传输 DisplayPort 信号（DP Alt mode）。</li><li>Intel 觉得 Type-C 接口不错，于是有了 Thunderbolt Alt mode，使用全部四对差分信号线传输 Thunderbolt 协议（Thunderbolt 3, 40Gbps）。<br>Thunderbolt 3 本身是一种隧道协议，在这个隧道中可以传输 PCI-E 数据和 DisplayPort 数据。<br>至于 USB 则可以在扩展坞中内置一个 USB 控制器芯片，通过 PCI-E 与电脑连接，这样扩展坞就可以插 USB 设备了。</li><li>USB-IF 觉得 Thunderbolt 3 这个协议不错，在 Intel 开放了 Thunderbolt 3 协议后，就把它拿过来“改名”成了 USB4。使用 USB Type-C 中的两对或四对差分信号线传输（USB4, ~40Gbps）。<br>与 Thunderbolt 3 相同，USB4 也是一种隧道协议，其中可以传输 USB 3.2，PCI-E，DisplayPort 等协议。<br>（吐槽时间：外层协议和内层协议都叫 USB 你是认真的吗？）<br>USB4 规范并不要求硬件生产厂家实现所有功能，比如说，一个最高只支持 20Gbps 速度的设备可以合法地被称作“支持 USB4”。因为 USB4 规范并不要求所有设备都支持 40Gbps。（吔屎啦你 USB-IF）</li><li>Intel 觉得 USB-IF 的标准混乱，是赚钱的好机会，于是自己列了一套更高的标准（比如要求设备必须支持 40Gbps 速度），并给符合 Intel 的标准的设备贴上 “Thunderbolt 4” 的标签。</li></ol><p>最后围观 USB4 混乱的速度要求被鞭尸的现场：<a href="https://youtu.be/ly5-QHjs8Gw?t=1845" target="_blank" rel="noopener">https://youtu.be/ly5-QHjs8Gw?t=1845</a></p><pre><code>Allison Sheridan: So a Thunderbolt 4 device is a USB4 device...Brad Saunders:    (nodding)Allison Sheridan: ...but a USB4 device is not necessarily a Thunderbolt 4 device?Brad Saunders:    It can be ...Allison Sheridan: It can be but it isn&apos;t necessarily.Brad Saunders:    It&apos;ll probably have... they may have made a choice to... maybe it&apos;s only 20 Gbps.Allison Sheridan: Right, but it&apos;s Thunderbolt 4 it&apos;s 40 [Gbps] per second, Okay.</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/usb4-thunderbolt4-memo/01-summary-diagram.png&quot; alt=&quot;Summary&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近研究了一些关于 USB4 以及 Thunderbolt 4 的资料，在此做个备忘。目前只考虑 U
      
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Memo" scheme="https://recursiveg.me/tags/Memo/"/>
    
  </entry>
  
  <entry>
    <title>手动硬盘安装 WePE</title>
    <link href="https://recursiveg.me/2021/06/manual-wepe-installation/"/>
    <id>https://recursiveg.me/2021/06/manual-wepe-installation/</id>
    <published>2021-06-22T14:00:00.000Z</published>
    <updated>2021-06-23T03:27:31.548Z</updated>
    
    <content type="html"><![CDATA[<p>最近尝试了一些 Windows 下的全盘备份/恢复方案，于是顺便折腾了一下各种 <a href="https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/winpe-intro" target="_blank" rel="noopener">WinPE</a> 系统。WinPE 简单来说就是一个 Windows 的 LiveCD，带有各种用于 Windows 的工具。网友们在微软的 WinPE 基础上加入各种驱动和方便使用的图形化操作界面，作为不同的 WinPE “发行版”发布，<a href="http://www.wepe.com.cn/" target="_blank" rel="noopener">微PE(WePE)</a> 是这些“发行版”之一。</p><p>WePE 自带的安装程序除了安装必要的启动项以外还会安装一些没啥用的选项。所以记录一下手动安装启动项的方法。环境为 Windows 10 64位 UEFI 启动。你需要先制作 WePE 的 ISO，然后把 ISO 里的<code>WEPE</code>目录复制到随便一个分区里，我假设是<code>D:</code>。用管理员身份执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bcdedit &#x2F;create &#x2F;device</span><br><span class="line"># 你会拿到一串 GUID, 假设是 &#123;A...&#125;</span><br><span class="line">bcdedit &#x2F;set &quot;&#123;A...&#125;&quot; ramdisksdidevice partition&#x3D;D:</span><br><span class="line">bcdedit &#x2F;set &quot;&#123;A...&#125;&quot; ramdisksdipath \WEPE\WEPE.SDI</span><br><span class="line"></span><br><span class="line">bcdedit &#x2F;create &#x2F;d &quot;WePE&quot; &#x2F;application osloader</span><br><span class="line"># 你会拿到一串 GUID, 假设是 &#123;B...&#125;</span><br><span class="line">bcdedit &#x2F;set &quot;&#123;B...&#125;&quot; device &quot;ramdisk&#x3D;[D:]\WEPE\WEPE64.WIM,&#123;A...&#125;&quot;</span><br><span class="line">bcdedit &#x2F;set &quot;&#123;B...&#125;&quot; osdevice &quot;ramdisk&#x3D;[D:]\WEPE\WEPE64.WIM,&#123;A...&#125;&quot;</span><br><span class="line">bcdedit &#x2F;set &quot;&#123;B...&#125;&quot; path \windows\system32\boot\winload.efi</span><br><span class="line">bcdedit &#x2F;set &quot;&#123;B...&#125;&quot; systemroot \windows</span><br><span class="line">bcdedit &#x2F;set &quot;&#123;B...&#125;&quot; nx OptIn</span><br><span class="line">bcdedit &#x2F;set &quot;&#123;B...&#125;&quot; pae ForceEnable</span><br><span class="line">bcdedit &#x2F;set &quot;&#123;B...&#125;&quot; detecthal Yes</span><br><span class="line">bcdedit &#x2F;set &quot;&#123;B...&#125;&quot; winpe yes</span><br><span class="line">bcdedit &#x2F;displayorder &quot;&#123;B...&#125;&quot; &#x2F;addlast</span><br><span class="line">bcdedit &#x2F;timeout 3</span><br></pre></td></tr></table></figure><p>设定完启动项以后就可以把盘符删掉了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近尝试了一些 Windows 下的全盘备份/恢复方案，于是顺便折腾了一下各种 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/winpe-intro&quot; targe
      
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="折腾" scheme="https://recursiveg.me/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="Windows" scheme="https://recursiveg.me/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Ciphersuite Memo</title>
    <link href="https://recursiveg.me/2021/02/ciphersuite-memo/"/>
    <id>https://recursiveg.me/2021/02/ciphersuite-memo/</id>
    <published>2021-02-21T11:30:00.000Z</published>
    <updated>2023-01-22T02:04:43.554Z</updated>
    
    <content type="html"><![CDATA[<p>I&#39;m sorry if you landed in this keywords soup only to find it not helpful.</p><ul><li><p><strong>Key Exchange</strong></p><ul><li>DH (<a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman" target="_blank" rel="noopener">Diffie-Hellman</a>): \(g^{xy} = (g^x)^y = (g^y)^x\)</li><li>ECDH (Elliptic-Curve DH)</li><li>ECDHE (ECDH Ephemeral)</li><li>DHE (DH Ephemeral)</li><li><a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)" target="_blank" rel="noopener">RSA (Encryption)</a>: Generate a random bitstream and share it with the peer by encrypting using peer&#39;s RSA public key.</li></ul><p>A related concept is PFS (<a href="https://en.wikipedia.org/wiki/Forward_secrecy" target="_blank" rel="noopener">Perfect Forward Secrecy</a>). DH offers PFS while RSA cannot.</p></li><li><p><strong>Authentication</strong><br>Also known as key-signing. Commonly used together with the PKI(<a href="https://en.wikipedia.org/wiki/Public_key_infrastructure" target="_blank" rel="noopener">Public Key Infrastructure</a>).</p><ul><li><a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Signing_messages" target="_blank" rel="noopener">RSA (Signing)</a></li><li>DSA (<a href="https://en.wikipedia.org/wiki/Digital_Signature_Algorithm" target="_blank" rel="noopener">Digital signature algorithm</a>)</li><li>ECDSA (Elliptic-Curve DSA)</li></ul></li><li><p><strong>Encryption</strong><br>Used for data confidentiality.</p><ul><li>RSA (Encryption): The famous asymmetric encryption algorithm.</li><li>AES (<a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard" target="_blank" rel="noopener">Advanced Encryption Standard</a>): A block cipher.</li><li><a href="https://en.wikipedia.org/wiki/Salsa20#ChaCha_variant" target="_blank" rel="noopener">Chacha</a>: A stream cipher.</li><li>and more...</li></ul><p>A related concept is <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation" target="_blank" rel="noopener">mode of operation</a>,which turns a block cipher to a stream cipher. <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_block_chaining_(CBC)" target="_blank" rel="noopener">CBC</a> is a commonly used one. When it&#39;s used with AES, it&#39;s expressed as <code>AES-CBC</code></p></li><li><p><strong>Message authentication</strong><br>Used for data integrity. These algorithms are also called MAC(<a href="https://en.wikipedia.org/wiki/Message_authentication_code" target="_blank" rel="noopener">Message authentication code</a>).</p><ul><li>Various <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function" target="_blank" rel="noopener">Hash algorithms</a>, including the famous <a href="https://en.wikipedia.org/wiki/Secure_Hash_Algorithms" target="_blank" rel="noopener">SHA family</a>.</li><li>HMAC (<a href="https://en.wikipedia.org/wiki/HMAC" target="_blank" rel="noopener">Hash-based MAC</a>): They uses a hash function inside and allows a &quot;password&quot; to be specified.</li><li><a href="https://en.wikipedia.org/wiki/Poly1305" target="_blank" rel="noopener">Poly1305</a></li></ul></li><li><p><strong>Authenticated Encryption (AE)</strong><br>Combines confidentiality and integrity. Wikipedia: <a href="https://en.wikipedia.org/wiki/Authenticated_encryption" target="_blank" rel="noopener">Authenticated Encryption</a>.</p><ul><li>EtM (<a href="https://en.wikipedia.org/wiki/Authenticated_encryption#Encrypt-then-MAC" target="_blank" rel="noopener">Encrypt-then-MAC</a>): A secure way to combine encryption algorithms with MAC algorithms.</li><li>GCM (<a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode" target="_blank" rel="noopener">Galois/Counter Mode</a>): A mode of operation, when paired with a block cipher, offers AE (actually AEAD) in one step.</li></ul><p>Some commonly used AE methods:</p><ul><li>AES-CBC with an HMAC e.g.<code>AES128-CBC-HMAC-SHA256</code>.</li><li>ChaCha20 with Poly1305.</li><li>AES-GCM</li></ul></li><li><p><strong>Authenticated Encryption with Associated Data (AEAD)</strong><br>Similar to AE, but allows extra unencrypted data (associated data) to be authenticated. Roughly speaking:</p><pre><code>ciphertext = Encrypt(plaintext)auth_tag = Mac(associated_data + ciphertext)</code></pre><p>A common use case for AEAD is when encrypting a network packet, you want the packet header to stay unencrypted (for network routing purposes) but still authenticated.</p></li><li><p><strong>Note about DH and curves of EC-based algorithms</strong><br>DH-based algorithms may have a &quot;Group&quot; option, which specifies a prime field or an elliptic curve. If a prime field is used, such as <code>modp2048</code>, it&#39;s normal DH. If an elliptic curve group is used, such as <code>ecp256</code>, it&#39;s EC-based DH.<br>Some other curves may be used:</p><ul><li><a href="https://en.wikipedia.org/wiki/Curve25519" target="_blank" rel="noopener">Curve25519</a></li><li><a href="https://en.wikipedia.org/wiki/EdDSA" target="_blank" rel="noopener">Edwards curve</a> as in EdDSA and Ed25519</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I&amp;#39;m sorry if you landed in this keywords soup only to find it not helpful.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Key Exchange&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Memo" scheme="https://recursiveg.me/tags/Memo/"/>
    
      <category term="Cryptography" scheme="https://recursiveg.me/tags/Cryptography/"/>
    
  </entry>
  
  <entry>
    <title>IPsec 配置备忘 Part9 - RouterOS</title>
    <link href="https://recursiveg.me/2021/01/ipsec-configurations-part9/"/>
    <id>https://recursiveg.me/2021/01/ipsec-configurations-part9/</id>
    <published>2021-01-18T06:30:00.000Z</published>
    <updated>2021-01-19T04:14:10.763Z</updated>
    
    <content type="html"><![CDATA[<p>这篇来填一个在 Part1 的时候挖的坑，简单介绍一下怎么在 RouterOS 和 strongSwan 之间配置一个 Site-to-Site 的 IKEv2 VPN。如果你还没有动手实际配置过 strongSwan，我强烈建议你先读完至少 Part1~5 和 Part7，并且自己动手配置一个能用的 strongSwan 服务端。这样至少能保证你会配置 strongSwan，否则同时学习 RouterOS 和 strongSwan 两种配置方法会让人云里雾里。</p><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p>RouterOS 做路由器，用 DHCP 给内网设备分配<code>192.168.50.0/24</code>段中的 IP 地址。并且用 IPsec 的 Tunnel 模式将所有来自此 IP 段的数据转发至服务器<code>22.22.22.22</code>。路由器本身的 IP 并不重要。</p><p><img src="/images/ipsec-configurations-part9/01-topology.png" alt="Network topology"></p><h2 id="阅读基本-RouterOS-命令"><a href="#阅读基本-RouterOS-命令" class="headerlink" title="阅读基本 RouterOS 命令"></a>阅读基本 RouterOS 命令</h2><p>在本文中我主要使用 RouterOS 命令来表示具体的配置，但是实际情况下调试 WebUI 会更方便。这里提供一张简图解释怎么阅读 RouterOS 的命令：<br><img src="/images/ipsec-configurations-part9/02-how-to-read-routeros-command.jpg" alt="Command explanation"></p><a id="more"></a><h2 id="证书生成"><a href="#证书生成" class="headerlink" title="证书生成"></a>证书生成</h2><p>我这里只贴 certtool 的 template 文件，具体的生成指令请参考 <a href="/2020/10/ipsec-configurations-part2/">Part2</a>。注意 RouterOS 似乎还不支持 Ed25519 证书，所以需要使用 ECDSA 或者是 RSA 证书。</p><figure class="highlight bash"><figcaption><span>server.tmpl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cn = <span class="string">"随意填, 我们使用 DNS SAN 作为 ID"</span></span><br><span class="line">dns_name = <span class="string">"server.dns.name"</span></span><br><span class="line">activation_date = <span class="string">"2020-12-01 00:00:00 UTC+0"</span></span><br><span class="line">expiration_date = <span class="string">"2022-01-01 00:00:00 UTC+0"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>routeros.tmpl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cn = <span class="string">"同样随意填"</span></span><br><span class="line">dns_name = <span class="string">"routeros.server.dns.name"</span></span><br><span class="line">activation_date = <span class="string">"2020-12-01 00:00:00 UTC+0"</span></span><br><span class="line">expiration_date = <span class="string">"2022-01-01 00:00:00 UTC+0"</span></span><br></pre></td></tr></table></figure><h2 id="strongSwan-配置"><a href="#strongSwan-配置" class="headerlink" title="strongSwan 配置"></a>strongSwan 配置</h2><p>由于这是一个 Site-to-Site 连接，所以不需要 Virtual IP 了。配置基于 Part2 中的<code>hosta.conf</code>，同样也是有变化的地方做了注释</p><figure class="highlight bash"><figcaption><span>server.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">connections &#123;</span><br><span class="line">    <span class="comment"># 修改连接名不影响功能</span></span><br><span class="line">    conn_routeros &#123;</span><br><span class="line">        version = 2</span><br><span class="line">        <span class="comment"># 使用实际的服务器地址</span></span><br><span class="line">        local_addrs = 22.22.22.22</span><br><span class="line">        <span class="comment"># 不指定 RouterOS 的地址，因为家宽地址不固定</span></span><br><span class="line">        remote_addrs = %any</span><br><span class="line">        <span class="comment"># RouterOS 在一阶段握手时不支持 GCM Mode</span></span><br><span class="line">        proposals = aes256-sha256-ecp256</span><br><span class="line">        <span class="built_in">local</span> &#123;</span><br><span class="line">            <span class="comment"># 使用证书中的 SAN</span></span><br><span class="line">            id = server.dns.name</span><br><span class="line">            auth = pubkey</span><br><span class="line">        &#125;</span><br><span class="line">        remote &#123;</span><br><span class="line">            <span class="comment"># 使用证书中的 SAN</span></span><br><span class="line">            id = routeros.server.dns.name</span><br><span class="line">            auth = pubkey</span><br><span class="line">            <span class="comment"># (可选) 指定 CA 证书的 DN，以确保对方出示的证书是我们签发的</span></span><br><span class="line">            ca_id = CN=CA_COMMON_NAME</span><br><span class="line">        &#125;</span><br><span class="line">        children &#123;</span><br><span class="line">            child_sa &#123;</span><br><span class="line">                <span class="comment"># 接受任意目的地流量</span></span><br><span class="line">                local_ts = 0.0.0.0/0</span><br><span class="line">                <span class="comment"># 客户端 IP 段，需要与 RouterOS DHCP 设定一致</span></span><br><span class="line">                remote_ts = 192.168.50.0/24</span><br><span class="line">                mode = tunnel</span><br><span class="line">                <span class="comment"># RouterOS 支持 GCM 作为实际数据的加密方式</span></span><br><span class="line">                esp_proposals = aes256gcm128-sha256-ecp256</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RouterOS-DHCP-设置"><a href="#RouterOS-DHCP-设置" class="headerlink" title="RouterOS DHCP 设置"></a>RouterOS DHCP 设置</h2><p>这里假设读者已经会在 RouterOS 中设置 VLAN。所以只是简单的把我的 LAN 配置列出来，方便读者调试。假设使用 <code>ether8</code>，bridge 名称为 <code>LAN</code>，使用 <code>VLAN=50</code>，子网 IP 段是 <code>192.168.50.100-192.168.50.200</code>。也可以参考我以前写的一篇《<a href="/2020/07/mikrotik-rb4011-setup-memo/">访客网络配置备忘</a>》。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 ether8 加入网桥</span></span><br><span class="line">/interface bridge port add bridge=LAN interface=ether8 pvid=50 ingress-filtering=yes frame-types=admit-only-untagged-and-priority-tagged</span><br><span class="line"><span class="comment"># 在网桥上新建一个 VLAN 接口</span></span><br><span class="line">/interface vlan add vlan-id=50 interface=LAN name=LAN.ipsec_test</span><br><span class="line"><span class="comment"># 编辑网桥的 VLAN 表</span></span><br><span class="line">/interface bridge vlan add bridge=LAN vlan-ids=50 tagged=LAN untagged=ether8 comment=VLAN_ipsec_test</span><br><span class="line"><span class="comment"># 分配网关 IP</span></span><br><span class="line">/ip address add address=192.168.50.1/24 interface=LAN.ipsec_test </span><br><span class="line"><span class="comment"># 添加 DHCP IP 池</span></span><br><span class="line">/ip pool add name=dhcp_ipsec_test ranges=192.168.50.100-192.168.50.200</span><br><span class="line"><span class="comment"># 设置 DHCP 服务器</span></span><br><span class="line">/ip dhcp-server network add address=192.168.50.0/24 gateway=192.168.50.1</span><br><span class="line">/ip dhcp-server add name=dhcp_ipsec_test interface=LAN.ipsec_test address-pool=dhcp_ipsec_test</span><br></pre></td></tr></table></figure><p>注意我们没有设置任何 NAT 规则，现在将一台电脑连接到<code>ether8</code>上，应该能自动获取到 IP 但是上不了网。如果能上网说明你的 NAT 规则设置得太宽了，你在之后需要参考 <a href="https://wiki.mikrotik.com/wiki/Manual:IP/IPsec#NAT_and_Fasttrack_Bypass" target="_blank" rel="noopener">NAT and Fasttrack bypass</a> 设置额外的规则。</p><h2 id="RouterOS-IPsec-术语对照表"><a href="#RouterOS-IPsec-术语对照表" class="headerlink" title="RouterOS IPsec 术语对照表"></a>RouterOS IPsec 术语对照表</h2><p>RouterOS 使用了自己的一套术语来描述 IPsec 相关的配置，我尝试了一下把 RouterOS 中的术语和 strongSwan 的配置文件内容一一对应起来：</p><table><thead><tr><th>RouterOS</th><th>strongSwan</th><th>Note</th></tr></thead><tbody><tr><td>Peer</td><td><code>{local,remote}_addrs</code></td><td></td></tr><tr><td>Profile</td><td>IKE_SA parameters</td><td>No AES GCM</td></tr><tr><td>Identities</td><td><code>local/remote</code> 身份认证块</td><td></td></tr><tr><td>Policy</td><td><code>{local,remote}_ts</code></td><td>分为普通的 policy 和 policy template</td></tr><tr><td>Proposal</td><td>CHILD_SA parameters</td><td>支持 AES GCM</td></tr><tr><td>ModeConfig</td><td>Address Pool, DNS, etc.</td><td>暂时用不到。</td></tr><tr><td>Group</td><td></td><td>似乎用来把多个 policy template 合成一组，暂时不清楚是做什么用的。</td></tr><tr><td>Active Peer</td><td>已建立的 IKE_SA</td><td></td></tr><tr><td>Installed SA</td><td>已建立的 CHILD_SA</td><td></td></tr><tr><td>Key</td><td></td><td>暂时不清楚是做什么用的</td></tr></tbody></table><h2 id="导入证书"><a href="#导入证书" class="headerlink" title="导入证书"></a>导入证书</h2><p>需要导入三个文件，先 scp 进 RouterOS 再<code>/certificate import file-name=xxx.pem</code>即可，WebUI也行。导入后确认 CA 证书显示为<code>T</code>，客户端证书显示为<code>KT</code>。</p><ul><li>客户端私钥</li><li>客户端证书</li><li>CA 证书</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[admin@RouterOS] &gt; &#x2F;certificate print            </span><br><span class="line">Flags: K - private-key, L - crl, C - smart-card-key, A - authority, I - issued, R - revoked, E - expired, T - trusted </span><br><span class="line"> #         NAME           COMMON-NAME           SUBJECT-ALT-NAME</span><br><span class="line"> 0 K     T routeros.pem_0 routeros              DNS:routeros.server.dns.name</span><br><span class="line"> 1       T ca-cert.pem_0  ca</span><br></pre></td></tr></table></figure><h2 id="IPsec-设定"><a href="#IPsec-设定" class="headerlink" title="IPsec 设定"></a>IPsec 设定</h2><p>先设置 Profile，Proposal，Peer，Identities</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定 IKE_SA 的 ciphersuite</span></span><br><span class="line">/ip ipsec profile add name=secure_ikesa <span class="built_in">hash</span>-algorithm=sha256 enc-algorithm=aes-256 dh-group=ecp256 proposal-check=strict </span><br><span class="line"><span class="comment"># 指定 CHILD_SA 的 ciphersuite</span></span><br><span class="line">/ip ipsec proposal add name=secure_childsa auth-algorithms=sha256 enc-algorithms=aes-256-gcm pfs-group=ecp256 </span><br><span class="line"><span class="comment"># 指定服务器地址和要使用的 Profile</span></span><br><span class="line">/ip ipsec peer add name=routeros_ipsec address=22.22.22.22 profile=secure_ikesa exchange-mode=ike2</span><br><span class="line"><span class="comment"># 配置身份验证，certificate 使用导入的客户端证书</span></span><br><span class="line"><span class="comment"># my-id 和 remote-id 使用 FQDN(i.e. DNS SAN) 并和证书中的值保持一致</span></span><br><span class="line">/ip ipsec identity add \</span><br><span class="line">    peer=routeros_ipsec \</span><br><span class="line">    auth-method=digital-signature \</span><br><span class="line">    certificate=routeros.pem_0 \</span><br><span class="line">    my-id=fqdn:routeros.server.dns.name \</span><br><span class="line">    remote-id=fqdn:server.dns.name</span><br></pre></td></tr></table></figure><p>这样设定完以后应该在 Active Peers 里看到这个 Peer 处于<code>established</code>状态了。然后再设置 Policy:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的 &#123;src,dst&#125;-address 类似 &#123;local,remote&#125;_ts</span></span><br><span class="line">/ip ipsec policy add peer=routeros_ipsec \</span><br><span class="line">    tunnel=yes \</span><br><span class="line">    src-address=192.168.50.0/24 \</span><br><span class="line">    dst-address=0.0.0.0/0 \</span><br><span class="line">    action=encrypt \</span><br><span class="line">    level=require \</span><br><span class="line">    proposal=secure_childsa</span><br></pre></td></tr></table></figure><p>取决于你的防火墙配置，你可能需要显式放行所有将被 IPsec 加密的 forward 流量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;ip firewall filter add chain&#x3D;forward ipsec-policy&#x3D;out,ipsec action&#x3D;accept</span><br></pre></td></tr></table></figure><p>最后在服务器上设置 masquerade 规则，应该就能上网了。你应当检查你的外部 IP 是不是确实变成了你的服务器的 IP。</p><h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><ul><li><a href="https://wiki.mikrotik.com/wiki/Manual:IP/IPsec" target="_blank" rel="noopener">MikroTik 的官方文档</a> 提供了更多配置例子和各种参数的详细解释。</li><li><a href="https://wiki.mikrotik.com/wiki/Manual:Packet_Flow" target="_blank" rel="noopener">Packet Flow</a> 页面展示了 RouterOS 的详细数据包处理流程。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇来填一个在 Part1 的时候挖的坑，简单介绍一下怎么在 RouterOS 和 strongSwan 之间配置一个 Site-to-Site 的 IKEv2 VPN。如果你还没有动手实际配置过 strongSwan，我强烈建议你先读完至少 Part1~5 和 Part7，并且自己动手配置一个能用的 strongSwan 服务端。这样至少能保证你会配置 strongSwan，否则同时学习 RouterOS 和 strongSwan 两种配置方法会让人云里雾里。&lt;/p&gt;
&lt;h2 id=&quot;网络结构&quot;&gt;&lt;a href=&quot;#网络结构&quot; class=&quot;headerlink&quot; title=&quot;网络结构&quot;&gt;&lt;/a&gt;网络结构&lt;/h2&gt;&lt;p&gt;RouterOS 做路由器，用 DHCP 给内网设备分配&lt;code&gt;192.168.50.0/24&lt;/code&gt;段中的 IP 地址。并且用 IPsec 的 Tunnel 模式将所有来自此 IP 段的数据转发至服务器&lt;code&gt;22.22.22.22&lt;/code&gt;。路由器本身的 IP 并不重要。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/ipsec-configurations-part9/01-topology.png&quot; alt=&quot;Network topology&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;阅读基本-RouterOS-命令&quot;&gt;&lt;a href=&quot;#阅读基本-RouterOS-命令&quot; class=&quot;headerlink&quot; title=&quot;阅读基本 RouterOS 命令&quot;&gt;&lt;/a&gt;阅读基本 RouterOS 命令&lt;/h2&gt;&lt;p&gt;在本文中我主要使用 RouterOS 命令来表示具体的配置，但是实际情况下调试 WebUI 会更方便。这里提供一张简图解释怎么阅读 RouterOS 的命令：&lt;br&gt;&lt;img src=&quot;/images/ipsec-configurations-part9/02-how-to-read-routeros-command.jpg&quot; alt=&quot;Command explanation&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Networking" scheme="https://recursiveg.me/tags/Networking/"/>
    
      <category term="折腾" scheme="https://recursiveg.me/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="IPsec" scheme="https://recursiveg.me/tags/IPsec/"/>
    
      <category term="VPN" scheme="https://recursiveg.me/tags/VPN/"/>
    
      <category term="RouterOS" scheme="https://recursiveg.me/tags/RouterOS/"/>
    
  </entry>
  
  <entry>
    <title>Flexget+systemd.timer 配置</title>
    <link href="https://recursiveg.me/2021/01/flexget-user-systemd-timer/"/>
    <id>https://recursiveg.me/2021/01/flexget-user-systemd-timer/</id>
    <published>2021-01-16T16:45:00.000Z</published>
    <updated>2021-01-19T04:25:10.842Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直都是手动检查每周新番并添加到 Transmission 中的，最近尝试把这一流程自动化一下。简单搜索了一下发现了 <a href="https://flexget.com" target="_blank" rel="noopener">FlexGet</a> 这个工具。支持 Transmission 也能在 Linux 下运行，就决定是它了。</p><h2 id="安装到用户目录"><a href="#安装到用户目录" class="headerlink" title="安装到用户目录"></a>安装到用户目录</h2><p>ArchLinux 源里并没有这个包，又考虑到这是个 Python 程序，所以就决定直接用<code>venv</code>了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.config/flexget</span><br><span class="line"><span class="built_in">cd</span> ~/.config/flexget</span><br><span class="line">python -m venv virtualenv</span><br><span class="line"><span class="built_in">source</span> virtualenv/bin/activate</span><br><span class="line">pip install flexget</span><br><span class="line">pip install transmission-rpc</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>配置方法可以看教程也可以看<a href="https://flexget.com/Configuration" target="_blank" rel="noopener">官方文档</a>。我就只简单贴一下。</p><figure class="highlight yaml"><figcaption><span>~/.config/flexget/config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">templates:</span></span><br><span class="line">  <span class="attr">transmission:</span></span><br><span class="line">    <span class="attr">transmission:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">'https://domain-name.com/transmission/rpc'</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">'your-username'</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">'your-password'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line">  <span class="string">这里随便写:</span></span><br><span class="line">    <span class="attr">rss:</span> <span class="string">'https://mikanani.me/RSS/...'</span></span><br><span class="line">    <span class="attr">accept_all:</span> <span class="literal">yes</span></span><br><span class="line">    <span class="attr">template:</span> <span class="string">transmission</span></span><br><span class="line">    <span class="attr">transmission:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">'/folder/path/on/server'</span></span><br></pre></td></tr></table></figure><h2 id="Systemd-配置"><a href="#Systemd-配置" class="headerlink" title="Systemd 配置"></a>Systemd 配置</h2><figure class="highlight toml"><figcaption><span>~/.config/systemd/user/flexget.service</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Refresh RSS with flexget</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=<span class="literal">on</span>eshot</span><br><span class="line"><span class="attr">ExecStart</span>=/home/recursiveg/.config/flexget/virtualenv/bin/flexget execute</span><br></pre></td></tr></table></figure><p>用户登录后 5 分钟进行同步，然后每两小时检查一次。</p><figure class="highlight toml"><figcaption><span>~/.config/systemd/user/flexget.timer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Run flexget <span class="literal">on</span> login then every <span class="number">2</span>hrs</span><br><span class="line"></span><br><span class="line"><span class="section">[Timer]</span></span><br><span class="line"><span class="attr">OnStartupSec</span>=<span class="number">5</span>min</span><br><span class="line"><span class="attr">OnUnitActiveSec</span>=<span class="number">2</span>h</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=timers.target</span><br></pre></td></tr></table></figure><p>一些可能会用到的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用并运行定时器</span></span><br><span class="line">systemctl --user <span class="built_in">enable</span> --now flexget.timer</span><br><span class="line"><span class="comment"># 立即检查</span></span><br><span class="line">systemctl --user start flexget.service</span><br><span class="line"><span class="comment"># 检查定时器情况</span></span><br><span class="line">systemctl --user list-timers</span><br><span class="line"><span class="comment"># 检查日志</span></span><br><span class="line">journalctl --user-unit flexget.service -f</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前一直都是手动检查每周新番并添加到 Transmission 中的，最近尝试把这一流程自动化一下。简单搜索了一下发现了 &lt;a href=&quot;https://flexget.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FlexGet&lt;/a&gt; 这个工
      
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="技术宅" scheme="https://recursiveg.me/tags/%E6%8A%80%E6%9C%AF%E5%AE%85/"/>
    
      <category term="脚本" scheme="https://recursiveg.me/tags/%E8%84%9A%E6%9C%AC/"/>
    
      <category term="新番" scheme="https://recursiveg.me/tags/%E6%96%B0%E7%95%AA/"/>
    
  </entry>
  
  <entry>
    <title>在 GNS3 中使用 ArchLinux</title>
    <link href="https://recursiveg.me/2020/12/use-archlinux-in-gns3/"/>
    <id>https://recursiveg.me/2020/12/use-archlinux-in-gns3/</id>
    <published>2020-12-19T14:47:39.000Z</published>
    <updated>2020-12-20T06:39:48.898Z</updated>
    
    <content type="html"><![CDATA[<p>之前在折腾 strongSwan 配置的时候需要多台电脑互相连接做测试，用实机各种不方便。比方说，我不想暴露真实 IP，就只能在发布前手工编辑配置文件，也不知道编辑过后的文件到底能不能工作。于是尝试折腾使用 <a href="https://www.gns3.com" target="_blank" rel="noopener">GNS3</a> 来搭建一个虚拟的网络环境。</p><h2 id="安装-GNS3"><a href="#安装-GNS3" class="headerlink" title="安装 GNS3"></a>安装 GNS3</h2><p>你可以尝试从 AUR 安装 GNS3，但是我之前试了几次都不是太成功，于是还是把 GNS3 装进了 virtualenv 里：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建并进入 virtualenv</span></span><br><span class="line">virtualenv -p python3.9 virtualenv</span><br><span class="line"><span class="built_in">source</span> virtualenv/bin/activate</span><br><span class="line"><span class="comment"># 安装 GNS3 及 PyQt5</span></span><br><span class="line">pip install gns3-server gns3-gui pyqt5</span><br><span class="line"><span class="comment"># 安装一些其他的依赖（可能有漏的，请根据 gns3 的出错消息自己安装）</span></span><br><span class="line">yay -S vpcs dynamips</span><br><span class="line"><span class="comment"># 启动 GNS3</span></span><br><span class="line">gns3</span><br></pre></td></tr></table></figure><p>GNS3 支持好几种方式来运行虚拟网络中的“节点”，我这里使用 Docker 来运行虚拟的 Archlinux 系统。因此也需要先安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S docker</span><br><span class="line">sudo usermod -aG docker &#96;whoami&#96;</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><p>同时建议安装 Wireshark 方便抓包调试。</p><h2 id="连接因特网"><a href="#连接因特网" class="headerlink" title="连接因特网"></a>连接因特网</h2><p>进入 GNS3 创建 Project 以后就可以尝试把左侧列表里的设备往中间画布上拖了。但是你会发现不仅设备类型少的可怜而且也基本拖不上去。这时我们需要自己创建设备节点的模板。进 Preferences，在最下面的 Docker containers 里点 New，Image name 输<code>archlinux:base-devel</code>，其他的都默认，Adapters 可以按自己需要指定数量。<br><img src="/images/use-archlinux-in-gns3/01-new-image.png" alt=""><br>点 OK 后，左侧的设备列表里就多了一个设备。拖到画布上，右键 Start，再右键 Console 就可以看到 ArchLinux 的命令行界面了。</p><p>GNS3 默认使用 xterm 作为终端模拟器，如果你像我一样使用 Gnome Terminal，需要先去 General - Console applications 把启动终端的命令改成</p><pre><code>gnome-terminal -t &quot;%d&quot; -- telnet &quot;%h&quot; &quot;%p&quot;</code></pre><p><img src="/images/use-archlinux-in-gns3/02-terminal-cmd.png" alt=""></p><p>这个新创建的 Archlinux 节点还是空空如也的，除了基本的系统什么也没有，我们可以把它连接到实际的网络上，这样就能用 pacman 安装软件包了。先从设备列表里拖一个“Cloud”设备出来，然后点左侧边栏最下面的“Add a link”切换到连线模式，点 Cloud 节点，选择物理机上用于联网的接口，再点 Archlinux 节点，选择要连接的端口，这样一条连线就接好了。Archlinux 节点被直接桥接到了外部接口上，和宿主机位于同一网段。<br><img src="/images/use-archlinux-in-gns3/03-link-connected.png" alt=""></p><p>由于 Archlinux 的镜像不带 dhcpcd 无法自动获取 IP，只能手动设置一下咯：</p><pre><code>ip link set eth0 upip addr add 192.168.1.222/24 dev eth0ip route add default via 192.168.1.1 dev eth0echo nameserver 1.1.1.1 &gt; /etc/resolv.conf</code></pre><p>不过实际测试以后发现这个速度实在是很残念，可能还是要写 Dockerfile 把镜像配置好再用才行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在折腾 strongSwan 配置的时候需要多台电脑互相连接做测试，用实机各种不方便。比方说，我不想暴露真实 IP，就只能在发布前手工编辑配置文件，也不知道编辑过后的文件到底能不能工作。于是尝试折腾使用 &lt;a href=&quot;https://www.gns3.com&quot; ta
      
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Networking" scheme="https://recursiveg.me/tags/Networking/"/>
    
      <category term="折腾" scheme="https://recursiveg.me/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="GNS3" scheme="https://recursiveg.me/tags/GNS3/"/>
    
      <category term="Archlinux" scheme="https://recursiveg.me/tags/Archlinux/"/>
    
  </entry>
  
  <entry>
    <title>IPsec 配置备忘 Part8 - iOS 客户端</title>
    <link href="https://recursiveg.me/2020/11/ipsec-configurations-part8/"/>
    <id>https://recursiveg.me/2020/11/ipsec-configurations-part8/</id>
    <published>2020-11-17T12:50:00.000Z</published>
    <updated>2020-12-05T22:17:13.395Z</updated>
    
    <content type="html"><![CDATA[<div style="background-color:#fff0f0; padding: 0 1em 1em"><center><b><p style="color:red; font-size:2em">⚠ 天坑预警 ⚠</p></b></center>我在 iOS 12/13/14 各一台设备上测试过，但是测试的时候不是次次都能工作。由于 iOS 的坑实在太多，以及不同版本的 iOS 的行为都不太一样，如果你碰到了我没碰到的坑我只能祝你好运 （<ゝω・）☆</div><p>接 Part6。折腾完 Android 以后我们来折腾一下 iOS。基本原理都是一样的，只是需要把苹果那一套 Vendor-specific 的配置选项翻译成 strongSwan 的，这样才能和服务器上的 strongSwan 互相通信嘛。由于 iOS 上的 IKEv2 客户端不是 strongSwan 而是苹果自己魔改的不知道什么版本，所以坑比起 Android 客户端更多。幸好 strongSwan 项目已经帮我们都踩了不少坑了：见 <a href="https://wiki.strongswan.org/projects/strongswan/wiki/AppleClients" target="_blank" rel="noopener">iOS (Apple iPhone, iPad...) and macOS</a> 和 <a href="https://wiki.strongswan.org/projects/strongswan/wiki/AppleIKEv2Profile" target="_blank" rel="noopener">IKEv2 Configuration Profile for Apple iOS 8 and newer</a>。</p><h2 id="坑坑坑"><a href="#坑坑坑" class="headerlink" title="坑坑坑"></a>坑坑坑</h2><p>由于本 Part 是基于 Part6 的，所以我们先来列举一下会需要我们做调整的 iOS 的坑（大部分在 strongSwan 的文档里已经提到过了）：</p><ol><li>iOS 的 local_id 和 remote_id 全部都是 FQDN 类型，意味着我们需要按照 Part7 的说明给证书加上<code>dns_name</code>的 SAN。</li><li>iOS 不允许 p12 证书使用空密码。</li><li>iOS 12 还不支持 ed25519，所以我们需要改用其他算法。</li><li>iOS 的 mobileconfig 全是坑。</li><li>iOS 需要在配置描述文件显式指定 CA 的 CN 才会发送 CERTREQ。</li><li>你需要在服务端配置文件的 pool 里指定一个 DNS，否则 iOS 连上后无法上网。</li></ol><p>基本流程是：生成密钥和证书；生成 iOS 的<code>mobileconfig</code>配置描述文件；想办法把这个文件安装到 iOS 设备上；最后尝试连接。由于 iOS 的配置文件比 Android 的复杂许多，所以我写了个 Python 脚本来负责生成，如果你用 macOS 也可以从苹果下载官方的配置工具。</p><a id="more"></a><h2 id="IKEv2-配置描述文件生成工具"><a href="#IKEv2-配置描述文件生成工具" class="headerlink" title="IKEv2 配置描述文件生成工具"></a>IKEv2 配置描述文件生成工具</h2><p>生成的配置文件原始模板来自 <a href="https://wiki.strongswan.org/projects/strongswan/wiki/AppleIKEv2Profile" target="_blank" rel="noopener">strongSwan 的文档</a>，原文有很详细的注释，建议过一遍。另外 <a href="https://developer.apple.com/business/documentation/Configuration-Profile-Reference.pdf" target="_blank" rel="noopener">Apple 的开发者手册</a>以及<a href="https://developer.apple.com/documentation/networkextension/nevpnprotocolikev2" target="_blank" rel="noopener">开发者网站</a>也可参考。你可以在 Apple 的网站上查到每个算法都是在哪个 iOS 版本里支持的。</p><p>另外我在脚本里有两个硬编码的地方，一个是 ciphersuite 写死了是<code>aes256gcm128-sha256-ecp256</code>。另一个是证书类型写死了<code>ECDSA256</code>（certtool 在使用 ECDSA 生成私钥的时候的默认值）。如果你需要设置为其他值，需要直接改脚本代码。</p><figure class="highlight python"><figcaption><span>ios-config-gen.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> plistlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> absl <span class="keyword">import</span> app</span><br><span class="line"><span class="keyword">from</span> absl <span class="keyword">import</span> flags</span><br><span class="line"></span><br><span class="line">FLAGS = flags.FLAGS</span><br><span class="line"></span><br><span class="line"><span class="comment">#--- Reversed DNS notation, iOS requires these.</span></span><br><span class="line">flags.DEFINE_string(<span class="string">"profile_rdns"</span>, <span class="literal">None</span>, <span class="string">"Not displayed, but can be used to replace old profile."</span>)</span><br><span class="line">flags.DEFINE_string(<span class="string">"vpn_rdns"</span>, <span class="literal">None</span>, <span class="string">"Not displayed. Can be arbitrary string."</span>)</span><br><span class="line">flags.DEFINE_string(<span class="string">"client_cert_rdns"</span>, <span class="literal">None</span>, <span class="string">"Not displayed. Can be arbitrary string."</span>)</span><br><span class="line">flags.DEFINE_string(<span class="string">"ca_cert_rdns"</span>, <span class="literal">None</span>, <span class="string">"Not displayed. Can be arbitrary string."</span>)</span><br><span class="line"><span class="comment">#--- Strings to be displayed. Can be anything.</span></span><br><span class="line">flags.DEFINE_string(<span class="string">"profile_display_name"</span>, <span class="literal">None</span>, <span class="string">"Arbitrary descriptive name."</span>)</span><br><span class="line">flags.DEFINE_string(<span class="string">"vpn_display_name"</span>, <span class="literal">None</span>, <span class="string">"Arbitrary descriptive name."</span>)</span><br><span class="line">flags.DEFINE_string(<span class="string">"client_cert_display_name"</span>, <span class="literal">None</span>, <span class="string">"Arbitrary descriptive name."</span>) </span><br><span class="line">flags.DEFINE_string(<span class="string">"client_cert_file_name"</span>, <span class="literal">None</span>, <span class="string">"Arbitrary descriptive name."</span>) </span><br><span class="line">flags.DEFINE_string(<span class="string">"ca_cert_display_name"</span>, <span class="literal">None</span>, <span class="string">"Arbitrary descriptive name."</span>)</span><br><span class="line">flags.DEFINE_string(<span class="string">"vpn_profile_name"</span>, <span class="literal">None</span>, <span class="string">"Arbitrary descriptive name."</span>)</span><br><span class="line"><span class="comment">#--- Server config</span></span><br><span class="line">flags.DEFINE_string(<span class="string">"server_addr"</span>, <span class="literal">None</span>, <span class="string">"Domain name of the server."</span>)</span><br><span class="line">flags.DEFINE_string(<span class="string">"server_id"</span>, <span class="literal">None</span>, <span class="string">"Remote id. iOS always send this as FQDN type."</span>)</span><br><span class="line"><span class="comment">#--- Client config</span></span><br><span class="line">flags.DEFINE_string(<span class="string">"client_cert_p12_file"</span>, <span class="literal">None</span>, <span class="string">"Client cert p12 file."</span>)</span><br><span class="line">flags.DEFINE_string(<span class="string">"client_cert_p12_pwd"</span>, <span class="literal">None</span>, <span class="string">"Password for client p12 cert."</span>)</span><br><span class="line">flags.DEFINE_string(<span class="string">"client_id"</span>, <span class="literal">None</span>, <span class="string">"Client's ID to be sent to the server. iOS always send this as FQDN type."</span>)</span><br><span class="line"><span class="comment">#--- CA config</span></span><br><span class="line">flags.DEFINE_string(<span class="string">"ca_cert_pem_file"</span>, <span class="literal">None</span>, <span class="string">"CA cert file, not p12 format."</span>)</span><br><span class="line">flags.DEFINE_string(<span class="string">"ca_common_name"</span>, <span class="literal">None</span>, <span class="string">"CA's Common name. iOS will send a CERTREQ iff this value MATCHES the CA's common name"</span>)</span><br><span class="line"><span class="comment">#--- iOS on-demand settings</span></span><br><span class="line">flags.DEFINE_bool(<span class="string">"always_on_wifi"</span>, <span class="literal">False</span>, <span class="string">"Setup on-demand rules to always connect on WiFi"</span>)</span><br><span class="line"><span class="comment">#--- Everything is required except client_cert_p12_pwd</span></span><br><span class="line">flags.mark_flag_as_required(<span class="string">"profile_rdns"</span>)</span><br><span class="line">flags.mark_flag_as_required(<span class="string">"vpn_rdns"</span>)</span><br><span class="line">flags.mark_flag_as_required(<span class="string">"client_cert_rdns"</span>)</span><br><span class="line">flags.mark_flag_as_required(<span class="string">"ca_cert_rdns"</span>)</span><br><span class="line"></span><br><span class="line">flags.mark_flag_as_required(<span class="string">"profile_display_name"</span>)</span><br><span class="line">flags.mark_flag_as_required(<span class="string">"vpn_display_name"</span>)</span><br><span class="line">flags.mark_flag_as_required(<span class="string">"client_cert_display_name"</span>)</span><br><span class="line">flags.mark_flag_as_required(<span class="string">"client_cert_file_name"</span>)</span><br><span class="line">flags.mark_flag_as_required(<span class="string">"ca_cert_display_name"</span>)</span><br><span class="line">flags.mark_flag_as_required(<span class="string">"vpn_profile_name"</span>)</span><br><span class="line"></span><br><span class="line">flags.mark_flag_as_required(<span class="string">"server_addr"</span>)</span><br><span class="line">flags.mark_flag_as_required(<span class="string">"server_id"</span>)</span><br><span class="line"></span><br><span class="line">flags.mark_flag_as_required(<span class="string">"client_cert_p12_file"</span>)</span><br><span class="line">flags.mark_flag_as_required(<span class="string">"client_id"</span>)</span><br><span class="line"></span><br><span class="line">flags.mark_flag_as_required(<span class="string">"ca_cert_pem_file"</span>)</span><br><span class="line">flags.mark_flag_as_required(<span class="string">"ca_common_name"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_pem_file</span><span class="params">(fname:str)</span>-&gt;bytes:</span></span><br><span class="line">    <span class="keyword">with</span> open(fname, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = [l.strip() <span class="keyword">for</span> l <span class="keyword">in</span> f.read().split(<span class="string">"\n"</span>)]</span><br><span class="line">    lines = filter(<span class="keyword">lambda</span> l:len(l) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="string">'-----'</span> <span class="keyword">not</span> <span class="keyword">in</span> l, lines)</span><br><span class="line">    <span class="keyword">return</span> base64.b64decode(<span class="string">''</span>.join(lines))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_cert_payload</span><span class="params">()</span>:</span></span><br><span class="line">    ret = dict()</span><br><span class="line">    ret[<span class="string">"PayloadIdentifier"</span>] = FLAGS.client_cert_rdns</span><br><span class="line">    ret[<span class="string">"PayloadDisplayName"</span>] = FLAGS.client_cert_display_name</span><br><span class="line">    ret[<span class="string">"PayloadCertificateFileName"</span>] = FLAGS.client_cert_file_name</span><br><span class="line">    ret[<span class="string">"PayloadUUID"</span>] = str(uuid.uuid4())</span><br><span class="line">    ret[<span class="string">"PayloadType"</span>] = <span class="string">"com.apple.security.pkcs12"</span></span><br><span class="line">    ret[<span class="string">"PayloadVersion"</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> FLAGS.client_cert_p12_pwd <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        ret[<span class="string">"Password"</span>] = FLAGS.client_cert_p12_pwd</span><br><span class="line">    ret[<span class="string">"PayloadContent"</span>] = load_pem_file(FLAGS.client_cert_p12_file)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ca_cert_payload</span><span class="params">()</span>:</span></span><br><span class="line">    ret = dict()</span><br><span class="line">    ret[<span class="string">"PayloadIdentifier"</span>] = FLAGS.ca_cert_rdns</span><br><span class="line">    ret[<span class="string">"PayloadDisplayName"</span>] = FLAGS.ca_cert_display_name</span><br><span class="line">    ret[<span class="string">"PayloadUUID"</span>] = str(uuid.uuid4())</span><br><span class="line">    ret[<span class="string">"PayloadType"</span>] = <span class="string">"com.apple.security.root"</span></span><br><span class="line">    ret[<span class="string">"PayloadVersion"</span>] = <span class="number">1</span></span><br><span class="line">    ret[<span class="string">"PayloadContent"</span>] = load_pem_file(FLAGS.ca_cert_pem_file)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">security_parameter_payload</span><span class="params">()</span>:</span></span><br><span class="line">    ret = dict()</span><br><span class="line">    <span class="comment"># Please check Apple's doc for the iOS version supporting these options</span></span><br><span class="line">    <span class="comment"># https://developer.apple.com/documentation/networkextension/nevpnikev2encryptionalgorithm</span></span><br><span class="line">    ret[<span class="string">"EncryptionAlgorithm"</span>] = <span class="string">"AES-256-GCM"</span></span><br><span class="line">    ret[<span class="string">"IntegrityAlgorithm"</span>] = <span class="string">"SHA2-256"</span></span><br><span class="line">    ret[<span class="string">"DiffieHellmanGroup"</span>] = <span class="number">19</span> <span class="comment"># ecp256</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ikev2_payload</span><span class="params">(client_cert_uuid:str)</span>:</span></span><br><span class="line">    ret = dict()</span><br><span class="line">    ret[<span class="string">"RemoteAddress"</span>] = FLAGS.server_addr</span><br><span class="line">    <span class="comment"># iOS have bug with DN?</span></span><br><span class="line">    <span class="comment"># use server address as suggested</span></span><br><span class="line">    ret[<span class="string">"RemoteIdentifier"</span>] = FLAGS.server_id</span><br><span class="line">    ret[<span class="string">"LocalIdentifier"</span>] = FLAGS.client_id</span><br><span class="line">    <span class="keyword">if</span> FLAGS.ca_common_name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        ret[<span class="string">"ServerCertificateIssuerCommonName"</span>] = FLAGS.ca_common_name</span><br><span class="line">    ret[<span class="string">"AuthenticationMethod"</span>] = <span class="string">"Certificate"</span></span><br><span class="line">    ret[<span class="string">"PayloadCertificateUUID"</span>] = client_cert_uuid</span><br><span class="line">    ret[<span class="string">"CertificateType"</span>] = <span class="string">"ECDSA256"</span></span><br><span class="line">    ret[<span class="string">"IKESecurityAssociationParameters"</span>] = security_parameter_payload()</span><br><span class="line">    ret[<span class="string">"ChildSecurityAssociationParameters"</span>] = security_parameter_payload()</span><br><span class="line">    <span class="keyword">if</span> FLAGS.always_on_wifi:</span><br><span class="line">        <span class="comment"># https://developer.apple.com/documentation/networkextension/personal_vpn/vpn_on_demand_rules</span></span><br><span class="line">        ret[<span class="string">"OnDemandEnabled"</span>] = <span class="number">1</span></span><br><span class="line">        ret[<span class="string">"OnDemandRules"</span>] = [</span><br><span class="line">            dict(InterfaceTypeMatch=<span class="string">"WiFi"</span>, Action=<span class="string">"Connect"</span>),</span><br><span class="line">            dict(Action=<span class="string">"Ignore"</span>)</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vpn_payload</span><span class="params">(client_cert_uuid:str)</span>:</span></span><br><span class="line">    ret = dict()</span><br><span class="line">    ret[<span class="string">"PayloadIdentifier"</span>] = FLAGS.vpn_rdns</span><br><span class="line">    ret[<span class="string">"PayloadDisplayName"</span>] = FLAGS.vpn_display_name</span><br><span class="line">    ret[<span class="string">"PayloadUUID"</span>] = str(uuid.uuid4())</span><br><span class="line">    ret[<span class="string">"PayloadType"</span>] = <span class="string">"com.apple.vpn.managed"</span></span><br><span class="line">    ret[<span class="string">"PayloadVersion"</span>] = <span class="number">1</span></span><br><span class="line">    ret[<span class="string">"UserDefinedName"</span>] = FLAGS.vpn_profile_name</span><br><span class="line">    ret[<span class="string">"VPNType"</span>] = <span class="string">"IKEv2"</span></span><br><span class="line">    ret[<span class="string">"IKEv2"</span>] = ikev2_payload(client_cert_uuid)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mobileconfig_payload</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    client_p = client_cert_payload()</span><br><span class="line">    vpn_p = vpn_payload(client_p[<span class="string">"PayloadUUID"</span>])</span><br><span class="line">    </span><br><span class="line">    ret = dict()</span><br><span class="line">    ret[<span class="string">"PayloadIdentifier"</span>] = FLAGS.profile_rdns</span><br><span class="line">    ret[<span class="string">"PayloadDisplayName"</span>] = FLAGS.profile_display_name</span><br><span class="line">    ret[<span class="string">"PayloadUUID"</span>] = str(uuid.uuid4())</span><br><span class="line">    ret[<span class="string">"PayloadType"</span>] = <span class="string">"Configuration"</span></span><br><span class="line">    ret[<span class="string">"PayloadVersion"</span>] = <span class="number">1</span></span><br><span class="line">    ret[<span class="string">"PayloadContent"</span>] = [vpn_p, client_p]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> FLAGS.ca_cert_pem_file <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        ca_p = ca_cert_payload()</span><br><span class="line">        ret[<span class="string">"PayloadContent"</span>].append(ca_p)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">    print(plistlib.dumps(mobileconfig_payload()).decode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  app.run(main)</span><br></pre></td></tr></table></figure><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>iOS 的客户端证书模板如下，具体的私钥生成和证书签发和 Part2 中的一致，获得<code>ios-key.pem</code>，<code>ios-cert.pem</code>两个文件。</p><figure class="highlight bash"><figcaption><span>ios.tmpl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># common name 似乎可以随意设置</span></span><br><span class="line">cn = <span class="string">"iOS Client"</span></span><br><span class="line"><span class="comment"># 给客户端设置 DNS 类型的 SAN</span></span><br><span class="line">dns_name = <span class="string">"iOS Client"</span></span><br><span class="line">activation_date = <span class="string">"2020-01-01 00:00:00 UTC+0"</span></span><br><span class="line">expiration_date = <span class="string">"2021-01-01 00:00:00 UTC+0"</span></span><br></pre></td></tr></table></figure><p>然后生成 p12 文件，<strong>注意</strong>：certtool 工具生成的 p12 与 iOS 有兼容性问题，可能导致无法导入，报错“容器只能包含一个证书及其密钥”，因此只能使用<code>openssl</code>生成。设置的实际密码为<code>123456</code>，以及这奇怪的输出格式是为了之后可以直接喂给 Python 脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 \</span><br><span class="line">    -inkey ios-key.pem \</span><br><span class="line">    -<span class="keyword">in</span> ios-cert.pem \</span><br><span class="line">    -<span class="built_in">export</span> \</span><br><span class="line">    -password pass:123456 | base64 &gt; ios-p12bundle.pem</span><br></pre></td></tr></table></figure><p>生成 iOS 的配置描述文件，你也可以使用苹果官方配置工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">./ios-config-gen.py \</span><br><span class="line">    <span class="comment"># 指定 CA 证书文件</span></span><br><span class="line">    --ca_cert_pem_file ca-cert.pem \</span><br><span class="line">    <span class="comment"># 指定 CA 的 Common name。只有在这里的值和证书中的值匹配时 iOS 才会给服务器</span></span><br><span class="line">    <span class="comment"># 发送证书请求。当然你也可以在服务器设置 send_cert=always</span></span><br><span class="line">    --ca_common_name <span class="string">"CA_COMMON_NAME"</span> \</span><br><span class="line">    <span class="comment"># 客户端证书文件</span></span><br><span class="line">    --client_cert_p12_file <span class="string">"ios-p12bundle.pem"</span> \</span><br><span class="line">    <span class="comment"># client_id 需要和之前的 SAN 名一致</span></span><br><span class="line">    --client_id <span class="string">"iOS Client"</span> \</span><br><span class="line">    <span class="comment"># iOS 似乎会优先将域名解析成 IPv6 地址，所以这里我们手动指定服务器的 IPv4 地址</span></span><br><span class="line">    --server_addr <span class="string">"12.34.56.78"</span> \</span><br><span class="line">    <span class="comment"># 服务器的 ID，这也是只匹配 SAN 不匹配 DN</span></span><br><span class="line">    --server_id <span class="string">"vpn.server.com"</span> \</span><br><span class="line">    <span class="comment"># 启用 on-demand VPN，这里出于我自己的需要设定成只要连着 WiFi 就连接 VPN。</span></span><br><span class="line">    <span class="comment"># 如果你需要自定义规则，则需要自己修改 Python 代码。</span></span><br><span class="line">    --always_on_wifi \</span><br><span class="line">    <span class="comment"># 可选，p12 证书的密码，不指定的话会要求用户输入</span></span><br><span class="line">    <span class="comment"># --client_cert_p12_pwd "123456" \</span></span><br><span class="line">    <span class="comment"># 没啥影响但是必填的选项（大概可以随便填？）</span></span><br><span class="line">    --profile_rdns <span class="string">"profile_rdns"</span>\</span><br><span class="line">    --vpn_rdns <span class="string">"vpn_rdns"</span>\</span><br><span class="line">    --client_cert_rdns <span class="string">"client_cert_rdns"</span>\</span><br><span class="line">    --ca_cert_rdns <span class="string">"ca_cert_rdns"</span>\</span><br><span class="line">    <span class="comment"># 所有以下选项（大概）只影响界面显示的字符串，可以（大概）随意填写。</span></span><br><span class="line">    <span class="comment"># 你可以用当前设置看看每个选项到底会被显示在哪儿。</span></span><br><span class="line">    --profile_display_name <span class="string">"profile_display_name"</span>\</span><br><span class="line">    --vpn_display_name <span class="string">"vpn_display_name"</span>\</span><br><span class="line">    --client_cert_display_name <span class="string">"client_cert_display_name"</span>\</span><br><span class="line">    --client_cert_file_name <span class="string">"client_cert_file_name"</span>\</span><br><span class="line">    --ca_cert_display_name <span class="string">"ca_cert_display_name"</span>\</span><br><span class="line">    --vpn_profile_name <span class="string">"vpn_profile_name"</span>\</span><br><span class="line">    <span class="comment"># 输出文件</span></span><br><span class="line">    &gt; ios-profile.mobileconfig</span><br></pre></td></tr></table></figure><p>然后导入进设备就 OK。可以用<code>python -m http.server [端口]</code>临时开启一个 HTTP 服务器，然后用浏览器访问这个文件即可。<br><del>你说导入失败？那是 iOS 的 BUG</del></p><h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><p>服务器配置基于 Part7 的配置修改，只注释变化部分。iOS 要求服务器证书的 subject 非空，所以在生成服务器证书的时候别忘了设置 common name。</p><figure class="highlight bash"><figcaption><span>server.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">connections &#123;</span><br><span class="line">  android-connection &#123;</span><br><span class="line">    version = 2</span><br><span class="line">    local_addrs = 12.34.56.78</span><br><span class="line">    remote_addrs = %any</span><br><span class="line">    <span class="comment"># 添加 iOS 设备使用的 ciphersuite</span></span><br><span class="line">    proposals = aes256gcm128-sha512-x25519,aes256gcm128-sha256-ecp256</span><br><span class="line">    pools = ip4pool</span><br><span class="line">    <span class="built_in">local</span> &#123;</span><br><span class="line">      id = vpn.server.com</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    remote &#123;</span><br><span class="line">      id = %any</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    children &#123;</span><br><span class="line">      child_sa &#123;</span><br><span class="line">        local_ts = 0.0.0.0/0</span><br><span class="line">        remote_ts = dynamic</span><br><span class="line">        mode = tunnel</span><br><span class="line">        <span class="comment"># 同上</span></span><br><span class="line">        esp_proposals = aes256gcm128-sha512-x25519,aes256gcm128-sha256-ecp256</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pools &#123;</span><br><span class="line">  ip4pool &#123;</span><br><span class="line">    addrs = 10.10.10.100-10.10.10.150</span><br><span class="line">    <span class="comment"># 需要指定要使用的 DNS</span></span><br><span class="line">    dns = 1.1.1.1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后重启 strongSwan 测试即可。连不上？Have fun time debugging.</p>]]></content>
    
    <summary type="html">
    
      &lt;div style=&quot;background-color:#fff0f0; padding: 0 1em 1em&quot;&gt;
&lt;center&gt;&lt;b&gt;&lt;p style=&quot;color:red; font-size:2em&quot;&gt;
⚠ 天坑预警 ⚠
&lt;/p&gt;&lt;/b&gt;&lt;/center&gt;
我在 iOS 12/13/14 各一台设备上测试过，但是测试的时候不是次次都能工作。由于 iOS 的坑实在太多，以及不同版本的 iOS 的行为都不太一样，如果你碰到了我没碰到的坑我只能祝你好运 （&lt;ゝω・）☆
&lt;/div&gt;

&lt;p&gt;接 Part6。折腾完 Android 以后我们来折腾一下 iOS。基本原理都是一样的，只是需要把苹果那一套 Vendor-specific 的配置选项翻译成 strongSwan 的，这样才能和服务器上的 strongSwan 互相通信嘛。由于 iOS 上的 IKEv2 客户端不是 strongSwan 而是苹果自己魔改的不知道什么版本，所以坑比起 Android 客户端更多。幸好 strongSwan 项目已经帮我们都踩了不少坑了：见 &lt;a href=&quot;https://wiki.strongswan.org/projects/strongswan/wiki/AppleClients&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iOS (Apple iPhone, iPad...) and macOS&lt;/a&gt; 和 &lt;a href=&quot;https://wiki.strongswan.org/projects/strongswan/wiki/AppleIKEv2Profile&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IKEv2 Configuration Profile for Apple iOS 8 and newer&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;坑坑坑&quot;&gt;&lt;a href=&quot;#坑坑坑&quot; class=&quot;headerlink&quot; title=&quot;坑坑坑&quot;&gt;&lt;/a&gt;坑坑坑&lt;/h2&gt;&lt;p&gt;由于本 Part 是基于 Part6 的，所以我们先来列举一下会需要我们做调整的 iOS 的坑（大部分在 strongSwan 的文档里已经提到过了）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;iOS 的 local_id 和 remote_id 全部都是 FQDN 类型，意味着我们需要按照 Part7 的说明给证书加上&lt;code&gt;dns_name&lt;/code&gt;的 SAN。&lt;/li&gt;
&lt;li&gt;iOS 不允许 p12 证书使用空密码。&lt;/li&gt;
&lt;li&gt;iOS 12 还不支持 ed25519，所以我们需要改用其他算法。&lt;/li&gt;
&lt;li&gt;iOS 的 mobileconfig 全是坑。&lt;/li&gt;
&lt;li&gt;iOS 需要在配置描述文件显式指定 CA 的 CN 才会发送 CERTREQ。&lt;/li&gt;
&lt;li&gt;你需要在服务端配置文件的 pool 里指定一个 DNS，否则 iOS 连上后无法上网。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基本流程是：生成密钥和证书；生成 iOS 的&lt;code&gt;mobileconfig&lt;/code&gt;配置描述文件；想办法把这个文件安装到 iOS 设备上；最后尝试连接。由于 iOS 的配置文件比 Android 的复杂许多，所以我写了个 Python 脚本来负责生成，如果你用 macOS 也可以从苹果下载官方的配置工具。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Networking" scheme="https://recursiveg.me/tags/Networking/"/>
    
      <category term="折腾" scheme="https://recursiveg.me/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="IPsec" scheme="https://recursiveg.me/tags/IPsec/"/>
    
      <category term="VPN" scheme="https://recursiveg.me/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>IPsec 配置备忘 Part7 - 证书 II</title>
    <link href="https://recursiveg.me/2020/11/ipsec-configurations-part7/"/>
    <id>https://recursiveg.me/2020/11/ipsec-configurations-part7/</id>
    <published>2020-11-15T09:45:00.000Z</published>
    <updated>2020-11-16T04:23:02.262Z</updated>
    
    <content type="html"><![CDATA[<p>接 Part2 与 Part6。尝试折腾一下除了“以证书 DN 作为 id”以外的证书使用姿势，如果有错误或者与本文解释相冲突的情况欢迎在评论指出。</p><h2 id="IKEv2-证书认证"><a href="#IKEv2-证书认证" class="headerlink" title="IKEv2 证书认证"></a>IKEv2 证书认证</h2><p>在 IKEv2 里，一方需要认证另一方基本只需要<a href="https://tools.ietf.org/html/rfc7296#page-11" target="_blank" rel="noopener">两样信息</a>，<code>ID</code>和<code>AUTH</code>。ID 就是之前配置文件里反复出现的那个，AUTH 一般是使用证书私钥对某些数据的签名，<a href="https://tools.ietf.org/html/rfc7296#section-2.15" target="_blank" rel="noopener">具体细节请参考 RFC</a>。证书则是把两者关联了起来：如果对方给出的 AUTH 能通过证书验证，那么对方就是这份证书所表示的那个人，同时这份证书又是颁发给 ID 的，那么对方就是 ID。</p><p>验证者要取得对方的证书有几种方式：</p><ul><li>管理员可以直接把证书塞进验证者的<code>/etc</code>目录里</li><li>被验证者可以自己把证书发送给验证者（<code>send_cert = always</code>参数）</li><li>验证者可以向被验证者请求证书（<code>send_certreq = yes</code>参数）。当然被验证者也可以选择不发送证书（<code>send_cert = never</code>参数），只是验证会失败就是了。</li></ul><p>另外如果验证者既不询问证书（<code>send_certreq = no</code>），被验证者也不<strong>主动</strong>发送证书（<code>send_cert = ifasked</code>），验证一样会失败。</p><p>strongSwan 在尝试匹配 ID 和证书的时候会检查 Subject DN 和 <a href="https://www.alvestrand.no/objectid/2.5.29.17.html" target="_blank" rel="noopener">SubjectAltName (SAN)</a>。我们之前一直在使用 Subject DN，而 SAN 则允许我们使用域名甚至 IP 作为 ID。另外，虽然我一直称呼“域名”或是“IP”，但是实际上只要 SAN 和 ID 匹配即可，这个“域名”到底是不是我们的并没有关系。（当然只有自签才能签出这种证书）</p><a id="more"></a><h2 id="Subject-Alternative-Name"><a href="#Subject-Alternative-Name" class="headerlink" title="Subject Alternative Name"></a>Subject Alternative Name</h2><p>要颁发带有 SAN 的证书只需要在 tmpl 文件（参见 Part2）中添加如下内容：</p><pre><code># 域名 SANdns_name=&quot;san.hosta.com&quot;# IP 地址 SANip_address = &quot;fd00::1&quot;</code></pre><p>需要注意的是，SAN 是区分类型的，比如上文的 DNS 和 IP，而 IKEv2 使用的 ID 也是分类型的（FQDN，IP，etc.）。类型需要匹配才能认证成功。有的教程会使用形如<code>@xxx.xxx.xx.x</code>这样的 IP，可能原因是，某些客户端使用 IP 作为 ID 但是却标记为 FQDN，或者是生成证书的时候将 IP 标记成了域名 SAN。这种情况就需要给 IP 添加前缀<code>@</code>来强制让 strongSwan 将其当作域名 ID。具体的解析规则可见 <a href="https://wiki.strongswan.org/projects/strongswan/wiki/IdentityParsing" target="_blank" rel="noopener">Identity Parsing</a> 文档。</p><p>除了在证书生成上的这些零碎注意点之外，我觉得另一点导致 IKEv2 很难配置的因素是，strongSwan 允许省略很多参数，而不同的平台会给这些被省略的参数提供不同的默认值，导致你以为的设置和程序实际使用的设置出现偏差。更不用说有的平台还有一些稀奇古怪的 BUG。</p><h2 id="Android-Client-w-o-DN"><a href="#Android-Client-w-o-DN" class="headerlink" title="Android Client w/o DN"></a>Android Client w/o DN</h2><p>这里我们尝试重复 Part6 中的实验，只是不出现 DN，全部用域名代替。同样的，只有有变化的部分才有注释。首先重新生成证书加入 SAN，你只需要重新用 CA 私钥签发服务器证书即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cn = <span class="string">"server common name"</span></span><br><span class="line"><span class="comment"># 域名 SAN，需要和 ID 相匹配</span></span><br><span class="line">dns_name = <span class="string">"vpn.server.com"</span></span><br><span class="line">activation_date = <span class="string">"2020-01-01 00:00:00 UTC+0"</span></span><br><span class="line">expiration_date = <span class="string">"2021-01-01 00:00:00 UTC+0"</span></span><br></pre></td></tr></table></figure><p>然后先看客户端 Profile 的变化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">jq -n \</span><br><span class="line">    --arg uuid `uuidgen -r` \</span><br><span class="line">    --arg name <span class="string">"My server"</span>\</span><br><span class="line">    --arg <span class="built_in">type</span> <span class="string">"ikev2-cert"</span>\</span><br><span class="line">    <span class="comment"># 注意这里(以及下面的 json 里)去掉了 remote.id。在 Android 客户端上，如果不指定</span></span><br><span class="line">    <span class="comment"># remote.id，那么 ID 就默认是 remote.addr 中的值。</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># 用服务器的域名代替了 IP 地址，目前客户端似乎还是会优先使用解析出来的 IPv4 地址，</span></span><br><span class="line">    <span class="comment"># 所以后面 JSON 里的 ipv6-transport 配置也不用了。</span></span><br><span class="line">    --arg addr <span class="string">"vpn.server.com"</span>\</span><br><span class="line">    <span class="comment"># 这里换成了 CA 证书，注意下方新增了 remote.certreq 配置项。</span></span><br><span class="line">    <span class="comment"># 虽然这个配置似乎默认就是 true，不过还是加上以防万一。</span></span><br><span class="line">    --arg servercert <span class="string">"`sed '/-----/d' ca-cert.pem`"</span>\</span><br><span class="line">    --arg localbundle <span class="string">"`sed '/-----/d' client-p12bundle.pem`"</span>\</span><br><span class="line">    <span class="string">'&#123;</span></span><br><span class="line"><span class="string">        uuid:$uuid,</span></span><br><span class="line"><span class="string">        name:$name,</span></span><br><span class="line"><span class="string">        type:$type,</span></span><br><span class="line"><span class="string">        remote:&#123;</span></span><br><span class="line"><span class="string">            addr:$addr,</span></span><br><span class="line"><span class="string">            cert:$servercert,</span></span><br><span class="line"><span class="string">            certreq: true</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        local: &#123;</span></span><br><span class="line"><span class="string">            p12:$localbundle</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;'</span> &gt; profile.sswan</span><br></pre></td></tr></table></figure><p>主要变化之一是省略了 remote.id 并将 remote.addr 从 IP 改成域名。注意这里不是不设置 ID，而是采用客户端的默认值（remote.addr）。和服务器配置中的省略 remote.id（%any）有巨大不同。之二是使用 CA 证书而不是直接使用服务器证书，至于为什么需要设定 certreq 请参考第一段。</p><p>再看服务端配置变化：</p><figure class="highlight bash"><figcaption><span>server.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">connections &#123;</span><br><span class="line">  android-connection &#123;</span><br><span class="line">    version = 2</span><br><span class="line">    <span class="comment"># 由于客户端优先采用 IPv4 解析，这里就需要改成 IPv4 的地址了。</span></span><br><span class="line">    local_addrs = 12.34.56.78</span><br><span class="line">    remote_addrs = %any</span><br><span class="line">    proposals = aes256gcm128-sha512-x25519</span><br><span class="line">    pools = ip4pool</span><br><span class="line">    <span class="built_in">local</span> &#123;</span><br><span class="line">      <span class="comment"># 和客户端设定的 remote.id 保持一致（</span></span><br><span class="line">      <span class="comment">#   恰好是客户端设定的 remote.addr (</span></span><br><span class="line">      <span class="comment">#     恰好是服务器的域名</span></span><br><span class="line">      <span class="comment">#   )</span></span><br><span class="line">      <span class="comment"># ）</span></span><br><span class="line">      id = vpn.server.com</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    remote &#123;</span><br><span class="line">      id = %any</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    children &#123;</span><br><span class="line">      child_sa &#123;</span><br><span class="line">        local_ts = 0.0.0.0/0</span><br><span class="line">        remote_ts = dynamic</span><br><span class="line">        mode = tunnel</span><br><span class="line">        esp_proposals = aes256gcm128-sha512-x25519</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pools &#123;</span><br><span class="line">  ip4pool &#123;</span><br><span class="line">    addrs = 10.10.10.100-10.10.10.150</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就配置好使用域名作为 ID 的 strongSwan 服务器了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接 Part2 与 Part6。尝试折腾一下除了“以证书 DN 作为 id”以外的证书使用姿势，如果有错误或者与本文解释相冲突的情况欢迎在评论指出。&lt;/p&gt;
&lt;h2 id=&quot;IKEv2-证书认证&quot;&gt;&lt;a href=&quot;#IKEv2-证书认证&quot; class=&quot;headerlink&quot; title=&quot;IKEv2 证书认证&quot;&gt;&lt;/a&gt;IKEv2 证书认证&lt;/h2&gt;&lt;p&gt;在 IKEv2 里，一方需要认证另一方基本只需要&lt;a href=&quot;https://tools.ietf.org/html/rfc7296#page-11&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;两样信息&lt;/a&gt;，&lt;code&gt;ID&lt;/code&gt;和&lt;code&gt;AUTH&lt;/code&gt;。ID 就是之前配置文件里反复出现的那个，AUTH 一般是使用证书私钥对某些数据的签名，&lt;a href=&quot;https://tools.ietf.org/html/rfc7296#section-2.15&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;具体细节请参考 RFC&lt;/a&gt;。证书则是把两者关联了起来：如果对方给出的 AUTH 能通过证书验证，那么对方就是这份证书所表示的那个人，同时这份证书又是颁发给 ID 的，那么对方就是 ID。&lt;/p&gt;
&lt;p&gt;验证者要取得对方的证书有几种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理员可以直接把证书塞进验证者的&lt;code&gt;/etc&lt;/code&gt;目录里&lt;/li&gt;
&lt;li&gt;被验证者可以自己把证书发送给验证者（&lt;code&gt;send_cert = always&lt;/code&gt;参数）&lt;/li&gt;
&lt;li&gt;验证者可以向被验证者请求证书（&lt;code&gt;send_certreq = yes&lt;/code&gt;参数）。当然被验证者也可以选择不发送证书（&lt;code&gt;send_cert = never&lt;/code&gt;参数），只是验证会失败就是了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外如果验证者既不询问证书（&lt;code&gt;send_certreq = no&lt;/code&gt;），被验证者也不&lt;strong&gt;主动&lt;/strong&gt;发送证书（&lt;code&gt;send_cert = ifasked&lt;/code&gt;），验证一样会失败。&lt;/p&gt;
&lt;p&gt;strongSwan 在尝试匹配 ID 和证书的时候会检查 Subject DN 和 &lt;a href=&quot;https://www.alvestrand.no/objectid/2.5.29.17.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SubjectAltName (SAN)&lt;/a&gt;。我们之前一直在使用 Subject DN，而 SAN 则允许我们使用域名甚至 IP 作为 ID。另外，虽然我一直称呼“域名”或是“IP”，但是实际上只要 SAN 和 ID 匹配即可，这个“域名”到底是不是我们的并没有关系。（当然只有自签才能签出这种证书）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Networking" scheme="https://recursiveg.me/tags/Networking/"/>
    
      <category term="折腾" scheme="https://recursiveg.me/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="IPsec" scheme="https://recursiveg.me/tags/IPsec/"/>
    
      <category term="VPN" scheme="https://recursiveg.me/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>IPsec 配置备忘 Part6 - Android 客户端</title>
    <link href="https://recursiveg.me/2020/11/ipsec-configurations-part6/"/>
    <id>https://recursiveg.me/2020/11/ipsec-configurations-part6/</id>
    <published>2020-11-14T14:40:00.000Z</published>
    <updated>2020-11-16T03:02:47.768Z</updated>
    
    <content type="html"><![CDATA[<p>接 Part4，终于要开始准备搭一个能用的 VPN 服务器了。另外，如果你要拿这个配置去翻墙请自便，但是不对实际效果做任何保证，本文只考虑传统的 VPN 使用场景。</p><p>基本上，服务端的配置和 Part4 中的一致，这里着重介绍如何配置客户端。配置使用 Play Store 上的 <a href="https://play.google.com/store/apps/details?id=org.strongswan.android" target="_blank" rel="noopener">strongSwan客户端</a>，版本为 2.3.1。</p><h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><p>首先，这个客户端似乎还不支持 ed25519 证书，因此我们需要改为使用 ecdsa 证书。完整的证书生成操作请看 Part2，在生成私钥时指定<code>--key-type ecdsa</code>即可。现在假设你已经生成好了所有 6 个文件：<code>ca-key.pem</code>,<code>ca-cert.pem</code>,<code>client-key.pem</code>,<code>client-cert.pem</code>,<code>server-key.pem</code>,<code>server-cert.pem</code>。</p><p>另外，这次我们会在服务器上配置 NAT，所以不再需要手动在服务端配置一个 IP 了。假设服务端<code>eth0</code>接口的公网 IP 是<code>2000::1</code>。首先将<code>ca-cert.pem</code>,<code>server-key.pem</code>,<code>server-cert.pem</code>三个文件移动到服务器上正确的地方。然后编写配置文件，同样的，这里只注释和 Part4 中不同的地方。</p><figure class="highlight bash"><figcaption><span>server.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">connections &#123;</span><br><span class="line">  android-connection &#123;</span><br><span class="line">    version = 2</span><br><span class="line">    <span class="comment"># 服务器的地址。根据官方文档，服务器内核版本需要大于等于 5.8</span></span><br><span class="line">    <span class="comment"># 才能支持 Android 客户端使用 IPv6 地址连接</span></span><br><span class="line">    local_addrs = 2000::1</span><br><span class="line">    <span class="comment"># 接受客户端来自任何地方</span></span><br><span class="line">    remote_addrs = %any</span><br><span class="line">    proposals = aes256gcm128-sha512-x25519</span><br><span class="line">    <span class="comment"># 只分配 IPv4 的虚拟 IP</span></span><br><span class="line">    pools = ip4pool</span><br><span class="line">    <span class="built_in">local</span> &#123;</span><br><span class="line">      <span class="comment"># 请按照实际情况修改 id</span></span><br><span class="line">      id = CN=server common name</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    remote &#123;</span><br><span class="line">      id = %any</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    children &#123;</span><br><span class="line">      child_sa &#123;</span><br><span class="line">        <span class="comment"># 允许客户端将去往所有目的地的流量发送给服务端</span></span><br><span class="line">        local_ts = 0.0.0.0/0</span><br><span class="line">        remote_ts = dynamic</span><br><span class="line">        mode = tunnel</span><br><span class="line">        esp_proposals = aes256gcm128-sha512-x25519</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pools &#123;</span><br><span class="line">  <span class="comment"># 只保留 IPv4 池</span></span><br><span class="line">  ip4pool &#123;</span><br><span class="line">    addrs = 10.10.10.100-10.10.10.150</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完毕后<code>systemctl restart strongswan</code>。</p><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>在客户端上，我决定创建一个可以直接导入的 Profile 文件，避免手工输入一大堆地址（要记得我在用 IPv6）。首先需要把 client-key.pem 和 client-cert.pem 合并成一个文件，注意 bash 本身是不支持多行命令和注释穿插写的，在执行的时候需要手动移除注释：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">certtool \</span><br><span class="line">    --load-privkey client-key.pem \</span><br><span class="line">    --load-certificate client-cert.pem \</span><br><span class="line">    <span class="comment"># 名称随意</span></span><br><span class="line">    --p12-name <span class="string">"Key Cert Bundle"</span> \</span><br><span class="line">    <span class="comment"># 空密码</span></span><br><span class="line">    --empty-password \</span><br><span class="line">    <span class="comment"># 合并成 PKCS12 格式</span></span><br><span class="line">    --to-p12 \</span><br><span class="line">    <span class="comment"># 需要指定 3des-pkcs12，否则 Android 系统无法正确导入</span></span><br><span class="line">    --pkcs-cipher 3des-pkcs12 &gt; client-p12bundle.pem</span><br></pre></td></tr></table></figure><p>新生成的文件是<code>client-p12bundle.pem</code>。然后我们参照 strongSwan 的<a href="https://wiki.strongswan.org/projects/strongswan/wiki/AndroidVPNClientProfiles" target="_blank" rel="noopener">文档</a>创建可以直接导入应用的 Profile 文件。当然你也可以手动导入证书再手动配置 Profile。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">jq -n \</span><br><span class="line">    <span class="comment"># 生成一个随机的 UUID</span></span><br><span class="line">    --arg uuid `uuidgen -r` \</span><br><span class="line">    <span class="comment"># Profile 的名称，可以随意写</span></span><br><span class="line">    --arg name <span class="string">"My server"</span>\</span><br><span class="line">    <span class="comment"># 认证类型</span></span><br><span class="line">    --arg <span class="built_in">type</span> <span class="string">"ikev2-cert"</span>\</span><br><span class="line">    <span class="comment"># 需要手动指定 remote id，否则服务器的地址将被当作 id，导致认证失败</span></span><br><span class="line">    <span class="comment"># 当然你也可以在创建证书的时候就把服务器地址写在证书里，避免手工指定 DN</span></span><br><span class="line">    <span class="comment"># 注意：id 和服务器地址和证书有复杂的检验关系，填写不当容易造成各种奇怪的</span></span><br><span class="line">    <span class="comment">#      身份验证错误。</span></span><br><span class="line">    --arg remoteid <span class="string">"CN=server common name"</span>\</span><br><span class="line">    <span class="comment"># 服务器的地址，我这里使用 2000::1 代替了实际地址，使用 IPv4 和域名也是可以的。</span></span><br><span class="line">    --arg addr <span class="string">"2000::1"</span>\</span><br><span class="line">    <span class="comment"># 嵌入服务器证书，注意这里我直接嵌了服务器本身的证书。嵌 CA 证书应该也是</span></span><br><span class="line">    <span class="comment"># 可行的，但是我没试。</span></span><br><span class="line">    --arg servercert <span class="string">"`sed '/-----/d' server-cert.pem`"</span>\</span><br><span class="line">    <span class="comment"># 嵌入客户端私钥和证书</span></span><br><span class="line">    --arg localbundle <span class="string">"`sed '/-----/d' client-p12bundle.pem`"</span>\</span><br><span class="line">    <span class="string">'&#123;</span></span><br><span class="line"><span class="string">        uuid:$uuid,</span></span><br><span class="line"><span class="string">        name:$name,</span></span><br><span class="line"><span class="string">        type:$type,</span></span><br><span class="line"><span class="string">        remote:&#123;</span></span><br><span class="line"><span class="string">            id:$remoteid,</span></span><br><span class="line"><span class="string">            addr:$addr,</span></span><br><span class="line"><span class="string">            cert:$servercert</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        local: &#123;</span></span><br><span class="line"><span class="string">            p12:$localbundle</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        "ipv6-transport": true</span></span><br><span class="line"><span class="string">    &#125;'</span> &gt; profile.sswan</span><br><span class="line">    <span class="comment"># 根据官方文档，服务器内核版本需要大于等于 5.8 才能支持客户端使用 IPv6 地址</span></span><br><span class="line">    <span class="comment"># 连接。同时需要设定 ipv6-transport 为 true。如果你使用 IPv4 则不需要此设置。</span></span><br><span class="line">    <span class="comment"># 另外这里没有指定 local.id，根据文档，在没有指定 local.id 的情况下，客户端程序</span></span><br><span class="line">    <span class="comment"># 会自动使用客户端证书的 DN 作为 id</span></span><br></pre></td></tr></table></figure><p>最后将生成的<code>profile.sswan</code>文件拷贝到手机上并导入即可。然后试一下能否成功建立连接。</p><h2 id="NAT-配置"><a href="#NAT-配置" class="headerlink" title="NAT 配置"></a>NAT 配置</h2><p>然后这样配置完了，虽然能连上服务器，但是依然不能访问网络，我们还需要在服务器上配置一下 NAT。一般是一条防火墙的<code>masquerade</code>规则。这里只简单把配置放出来给自己做个备忘，不做细讲：</p><figure class="highlight bash"><figcaption><span>nftables.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">table ip nat &#123;</span><br><span class="line">  chain prerouting &#123;</span><br><span class="line">    <span class="built_in">type</span> nat hook prerouting priority 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  chain postrouting &#123;</span><br><span class="line">    <span class="built_in">type</span> nat hook postrouting priority 100;</span><br><span class="line">    ip saddr 10.10.10.0/24 meta oifname eth0 masquerade</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接 Part4，终于要开始准备搭一个能用的 VPN 服务器了。另外，如果你要拿这个配置去翻墙请自便，但是不对实际效果做任何保证，本文只考虑传统的 VPN 使用场景。&lt;/p&gt;
&lt;p&gt;基本上，服务端的配置和 Part4 中的一致，这里着重介绍如何配置客户端。配置使用 Play 
      
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Networking" scheme="https://recursiveg.me/tags/Networking/"/>
    
      <category term="折腾" scheme="https://recursiveg.me/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="IPsec" scheme="https://recursiveg.me/tags/IPsec/"/>
    
      <category term="VPN" scheme="https://recursiveg.me/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>IPsec 配置备忘 Part5 - 防火墙配置</title>
    <link href="https://recursiveg.me/2020/11/ipsec-configurations-part5/"/>
    <id>https://recursiveg.me/2020/11/ipsec-configurations-part5/</id>
    <published>2020-11-14T08:30:00.000Z</published>
    <updated>2020-11-15T01:55:57.185Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下使用到的端口以及需要做的防火墙配置，不一定能覆盖所有场景，如果有漏掉的规则欢迎留言补充。</p><p><strong><em>TL;DR</em></strong> 在两端均放行：</p><ul><li>UDP 500</li><li>UDP 4500</li><li>ESP 协议<a id="more"></a></li></ul><p>最基本的 IKEv2 使用 UDP 500 端口进行通信。当密钥交换完成后，Linux 内核会将加密了的数据包封装在 ESP 中发送。所以整个包结构是：</p><pre><code>Ethernet - 外层IP - ESP - 内层IP - &lt;...&gt;</code></pre><p>但是我们也知道，所有除 UDP 和 TCP 以外的四层协议都不能很好地穿过防火墙和 NAT，于是给 ESP 套一层 UDP 就是很自然的事情了：</p><pre><code>Ethernet - 外层IP - UDP[dport=4500] - ESP - 内层IP - &lt;...&gt;</code></pre><p>这层多出来的 UDP 的端口号就被人为规定成 4500 了。另外由于一些我没有搞明白的原因，strongSwan 会在某些情况下使用 4500 进行 IKE 通信，即使并不需要 ESP UDP 封装。</p><p>在默认配置下，strongSwan 需要所有三种规则：使用 UDP 500 和 4500 (即使没有 NAT)进行 IKEv2 协商，然后内核发送 ESP 包。如果有 NAT 存在，strongSwan 会使用 UDP 4500 对数据进行封装而不使用 ESP。</p><p>如果你不想放行 4500 又不想影响非 NAT 流量，可以在<a href="https://wiki.strongswan.org/projects/strongswan/wiki/Swanctlconf" target="_blank" rel="noopener">配置文件</a>中设置<code>mobike = no</code>。你也可以使用<code>encap = yes</code>选项在没有 NAT 的环境中模拟 NAT，强制使用 UDP ESP 封装。如果你能确保你的所有 ESP 流量都是 UDP 封装的，那么不放行 ESP 也是可以的。</p><p>如果你使用不封装的 ESP，那么你需要在连接两端都放行 ESP 数据包，不然可能会出现奇怪的现象。比如，你必须先从 A ping B，然后才能从 B ping A，直接 ping 不通，之类的。</p><p>用于<code>nftables.conf</code>的放行规则如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">udp dport 500 accept</span><br><span class="line">udp dport 4500 accept</span><br><span class="line"><span class="comment"># 外层 IP 可能是 IPv4 也可能是 IPv6，需要两条规则来放行所有 ESP 包</span></span><br><span class="line">ip protocol esp accept</span><br><span class="line">ip6 nexthdr esp accept</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下使用到的端口以及需要做的防火墙配置，不一定能覆盖所有场景，如果有漏掉的规则欢迎留言补充。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;TL;DR&lt;/em&gt;&lt;/strong&gt; 在两端均放行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UDP 500&lt;/li&gt;
&lt;li&gt;UDP 4500&lt;/li&gt;
&lt;li&gt;ESP 协议
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Networking" scheme="https://recursiveg.me/tags/Networking/"/>
    
      <category term="折腾" scheme="https://recursiveg.me/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="IPsec" scheme="https://recursiveg.me/tags/IPsec/"/>
    
      <category term="VPN" scheme="https://recursiveg.me/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>IPsec 配置备忘 Part4 - Virtual IP</title>
    <link href="https://recursiveg.me/2020/11/ipsec-configurations-part4/"/>
    <id>https://recursiveg.me/2020/11/ipsec-configurations-part4/</id>
    <published>2020-11-05T12:00:00.000Z</published>
    <updated>2020-11-15T00:53:37.157Z</updated>
    
    <content type="html"><![CDATA[<p>第四篇主要讲一下怎么给客户端下发内网 IP ~<br><a href="/2020/10/ipsec-configurations-part1/">Part1 传送门</a>；<a href="/2020/10/ipsec-configurations-part2/">Part2 传送门</a>；<a href="/2020/10/ipsec-configurations-part3/">Part3 传送门</a></p><h2 id="Virtual-IP-VIP"><a href="#Virtual-IP-VIP" class="headerlink" title="Virtual IP (VIP)"></a>Virtual IP (VIP)</h2><p>接 Part3，有了 Tunnel 模式以后我们实际使用的 IP 地址就不用受制于机器的实际 IP 了。但是手动给每个客户端手动分配一个地址显然是不切实际的。于是我们可以使用 Virtual IP 功能自动向连入的客户端分配一个内网 IP，就像 DHCP 或者 SLAAC 那样。</p><h2 id="场景配置"><a href="#场景配置" class="headerlink" title="场景配置"></a>场景配置</h2><p>与之前完全对称的配置不同，使用 Virtual IP 时需要区分服务端和客户端。先在服务端配置将要分配的 IP，然后由客户端发起连接，服务端就会将配置好的 IP 分发出去。我使用 HostA 作为服务端，HostB 作为客户端。HostA 将会给 HostB 分配 IPv4 与 IPv6 各一个。使用的 Virtual IP 段是<code>fd01::100-fd01::200</code>和<code>10.10.10.100-10.10.10.150</code>。</p><pre><code>hosta$ ip -br addreth1         UP             fd00::1/64 fd01::1/128 10.10.10.1/32hostb$ ip -br addreth1         UP             fd00::2/64</code></pre><p>和 Part3 相比，HostA 这里有一些与之前不同的地方，一是内部 IP 全部放在了 eth1 上（而不是 lo 上）；二是内部 IP 的前缀长度都是最大值；三是增加了一个 IPv4 的内部 IP，用于和分配的 IPv4 Virtual IP 通信。同时 HostB 也不再手工分配<code>fd01</code>开头的内部 IP 了，将由 strongSwan 自动配置。</p><p>当连接建立后，我们应该能看到在 HostB 的 eth1 上出现两个新的，自动分配的 IP。且分配到的 IPv4 地址与 10.10.10.1 之间的通信是加密的，分配到的 IPv6 地址与 fd01::1 之间的通信是加密的。</p><a id="more"></a><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>配置文件基于 Part3 修改而来，有变化的部分已添加注释：</p><figure class="highlight bash"><figcaption><span>hosta.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">connections &#123;</span><br><span class="line">  conn_hosta_hostb &#123;</span><br><span class="line">    version = 2</span><br><span class="line">    local_addrs = fd00::1</span><br><span class="line">    remote_addrs = fd00::2</span><br><span class="line">    proposals = null-sha-modp2048</span><br><span class="line">    <span class="comment"># 指定要使用的 IP 池</span></span><br><span class="line">    pools = ip6pool,ip4pool</span><br><span class="line">    <span class="built_in">local</span> &#123;</span><br><span class="line">      id = CN=HOSTA_COMMON_NAME</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    remote &#123;</span><br><span class="line">      id = %any</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    children &#123;</span><br><span class="line">      child_sa &#123;</span><br><span class="line">        <span class="comment"># Local TS 加上新增的 IPv4 地址</span></span><br><span class="line">        local_ts = fd01::1/128,10.10.10.1/32</span><br><span class="line">        <span class="comment"># Remote TS 设置为 "dynamic"</span></span><br><span class="line">        <span class="comment"># strongSwan 会自动将其替换成分配出去的 Virtual IP</span></span><br><span class="line">        remote_ts = dynamic</span><br><span class="line">        mode = tunnel</span><br><span class="line">        esp_proposals = null-sha-modp2048</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 IP 池</span></span><br><span class="line">pools &#123;</span><br><span class="line">  <span class="comment"># IP 池的名称</span></span><br><span class="line">  ip6pool &#123;</span><br><span class="line">    <span class="comment"># 池中的 IP，也可以使用 fd01::100/120 这样的表示法</span></span><br><span class="line">    addrs = fd01::100-fd01::200</span><br><span class="line">  &#125;</span><br><span class="line">  ip4pool &#123;</span><br><span class="line">    addrs = 10.10.10.100-10.10.10.150</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>hostb.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">connections &#123;</span><br><span class="line">  conn_hosta_hostb &#123;</span><br><span class="line">    version = 2</span><br><span class="line">    local_addrs = fd00::2</span><br><span class="line">    remote_addrs = fd00::1</span><br><span class="line">    proposals = null-sha-modp2048</span><br><span class="line">    <span class="comment"># 向服务器请求 VIP，0.0.0.0 代表任意 IPv4</span></span><br><span class="line">    <span class="comment"># :: 代表任意 IPv6</span></span><br><span class="line">    vips = 0.0.0.0,::</span><br><span class="line">    <span class="built_in">local</span> &#123;</span><br><span class="line">      id = CN=HOSTB_COMMON_NAME</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    remote &#123;</span><br><span class="line">      id = CN=HOSTA_COMMON_NAME</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    children &#123;</span><br><span class="line">      child_sa &#123;</span><br><span class="line">        <span class="comment"># 类似 HostA 的 Remote TS，dynamic 会被自动替换</span></span><br><span class="line">        <span class="comment"># 成从服务端接收到的 VIP</span></span><br><span class="line">        local_ts = dynamic</span><br><span class="line">        <span class="comment"># 增加服务器的 IPv4 内网地址</span></span><br><span class="line">        remote_ts = fd01::1/128,10.10.10.1/32</span><br><span class="line">        mode = tunnel</span><br><span class="line">        esp_proposals = null-sha-modp2048</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链接测试"><a href="#链接测试" class="headerlink" title="链接测试"></a>链接测试</h2><p>与 Part3 中的对称链接不同，这次你必须从客户端发起连接，也就是从 HostB 执行如下命令：<code>swanctl -i -c child_sa</code>。连接建立后，你应该就能看到自动分配的 IP 了：</p><pre><code>hostb$ ip -br addreth1         UP             fd00::2/64 fd01::100/128 10.10.10.100/32</code></pre><p>此时再从 HostB 分别 ping <code>fd00::1</code>，<code>fd01::1</code>和<code>10.10.10.1</code>，你应该能看到前者没有加密，而后两者的 ICMP 包被包在了<code>fd00::1 &lt;---&gt; fd00::2</code>的 IPv6-ESP 包里：</p><p><img src="/images/ipsec-configurations-part4/IPv4-in-IPv6-ESP.png" alt="IPv4 ICMP inside IPv6 ESP"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第四篇主要讲一下怎么给客户端下发内网 IP ~&lt;br&gt;&lt;a href=&quot;/2020/10/ipsec-configurations-part1/&quot;&gt;Part1 传送门&lt;/a&gt;；&lt;a href=&quot;/2020/10/ipsec-configurations-part2/&quot;&gt;Part2 传送门&lt;/a&gt;；&lt;a href=&quot;/2020/10/ipsec-configurations-part3/&quot;&gt;Part3 传送门&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Virtual-IP-VIP&quot;&gt;&lt;a href=&quot;#Virtual-IP-VIP&quot; class=&quot;headerlink&quot; title=&quot;Virtual IP (VIP)&quot;&gt;&lt;/a&gt;Virtual IP (VIP)&lt;/h2&gt;&lt;p&gt;接 Part3，有了 Tunnel 模式以后我们实际使用的 IP 地址就不用受制于机器的实际 IP 了。但是手动给每个客户端手动分配一个地址显然是不切实际的。于是我们可以使用 Virtual IP 功能自动向连入的客户端分配一个内网 IP，就像 DHCP 或者 SLAAC 那样。&lt;/p&gt;
&lt;h2 id=&quot;场景配置&quot;&gt;&lt;a href=&quot;#场景配置&quot; class=&quot;headerlink&quot; title=&quot;场景配置&quot;&gt;&lt;/a&gt;场景配置&lt;/h2&gt;&lt;p&gt;与之前完全对称的配置不同，使用 Virtual IP 时需要区分服务端和客户端。先在服务端配置将要分配的 IP，然后由客户端发起连接，服务端就会将配置好的 IP 分发出去。我使用 HostA 作为服务端，HostB 作为客户端。HostA 将会给 HostB 分配 IPv4 与 IPv6 各一个。使用的 Virtual IP 段是&lt;code&gt;fd01::100-fd01::200&lt;/code&gt;和&lt;code&gt;10.10.10.100-10.10.10.150&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hosta$ ip -br addr
eth1         UP             fd00::1/64 fd01::1/128 10.10.10.1/32

hostb$ ip -br addr
eth1         UP             fd00::2/64&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;和 Part3 相比，HostA 这里有一些与之前不同的地方，一是内部 IP 全部放在了 eth1 上（而不是 lo 上）；二是内部 IP 的前缀长度都是最大值；三是增加了一个 IPv4 的内部 IP，用于和分配的 IPv4 Virtual IP 通信。同时 HostB 也不再手工分配&lt;code&gt;fd01&lt;/code&gt;开头的内部 IP 了，将由 strongSwan 自动配置。&lt;/p&gt;
&lt;p&gt;当连接建立后，我们应该能看到在 HostB 的 eth1 上出现两个新的，自动分配的 IP。且分配到的 IPv4 地址与 10.10.10.1 之间的通信是加密的，分配到的 IPv6 地址与 fd01::1 之间的通信是加密的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Networking" scheme="https://recursiveg.me/tags/Networking/"/>
    
      <category term="折腾" scheme="https://recursiveg.me/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="IPsec" scheme="https://recursiveg.me/tags/IPsec/"/>
    
      <category term="VPN" scheme="https://recursiveg.me/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>[娱乐向] Samsung 980 Pro RAID 性能测试</title>
    <link href="https://recursiveg.me/2020/11/samsung-980pro-speedtest/"/>
    <id>https://recursiveg.me/2020/11/samsung-980pro-speedtest/</id>
    <published>2020-11-02T14:00:00.000Z</published>
    <updated>2020-11-03T19:54:06.436Z</updated>
    
    <content type="html"><![CDATA[<p>三星的新 SSD 980 Pro 已经发售一段时间了，前两天看到 Amazon 上 1TB 有货，赶紧下单两条。今天到货，于是装机测一波速度。打算用来做系统盘，所以自然就是用来组 RAID-0 咯。于是用 fio 分别测试了一下 btrfs 和 mdadm 组 RAID 的性能。测试完全不严谨，参数是用脸滚键盘滚出来的，放出来仅供各位一乐，为什么是娱乐向你看数据就知道了。同时拉上了打酱油的 960 Evo（我现在的系统盘），以及完全是搞笑用的<code>/dev/shm</code>：</p><table><thead><tr><th align="left">场景</th><th align="right">连续读取(MiB/s)</th><th align="right">连续写入(MiB/s)</th><th align="right">4K 随机读取(kIOPS)</th><th align="right">4K 随机写入(kIOPS)</th></tr></thead><tbody><tr><td align="left">980 Pro 单盘 EXT4</td><td align="right">6370</td><td align="right">4725</td><td align="right">330</td><td align="right">125</td></tr><tr><td align="left">980 Pro 单盘 BTRFS</td><td align="right">6264</td><td align="right">2720</td><td align="right">137</td><td align="right">63.7</td></tr><tr><td align="left">980 Pro mdadm RAID-0 EXT4</td><td align="right">12186</td><td align="right">9426</td><td align="right">298</td><td align="right">115</td></tr><tr><td align="left">980 Pro BTRFS RAID0</td><td align="right">5937</td><td align="right">3932</td><td align="right">133</td><td align="right">63.3</td></tr><tr><td align="left">/dev/shm</td><td align="right">6290</td><td align="right">5541</td><td align="right">792</td><td align="right">571</td></tr><tr><td align="left">960 Evo 单盘 XFS</td><td align="right">2963</td><td align="right">410</td><td align="right">199</td><td align="right">31.3</td></tr></tbody></table><p>Emmmm, mdadm RAID0 比内存快……这很合理……以及 btrfs 你的 RAID 性能还能更烂一点吗？</p><a id="more"></a><p>测试用设置在此，测试<code>/dev/shm</code>的时候关掉了<code>direct</code>以及把文件大小改成了<code>1g</code>:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[global]</span></span><br><span class="line"><span class="attr">ioengine</span>=libaio</span><br><span class="line"><span class="attr">direct</span>=<span class="number">1</span></span><br><span class="line">time_based</span><br><span class="line"><span class="attr">runtime</span>=<span class="number">60</span></span><br><span class="line"><span class="attr">numjobs</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">iodepth</span>=<span class="number">32</span></span><br><span class="line">group_reporting</span><br><span class="line"><span class="attr">size</span>=<span class="number">10</span>g</span><br><span class="line"></span><br><span class="line"><span class="section">[seq_read]</span></span><br><span class="line">stonewall</span><br><span class="line"><span class="attr">bs</span>=<span class="number">1</span>M</span><br><span class="line"><span class="attr">rw</span>=read</span><br><span class="line"></span><br><span class="line"><span class="section">[seq_write]</span></span><br><span class="line">stonewall</span><br><span class="line"><span class="attr">bs</span>=<span class="number">1</span>M</span><br><span class="line"><span class="attr">rw</span>=write</span><br><span class="line"></span><br><span class="line"><span class="section">[random_read]</span></span><br><span class="line">stonewall</span><br><span class="line"><span class="attr">bs</span>=<span class="number">4</span>k</span><br><span class="line"><span class="attr">rw</span>=randread</span><br><span class="line"></span><br><span class="line"><span class="section">[random_write]</span></span><br><span class="line">stonewall</span><br><span class="line"><span class="attr">bs</span>=<span class="number">4</span>k</span><br><span class="line"><span class="attr">rw</span>=randwrite</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;三星的新 SSD 980 Pro 已经发售一段时间了，前两天看到 Amazon 上 1TB 有货，赶紧下单两条。今天到货，于是装机测一波速度。打算用来做系统盘，所以自然就是用来组 RAID-0 咯。于是用 fio 分别测试了一下 btrfs 和 mdadm 组 RAID 的性能。测试完全不严谨，参数是用脸滚键盘滚出来的，放出来仅供各位一乐，为什么是娱乐向你看数据就知道了。同时拉上了打酱油的 960 Evo（我现在的系统盘），以及完全是搞笑用的&lt;code&gt;/dev/shm&lt;/code&gt;：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;场景&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;连续读取(MiB/s)&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;连续写入(MiB/s)&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;4K 随机读取(kIOPS)&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;4K 随机写入(kIOPS)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;980 Pro 单盘 EXT4&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;6370&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;4725&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;330&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;125&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;980 Pro 单盘 BTRFS&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;6264&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;2720&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;137&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;63.7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;980 Pro mdadm RAID-0 EXT4&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;12186&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;9426&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;298&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;115&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;980 Pro BTRFS RAID0&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;5937&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;3932&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;133&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;63.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;/dev/shm&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;6290&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;5541&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;792&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;571&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;960 Evo 单盘 XFS&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;2963&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;410&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;199&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;31.3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;Emmmm, mdadm RAID0 比内存快……这很合理……以及 btrfs 你的 RAID 性能还能更烂一点吗？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="折腾" scheme="https://recursiveg.me/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="硬件" scheme="https://recursiveg.me/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>IPsec 配置备忘 Part3 - Tunnel 模式</title>
    <link href="https://recursiveg.me/2020/10/ipsec-configurations-part3/"/>
    <id>https://recursiveg.me/2020/10/ipsec-configurations-part3/</id>
    <published>2020-10-31T02:50:00.000Z</published>
    <updated>2020-10-31T18:06:53.952Z</updated>
    
    <content type="html"><![CDATA[<p>第三篇简单介绍一下 IPsec 的 Tunnel 模式，没看过前两篇的快去看~<br><a href="/2020/10/ipsec-configurations-part1/">Part1 传送门</a>；<a href="/2020/10/ipsec-configurations-part2/">Part2 传送门</a></p><h2 id="Tunnel-模式简介"><a href="#Tunnel-模式简介" class="headerlink" title="Tunnel 模式简介"></a>Tunnel 模式简介</h2><p><img src="/images/ipsec-configurations-part3/01-tunnel-mode-header-layout.png" alt="Tunnel mode header layout"> 前两篇中我们使用的都是 Transport 模式，但是实际使用中，更常用的是 Tunnel 模式。Transport 模式只加密四层及以上数据，而不修改 IP 头，原始的 IP 头将会原样传输。这意味着我们只能进行点对点传输，因为只有一个 IP 头，我们无法告知对方服务器我们实际要访问的地址。Tunnel 模式则是连原始的 IP 头也一起加密，然后再在前端添加一个新的 IP 头，这样服务器在收到数据包后，可以解密并读取内部的 IP 头，再转发给实际的目标服务器。</p><a id="more"></a><h2 id="配置场景"><a href="#配置场景" class="headerlink" title="配置场景"></a>配置场景</h2><p>这次的场景在 Part2 的基础上略有改动：在 HostA 与 HostB 的<code>lo</code>接口上分别添加<code>fd01::1/64</code>与<code>fd01::2/64</code>:</p><pre><code>hosta$ ip -6 -br addrlo               UNKNOWN        fd01::1/64 ::1/128eth1             UP             fd00::1/64 [--omit--][--omit--]hostb$ ip -6 -br addrlo               UNKNOWN        fd01::2/64 ::1/128eth1             UP             fd00::2/64 [--omit--][--omit--]</code></pre><p>在没有建立连接的情况下，fd00::1 和 fd00::2 可互 ping，fd01::1 和 fd01::2 不可互 ping。在建立连接后，fd00::1 和 fd00::2 可互 ping，但是不加密，fd01::1 和 fd01::2 可互 ping 且流量加密。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>配置文件也是在 Part2 的基础上改动而来，变化部分已加注释</p><figure class="highlight bash"><figcaption><span>hosta.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hosta</span></span><br><span class="line">connections &#123;</span><br><span class="line">  conn_hosta_hostb &#123;</span><br><span class="line">    version = 2</span><br><span class="line">    local_addrs = fd00::1</span><br><span class="line">    remote_addrs = fd00::2</span><br><span class="line">    <span class="comment"># 使用 NULL 加密以方便抓包观察</span></span><br><span class="line">    proposals = null-sha-modp2048</span><br><span class="line">    <span class="built_in">local</span> &#123;</span><br><span class="line">      id = CN=HOSTA_COMMON_NAME</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    remote &#123;</span><br><span class="line">      id = %any</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    children &#123;</span><br><span class="line">      child_sa &#123;</span><br><span class="line">        <span class="comment"># Traffic selector 改为 fd01::*</span></span><br><span class="line">        <span class="comment"># 这意味着 fd00::* 不被选中，也就不会被加密</span></span><br><span class="line">        local_ts = fd01::1/128</span><br><span class="line">        remote_ts = fd01::2/128</span><br><span class="line">        <span class="comment"># 传输模式改为 Tunnel</span></span><br><span class="line">        mode = tunnel</span><br><span class="line">        esp_proposals = null-sha-modp2048</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>hostb.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">connections &#123;</span><br><span class="line">  conn_hosta_hostb &#123;</span><br><span class="line">    version = 2</span><br><span class="line">    <span class="comment"># 交换 local 与 remote</span></span><br><span class="line">    local_addrs = fd00::2</span><br><span class="line">    remote_addrs = fd00::1</span><br><span class="line">    proposals = null-sha-modp2048</span><br><span class="line">    <span class="built_in">local</span> &#123;</span><br><span class="line">      <span class="comment"># 使用 HostB 的 id</span></span><br><span class="line">      id = CN=HOSTB_COMMON_NAME</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    remote &#123;</span><br><span class="line">      id = %any</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    children &#123;</span><br><span class="line">      child_sa &#123;</span><br><span class="line">        <span class="comment"># 交换 local 与 remote</span></span><br><span class="line">        local_ts = fd01::2/128</span><br><span class="line">        remote_ts = fd01::1/128</span><br><span class="line">        mode = tunnel</span><br><span class="line">        esp_proposals = null-sha-modp2048</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链接测试"><a href="#链接测试" class="headerlink" title="链接测试"></a>链接测试</h2><p>启动 strongSwan 和 Wireshark，在 HostA 上，可以 ping fd00::2 但是不能 ping fd01::2。然后用<code>sudo swanctl -i -c child_sa</code>建立连接，依然可以 ping fd00::2 但是数据不加密，同时能够 ping 通 fd01::2 了。抓包可以看出明显的<code>ETHERNET-IP-ESP-IP-ICMP</code>的包头层次，并且外层 IP 使用 fd00::* 进行数据传输，内层 IP 使用 fd01::* 的实际目的地址：</p><p><img src="/images/ipsec-configurations-part3/02-esp-tunnel-mode-packet-wireshark.png" alt="Tunnel mode packet example"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第三篇简单介绍一下 IPsec 的 Tunnel 模式，没看过前两篇的快去看~&lt;br&gt;&lt;a href=&quot;/2020/10/ipsec-configurations-part1/&quot;&gt;Part1 传送门&lt;/a&gt;；&lt;a href=&quot;/2020/10/ipsec-configurations-part2/&quot;&gt;Part2 传送门&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Tunnel-模式简介&quot;&gt;&lt;a href=&quot;#Tunnel-模式简介&quot; class=&quot;headerlink&quot; title=&quot;Tunnel 模式简介&quot;&gt;&lt;/a&gt;Tunnel 模式简介&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/ipsec-configurations-part3/01-tunnel-mode-header-layout.png&quot; alt=&quot;Tunnel mode header layout&quot;&gt; 前两篇中我们使用的都是 Transport 模式，但是实际使用中，更常用的是 Tunnel 模式。Transport 模式只加密四层及以上数据，而不修改 IP 头，原始的 IP 头将会原样传输。这意味着我们只能进行点对点传输，因为只有一个 IP 头，我们无法告知对方服务器我们实际要访问的地址。Tunnel 模式则是连原始的 IP 头也一起加密，然后再在前端添加一个新的 IP 头，这样服务器在收到数据包后，可以解密并读取内部的 IP 头，再转发给实际的目标服务器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Networking" scheme="https://recursiveg.me/tags/Networking/"/>
    
      <category term="折腾" scheme="https://recursiveg.me/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="IPsec" scheme="https://recursiveg.me/tags/IPsec/"/>
    
      <category term="VPN" scheme="https://recursiveg.me/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>IPsec 配置备忘 Part2 - 证书</title>
    <link href="https://recursiveg.me/2020/10/ipsec-configurations-part2/"/>
    <id>https://recursiveg.me/2020/10/ipsec-configurations-part2/</id>
    <published>2020-10-30T15:50:00.000Z</published>
    <updated>2020-12-05T22:13:32.162Z</updated>
    
    <content type="html"><![CDATA[<p>作为系列的第二篇文章，讲解基本的证书原理和配置方法。没看过第一部分的快去看～<br>传送门：<a href="/2020/10/ipsec-configurations-part1/">IPsec 配置备忘 Part1</a>。</p><h2 id="证书认证基础"><a href="#证书认证基础" class="headerlink" title="证书认证基础"></a>证书认证基础</h2><p>我们在 Part1 中看到，PSK 认证的基本思路是使用一个只有通信双方才知道的暗号，如果能确认对方确实知道这个暗号，那么认证就成功了。证书认证的思路非常不同：假设 A 需要向 B 证明自己的身份，同时 A 知道 B 信任 C，那么 A 可以向 C 索取一份“介绍信”，当 B 询问 A 的身份时，A 可以向 B 展示这份 C 出具的“介绍信”，如果 B 能够确认这份“介绍信”确实是由 C 出具的，那么认证就成功了。注意这个认证是单向的，假设 A 也信任 C，那么 B 也可以通过向 C 索取“介绍信”来向 A 证明自己的身份。在 PKI 体系中，A 和 B 持有各自的“私钥”，C 作为 Certificate Authority (CA) 向 A/B 颁发证书（即“介绍信”）。同时，CA 也会向自己颁发一份证书并分发给 A/B，A/B 使用 CA 的证书来确认 B/A 出示的证书确实为 C 所颁发。</p><a id="more"></a><h2 id="使用-certtool-创建证书"><a href="#使用-certtool-创建证书" class="headerlink" title="使用 certtool 创建证书"></a>使用 certtool 创建证书</h2><p>我使用 <a href="https://www.gnutls.org/manual/html_node/certtool-Invocation.html" target="_blank" rel="noopener">certtool</a> 没有什么特别的理由，你也可以用<code>openssl</code>或者 strongSwan 自带的<code>pki</code>工具。我在之前的一篇文章里介绍过如何使用 certtool 创建证书：<a href="/2016/12/assign-ipv6-through-ipsec-and-strongswan/">借助IPsec和strongSwan建立隧道并分配IPv6地址</a>。不过我还是决定再写一遍现在的配置。我们的配置场景和 Part1 中的相同，只不过把 PSK 认证换成了证书认证。</p><p>首先给 HostA, HostB 和 CA 分别创建私钥，我这里用的是 ed25519，一些设备可能不支持，请自行参考文档换成 RSA：</p><pre><code>certtool --generate-privkey --key-type ed25519 --outfile ca-key.pemcerttool --generate-privkey --key-type ed25519 --outfile hosta-key.pemcerttool --generate-privkey --key-type ed25519 --outfile hostb-key.pem</code></pre><p>生成证书时，我们需要手动指定一些证书的信息，比如证书的名称，过期时间等等。证书的 <a href="https://ldapwiki.com/wiki/Distinguished%20Names" target="_blank" rel="noopener">Distinguished Name (DN)</a> 会被用来和 IKEv2 的身份标识符进行匹配，以决定具体向对方出示哪份证书（对于发送者）以及是否接受对方的证书（对于接受者）。这些信息需要写成一个 template 文件才能被 certtool 读取，详细的 template 文件格式可以在 <a href="https://www.gnutls.org/manual/html_node/certtool-Invocation.html" target="_blank" rel="noopener">certtool 的帮助文档</a>里查到。<em>template 中的键名大小写敏感。</em></p><figure class="highlight bash"><figcaption><span>ca.tmpl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Common name, 是 DN 的一部分</span></span><br><span class="line">cn = <span class="string">"CA_COMMON_NAME"</span></span><br><span class="line"><span class="comment"># 组织名，是 DN 的一部分</span></span><br><span class="line">organization = <span class="string">"ORG_NAME"</span></span><br><span class="line"></span><br><span class="line">ca</span><br><span class="line"><span class="comment"># 生效与过期时间</span></span><br><span class="line">activation_date = <span class="string">"2020-01-01 00:00:00 UTC+0"</span></span><br><span class="line">expiration_date = <span class="string">"2030-01-01 00:00:00 UTC+0"</span></span><br><span class="line">cert_signing_key</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>hosta.tmpl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cn = <span class="string">"HOSTA_COMMON_NAME"</span></span><br><span class="line">activation_date = <span class="string">"2020-01-01 00:00:00 UTC+0"</span></span><br><span class="line">expiration_date = <span class="string">"2021-01-01 00:00:00 UTC+0"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>hostb.tmpl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cn = <span class="string">"HOSTB_COMMON_NAME"</span></span><br><span class="line">activation_date = <span class="string">"2020-01-01 00:00:00 UTC+0"</span></span><br><span class="line">expiration_date = <span class="string">"2021-01-01 00:00:00 UTC+0"</span></span><br></pre></td></tr></table></figure><p>然后创建证书：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成自签名 CA 证书</span></span><br><span class="line">certtool --generate-self-signed \</span><br><span class="line">    --template ca.tmpl \</span><br><span class="line">    --load-privkey ca-key.pem \</span><br><span class="line">    --outfile ca-cert.pem</span><br><span class="line"></span><br><span class="line"><span class="comment"># CA 向 HostA 颁发证书</span></span><br><span class="line">certtool --generate-certificate \</span><br><span class="line">    --template hosta.tmpl \</span><br><span class="line">    --load-ca-certificate ca-cert.pem \</span><br><span class="line">    --load-ca-privkey ca-key.pem \</span><br><span class="line">    --load-privkey hosta-key.pem \</span><br><span class="line">    --outfile hosta-cert.pem</span><br><span class="line"></span><br><span class="line"><span class="comment"># CA 向 HostB 颁发证书    </span></span><br><span class="line">certtool --generate-certificate \</span><br><span class="line">    --template hostb.tmpl \</span><br><span class="line">    --load-ca-certificate ca-cert.pem \</span><br><span class="line">    --load-ca-privkey ca-key.pem \</span><br><span class="line">    --load-privkey hostb-key.pem \</span><br><span class="line">    --outfile hostb-cert.pem</span><br></pre></td></tr></table></figure><p>最终会生成的 6 个文件，你可以使用<code>certtool --key-info &lt; hosta-key.pem</code>来查看私钥信息，用<code>certtool --certificate-info &lt; hosta-cert.pem</code>来查看证书信息，用<code>certtool --verify --load-ca-certificate ca-cert.pem &lt; hosta-cert.pem</code>来检查证书是否确实是由 CA 签发的。其中：</p><ul><li><code>hosta-key.pem, hosta-cert.pem, ca-cert.pem</code> 需要拷贝到 HostA 上</li><li><code>hostb-key.pem, hostb-cert.pem, ca-cert.pem</code> 需要拷贝到 HostB 上</li><li><code>ca-key.pem</code> 留在本地好好保管不要交给任何人。</li></ul><p>对于 strongSwan，私钥<code>*-key.pem</code>需要放置在<code>/etc/swanctl/private</code>，私钥对应的证书<code>host*-cert.pem</code>需要放置在<code>/etc/swanctl/x509</code>，CA 证书<code>ca-cert.pem</code>需要放置在<code>/etc/swanctl/x509ca</code>。</p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>基本上和 Part1 中的配置一样，有不同之处已经加了注释</p><figure class="highlight bash"><figcaption><span>hosta.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">connections &#123;</span><br><span class="line">  conn_hosta_hostb &#123;</span><br><span class="line">    version = 2</span><br><span class="line">    local_addrs = fd00::1</span><br><span class="line">    remote_addrs = fd00::2</span><br><span class="line">    proposals = aes256gcm128-sha512-x25519</span><br><span class="line">    <span class="built_in">local</span> &#123;</span><br><span class="line">      <span class="comment"># id 是证书的 DN，由于我们在 hosta.tmpl 里只指定了 CN，</span></span><br><span class="line">      <span class="comment"># 所以 DN 就是 "CN=&#123;...&#125;"。这个 id 会被发送给对方，</span></span><br><span class="line">      <span class="comment"># 同时对应的证书/密钥对（hosta-cert/key.pem）会被选中，</span></span><br><span class="line">      <span class="comment"># 作为对 id 的证明。</span></span><br><span class="line">      id = CN=HOSTA_COMMON_NAME</span><br><span class="line">      <span class="comment"># 使用证书作为身份标识符的证明方式</span></span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    remote &#123;</span><br><span class="line">      <span class="comment"># 接受任何 id，只要这个 id 能通过证书验证</span></span><br><span class="line">      <span class="comment"># i.e. 只要对方出示的证书确实是由某个 CA 签署的即可。</span></span><br><span class="line">      id = %any</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    children &#123;</span><br><span class="line">      child_sa &#123;</span><br><span class="line">        local_ts = fd00::1/128</span><br><span class="line">        remote_ts = fd00::2/128</span><br><span class="line">        mode = transport</span><br><span class="line">        esp_proposals = aes256gcm128-sha512-x25519</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不需要 secrets 指定 PSK 了。</span></span><br></pre></td></tr></table></figure><p>将<code>remote.id</code>设置成<code>%any</code>会有一定的安全问题，比如 HostA 是服务器，HostB 和 HostC 是客户端，如果 HostB 连接 HostA 的时候不检查 id，那么如果 HostC 能劫持 IP 地址，它就能假装成 HostA。毕竟 HostB 不关心它连接的到底是 A 还是 C。解决方法也很简单，指定<code>remote.id</code>为<code>CN=HOSTB_COMMON_NAME</code>即可。</p><p>HostB 的配置除了<code>local.id</code>外完全一致</p><figure class="highlight bash"><figcaption><span>hostb.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">connections &#123;</span><br><span class="line">  conn_hosta_hostb &#123;</span><br><span class="line">    version = 2</span><br><span class="line">    local_addrs = fd00::1</span><br><span class="line">    remote_addrs = fd00::2</span><br><span class="line">    proposals = aes256gcm128-sha512-x25519</span><br><span class="line">    <span class="built_in">local</span> &#123;</span><br><span class="line">      id = CN=HOSTB_COMMON_NAME <span class="comment"># 使用 HostB 的证书的 DN</span></span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    remote &#123;</span><br><span class="line">      id = %any</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    children &#123;</span><br><span class="line">      child_sa &#123;</span><br><span class="line">        local_ts = fd00::1/128</span><br><span class="line">        remote_ts = fd00::2/128</span><br><span class="line">        mode = transport</span><br><span class="line">        esp_proposals = aes256gcm128-sha512-x25519</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链接测试"><a href="#链接测试" class="headerlink" title="链接测试"></a>链接测试</h2><p>同 Part1，在任意一侧使用<code>sudo swanctl -i -c child_sa</code>建立连接即可。连接建立后抓包即可看到加密流量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为系列的第二篇文章，讲解基本的证书原理和配置方法。没看过第一部分的快去看～&lt;br&gt;传送门：&lt;a href=&quot;/2020/10/ipsec-configurations-part1/&quot;&gt;IPsec 配置备忘 Part1&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;证书认证基础&quot;&gt;&lt;a href=&quot;#证书认证基础&quot; class=&quot;headerlink&quot; title=&quot;证书认证基础&quot;&gt;&lt;/a&gt;证书认证基础&lt;/h2&gt;&lt;p&gt;我们在 Part1 中看到，PSK 认证的基本思路是使用一个只有通信双方才知道的暗号，如果能确认对方确实知道这个暗号，那么认证就成功了。证书认证的思路非常不同：假设 A 需要向 B 证明自己的身份，同时 A 知道 B 信任 C，那么 A 可以向 C 索取一份“介绍信”，当 B 询问 A 的身份时，A 可以向 B 展示这份 C 出具的“介绍信”，如果 B 能够确认这份“介绍信”确实是由 C 出具的，那么认证就成功了。注意这个认证是单向的，假设 A 也信任 C，那么 B 也可以通过向 C 索取“介绍信”来向 A 证明自己的身份。在 PKI 体系中，A 和 B 持有各自的“私钥”，C 作为 Certificate Authority (CA) 向 A/B 颁发证书（即“介绍信”）。同时，CA 也会向自己颁发一份证书并分发给 A/B，A/B 使用 CA 的证书来确认 B/A 出示的证书确实为 C 所颁发。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Networking" scheme="https://recursiveg.me/tags/Networking/"/>
    
      <category term="折腾" scheme="https://recursiveg.me/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="IPsec" scheme="https://recursiveg.me/tags/IPsec/"/>
    
      <category term="VPN" scheme="https://recursiveg.me/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>IPsec 配置备忘 Part1 - IKEv2 基础</title>
    <link href="https://recursiveg.me/2020/10/ipsec-configurations-part1/"/>
    <id>https://recursiveg.me/2020/10/ipsec-configurations-part1/</id>
    <published>2020-10-29T15:40:00.000Z</published>
    <updated>2021-01-19T04:10:19.549Z</updated>
    
    <content type="html"><![CDATA[<p>俗话说得好，配置 IPsec 隧道只有零次和无数次，在被 strongSwan 折磨了 N 次以后，我终于决定要把之前试过的配置都记录下来，于是就有了这个系列。我计划基本上每个 PART 会介绍一个（或几个）特定场景下的配置，配置文件样例以 strongSwan vici 为主，之后可能会介绍 iOS, Android 或者是 Mikrotik 路由器的配置方法，<del>如果我能坚持不鸽写到那里的话（画外音：你这 FLAG 立得……）</del> <a href="/2021/01/ipsec-configurations-part9/">FLAG 回收了</a>。如果各位有想看的配置场景欢迎留言告诉我，会考虑先写。</p><h2 id="IKEv2-与-IPsec-基础"><a href="#IKEv2-与-IPsec-基础" class="headerlink" title="IKEv2 与 IPsec 基础"></a>IKEv2 与 IPsec 基础</h2><p>严格来说 IKEv2 不是 VPN，它的全称是 Internet Key Exchange，只是一种用于交换密钥的协议罢了。密钥在计算机里一般就表示为一串固定长度的二进制数据，密钥交换就是指在两台设备之间约定一个相同的二进制串，就像两个密友之间约定暗号一样。一旦密钥交换完毕，IKE 的使命就结束了，具体怎么用约定好的密钥加密数据不是 IKE 解决的问题。在 Linux 系统上，实际的数据包加密解密是由内核的 XFRM 框架负责的，你可以使用<code>ip xfrm</code>命令看到配置好的密钥以及加解密使用的算法。事实上，不使用 IKEv2 而完全手动“交换”密钥是可行的，比如<a href="https://gist.github.com/blackgear/a9f96261b091b2215dfd" target="_blank" rel="noopener">朴素VPN：一个纯内核级静态隧道</a>。你可以看到作者直接使用<code>ip xfrm {policy,state} add</code>指令设定密钥，然后内核就会自动用设定的密钥加密流量。</p><p>然而，手动管理内核状态是复杂的，人工分发密钥也不怎么安全，这时就轮到 strongSwan 登场啦（或者说，任何实现了 IKE 的 Daemon 服务）。两台服务器的 strongSwan 使用 IKEv2 协议交换密钥，解决了密钥分发的问题。随后 strongSwan 会把交换得来的密钥设定进内核，这样内核就会自动加密指定的流量了。</p><p>从数据包层面上看，IKE 是7层协议，密钥交换使用特殊的 UDP 包完成。而一般被加密的数据包会使用 ESP 封装，ESP 头一般紧跟在 IP 头后。ESP 也可以被封装进 UDP 用以穿越 NAT。</p><h2 id="没有-TUN-设备"><a href="#没有-TUN-设备" class="headerlink" title="没有 TUN 设备"></a>没有 TUN 设备</h2><p>内核 XFRM 的工作方式和基于 TUN 设备的 VPN 很不一样。一般基于 TUN 的 VPN 会加密所有进入 TUN 设备的流量，因此你可以直接使用路由表来控制哪些流量走 VPN，哪些不走。而 XFRM 的匹配基于策略（i.e. 源地址+目标地址+一些别的），如果某个数据包匹配到了一个策略，这个数据包就会根据这个策略指定的方式被加密。</p><p>比方说有<code>A [fd00::1]</code>和<code>B [fd00::2]</code>，如果你从 A 发送一个数据包到 B，普通情况下这个数据包是明文的。如果你在 A 配置了<code>src=fd00::1,dst=fd00::2,encrypt=&lt;...&gt;</code>的策略并再发一个数据包，这个包就会自动被加密。B 收到了这个数据包，但是它并不知道该如何解密，所以你必须同时在 B 配置一条<code>src=fd00::1,dst=fd00::2,decrypt=&lt;...&gt;</code>的策略，这样 B 才能解密。对于从 B 到 A 的流量也需要类似的两条策略。使用 IKEv2 的话，这些策略 strongSwan 都会自动帮你设置好，无需操心。于是你会发现，尽管我们仍然在使用节点本身的 IP，但是流量却已经被加密了。</p><p>对于那些必须使用路由表或是策略匹配不是很有效的场景, <a href="https://wiki.strongswan.org/projects/strongswan/wiki/RouteBasedVPN" target="_blank" rel="noopener">Route-based IPsec VPN</a> 也是存在的。我也许会在未来的某一期讲。</p><a id="more"></a><h2 id="一些-IKEv2-的细节"><a href="#一些-IKEv2-的细节" class="headerlink" title="一些 IKEv2 的细节"></a>一些 IKEv2 的细节</h2><p>IKEv2 除了交换密钥以外，还负责包括身份认证，协议协商等一系列其他工作。实际使用的时候，我们一般需要指定这些参数：</p><ul><li>对方的 IKE 服务器地址</li><li>自己的身份标识符</li><li>能接受的对方的身份标识符，可选。</li><li>对自己身份标识符的证明，一般是 PSK (预共享密钥) 或者是证书。</li><li>对对方身份标识符证明的验证方式，比方说，如果对方使用证书认证其身份，则可以通过检查 CA 证书链的方式来证明其证书的有效性。</li><li>自己能接受的 Cipher suite</li><li>Local traffic selector</li><li>Remote traffic selector</li></ul><p>以上所有这些参数需要在两端都配置。其中，cipher suite 需要至少指定两次，原因是 IKEv2 是一个两阶段协议，两阶段使用的 cipher suite 可以不同。在第一阶段会简单地进行一次 DH 密钥交换，建立 IKE_SA，然后进入第二阶段。二阶段中的身份认证，traffic selector 协商等均会被加密。在二阶段 IKE 会建立 CHILD_SA，也是用来加密实际数据的 SA，CHILD_SA 的协商结果，包括密钥，加密算法，traffic selector 等均会被设定入内核，以便内核进行实际的加密操作。</p><p><a href="https://docs.paloaltonetworks.com/pan-os/9-0/pan-os-admin/vpns/site-to-site-vpn-concepts/ikev2/traffic-selectors.html" target="_blank" rel="noopener">Traffic selector</a> 决定了内核匹配数据包的策略，即，哪些数据需要被加密。比方说，一个 VPN 客户端可能会设定 <code>local_ts=10.0.0.14/32, remote_ts=0.0.0.0/0</code> 这意味着该客户端希望所有流量都被加密。而一个服务器可能会设定 <code>local_ts=&lt;所有非中国大陆IP&gt;, remote_ts=10.0.0.14/32</code>，这说明该服务器不希望处理去往中国大陆 IP 的流量。如果这两者进行协商，结果客户端就不会将去往中国大陆 IP 的流量发送给服务端。这也被称作 <a href="https://wiki.strongswan.org/projects/strongswan/wiki/ForwardingAndSplitTunneling" target="_blank" rel="noopener">Split Tunneling</a>。</p><h2 id="简单-Host-to-Host-配置"><a href="#简单-Host-to-Host-配置" class="headerlink" title="简单 Host-to-Host 配置"></a>简单 Host-to-Host 配置</h2><p>这是一份简单的 Host-to-Host 配置样例，场景和<code>没有 TUN 设备</code>中描述的一致。我在本地的两台物理机上进行配置，两台机器使用网线直连，并用<code>ip addr add fd00::{1,2}/64 dev &lt;name&gt;</code>手动配置 IP。认证方式使用 PSK。在 Archlinux 上，配置文件位于<code>/etc/swanctl/swanctl.conf</code>。使用<code>sudo systemctl start strongswan</code>来启动 strongSwan。</p><p>这是 HostA 的配置:</p><figure class="highlight bash"><figcaption><span>hosta.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">connections &#123;</span><br><span class="line">  conn_hosta_hostb &#123;</span><br><span class="line">    <span class="comment"># IKEv2</span></span><br><span class="line">    version = 2</span><br><span class="line">    <span class="comment"># 本地 IKEv2 服务地址</span></span><br><span class="line">    local_addrs = fd00::1</span><br><span class="line">    <span class="comment"># 对方 IKEv2 服务地址</span></span><br><span class="line">    remote_addrs = fd00::2</span><br><span class="line">    <span class="comment"># IKE_SA 的 cipher suite</span></span><br><span class="line">    proposals = aes256gcm128-sha512-x25519</span><br><span class="line">    <span class="built_in">local</span> &#123;</span><br><span class="line">      id = hosta     <span class="comment"># 己方身份标识符</span></span><br><span class="line">      auth = psk     <span class="comment"># 己方身份标识符的证明方式</span></span><br><span class="line">    &#125;</span><br><span class="line">    remote &#123;</span><br><span class="line">      id = %any      <span class="comment"># 对方身份标识符，这里接受任意标识符</span></span><br><span class="line">      auth = psk     <span class="comment"># 对方身份标识符证明的验证方式</span></span><br><span class="line">    &#125;</span><br><span class="line">    children &#123;       <span class="comment"># 列出需要建立的 CHILD_SA</span></span><br><span class="line">      child_sa &#123;     <span class="comment"># 只有一个 CHILD_SA, 叫做 "child_sa"</span></span><br><span class="line">        local_ts = fd00::1/128  <span class="comment"># Local traffic selector</span></span><br><span class="line">        remote_ts = fd00::2/128 <span class="comment"># Remote traffic selector</span></span><br><span class="line">        mode = transport        <span class="comment"># 使用 Tansport 模式而不是 Tunnel 模式</span></span><br><span class="line">        <span class="comment"># CHILD_SA 的 cipher suite, 其实这里用的和 IKE_SA 的是一样的</span></span><br><span class="line">        esp_proposals = aes256gcm128-sha512-x25519</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">secrets &#123;</span><br><span class="line">  ike_hosta &#123;</span><br><span class="line">    <span class="comment"># 发送己方身份时，使用这个 PSK</span></span><br><span class="line">    id = hosta</span><br><span class="line">    secret = pwd_for_hosta</span><br><span class="line">  &#125;</span><br><span class="line">  ike_hostb &#123;</span><br><span class="line">    <span class="comment"># 对方发送的身份标识符是"hostb"，会匹配到这个 PSK</span></span><br><span class="line">    <span class="comment"># 实际操作中一般不这么写，而是把两个 id 写到同一个 ike_* 块中，共用 secret。</span></span><br><span class="line">    id = hostb</span><br><span class="line">    secret = pwd_for_hostb</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HostB 的配置，几乎一样：</p><figure class="highlight bash"><figcaption><span>hostb.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">connections &#123;</span><br><span class="line">  conn_hosta_hostb &#123;</span><br><span class="line">    version = 2</span><br><span class="line">    local_addrs = fd00::2  <span class="comment"># IP 地址交换一下</span></span><br><span class="line">    remote_addrs = fd00::1</span><br><span class="line">    proposals = aes256gcm128-sha512-x25519</span><br><span class="line">    <span class="built_in">local</span> &#123;</span><br><span class="line">      id = hostb  <span class="comment"># 标识符改一下</span></span><br><span class="line">      auth = psk</span><br><span class="line">    &#125;</span><br><span class="line">    remote &#123;</span><br><span class="line">      id = %any</span><br><span class="line">      auth = psk</span><br><span class="line">    &#125;</span><br><span class="line">    children &#123;</span><br><span class="line">      child_sa &#123;</span><br><span class="line">        local_ts = fd00::2/128  <span class="comment"># IP 地址交换一下</span></span><br><span class="line">        remote_ts = fd00::1/128</span><br><span class="line">        mode = transport</span><br><span class="line">        esp_proposals = aes256gcm128-sha512-x25519</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">secrets &#123;</span><br><span class="line">  ike_hosta &#123;</span><br><span class="line">    id = hosta</span><br><span class="line">    secret = pwd_for_hosta</span><br><span class="line">  &#125;</span><br><span class="line">  ike_hostb &#123;</span><br><span class="line">    id = hostb</span><br><span class="line">    secret = pwd_for_hostb</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链接测试"><a href="#链接测试" class="headerlink" title="链接测试"></a>链接测试</h2><p>测试之前需要先检查一下 IP 掩码的长度，如果和我一样使用<code>/64</code>的话，可能会受到<code>bypass-lan</code>插件的干扰，导致数据不被加密。需要去<code>/etc/strongswan.d/charon/bypass-lan.conf</code>把它关掉。然后重启 strongSwan 即可。由于我们没有配置自动连接，所以启动 strongSwan 后数据流还是未加密的：</p><pre><code>23:50:29.873728 IP6 (flowlabel 0xe3038, hlim 64, next-header ICMPv6 (58) payload length: 64) fd00::1 &gt; fd00::2: [icmp6 sum ok] ICMP6, echo request, seq 1  0x0000:  600e 3038 0040 3a40 fd00 0000 0000 0000  `.08.@:@........  0x0010:  0000 0000 0000 0001 fd00 0000 0000 0000  ................  0x0020:  0000 0000 0000 0002 8000 02ec 001d 0001  ................  0x0030:  15ed 9c5f 0000 0000 0457 0d00 0000 0000  ..._.....W......  0x0040:  1011 1213 1415 1617 1819 1a1b 1c1d 1e1f  ................  0x0050:  2021 2223 2425 2627 2829 2a2b 2c2d 2e2f  .!&quot;#$%&amp;&apos;()*+,-./  0x0060:  3031 3233 3435 3637                      01234567</code></pre><p>需要使用 <code>swanctl</code> 手动建立连接：</p><pre><code>sudo swanctl -i -c child_sa</code></pre><p>你应该能看到 IKEv2 的四个 UDP 包，然后再 ping，数据就是加密的了：</p><pre><code>23:51:18.731508 IP6 (flowlabel 0xe3038, hlim 64, next-header ESP (50) payload length: 100) fd00::1 &gt; fd00::2: ESP(spi=0xc704dbda,seq=0x1), length 100  0x0000:  600e 3038 0064 3240 fd00 0000 0000 0000  `.08.d2@........  0x0010:  0000 0000 0000 0001 fd00 0000 0000 0000  ................  0x0020:  0000 0000 0000 0002 c704 dbda 0000 0001  ................  0x0030:  dc51 b5d7 bef1 bce6 da9d 74b2 7e6c 482d  .Q........t.~lH-  0x0040:  d9db 6e37 24d6 9fc6 10bb 525c e308 bc76  ..n7$.....R\...v  0x0050:  9d26 74d6 64ff ef55 5a54 5f95 94c7 01cf  .&amp;t.d..UZT_.....  0x0060:  2ae7 51b2 db41 439b 4d37 1f1e 3075 74d1  *.Q..AC.M7..0ut.  0x0070:  25dc 2990 8c07 b484 a37e b052 e5fc 8709  %.)......~.R....  0x0080:  e229 c79d 0816 0ae5 5c8b 652f            .)......\.e/</code></pre><h2 id="strongSwan-调试技巧"><a href="#strongSwan-调试技巧" class="headerlink" title="strongSwan 调试技巧"></a>strongSwan 调试技巧</h2><p>在 Archlinux 上，strongSwan 的日志级别控制在<code>/etc/strongswan.d/charon-systemd.conf</code>。另外，strongSwan 支持 NULL 加密（即不加密）以方便调试，将<code>proposals</code>和<code>esp_proposals</code>修改为如下值即可：</p><pre><code>proposals = null-sha-modp2048esp_proposals = null-sha-modp2048</code></pre><p>然后在 Wireshark 中选中 <code>Attempt to detect/decode NULL encrypted ESP payloads</code> 即可直接查看数据包内容：</p><p><img src="/images/ipsec-configurations-part1/null-encrypt-wireshark.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;俗话说得好，配置 IPsec 隧道只有零次和无数次，在被 strongSwan 折磨了 N 次以后，我终于决定要把之前试过的配置都记录下来，于是就有了这个系列。我计划基本上每个 PART 会介绍一个（或几个）特定场景下的配置，配置文件样例以 strongSwan vici 为主，之后可能会介绍 iOS, Android 或者是 Mikrotik 路由器的配置方法，&lt;del&gt;如果我能坚持不鸽写到那里的话（画外音：你这 FLAG 立得……）&lt;/del&gt; &lt;a href=&quot;/2021/01/ipsec-configurations-part9/&quot;&gt;FLAG 回收了&lt;/a&gt;。如果各位有想看的配置场景欢迎留言告诉我，会考虑先写。&lt;/p&gt;
&lt;h2 id=&quot;IKEv2-与-IPsec-基础&quot;&gt;&lt;a href=&quot;#IKEv2-与-IPsec-基础&quot; class=&quot;headerlink&quot; title=&quot;IKEv2 与 IPsec 基础&quot;&gt;&lt;/a&gt;IKEv2 与 IPsec 基础&lt;/h2&gt;&lt;p&gt;严格来说 IKEv2 不是 VPN，它的全称是 Internet Key Exchange，只是一种用于交换密钥的协议罢了。密钥在计算机里一般就表示为一串固定长度的二进制数据，密钥交换就是指在两台设备之间约定一个相同的二进制串，就像两个密友之间约定暗号一样。一旦密钥交换完毕，IKE 的使命就结束了，具体怎么用约定好的密钥加密数据不是 IKE 解决的问题。在 Linux 系统上，实际的数据包加密解密是由内核的 XFRM 框架负责的，你可以使用&lt;code&gt;ip xfrm&lt;/code&gt;命令看到配置好的密钥以及加解密使用的算法。事实上，不使用 IKEv2 而完全手动“交换”密钥是可行的，比如&lt;a href=&quot;https://gist.github.com/blackgear/a9f96261b091b2215dfd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;朴素VPN：一个纯内核级静态隧道&lt;/a&gt;。你可以看到作者直接使用&lt;code&gt;ip xfrm {policy,state} add&lt;/code&gt;指令设定密钥，然后内核就会自动用设定的密钥加密流量。&lt;/p&gt;
&lt;p&gt;然而，手动管理内核状态是复杂的，人工分发密钥也不怎么安全，这时就轮到 strongSwan 登场啦（或者说，任何实现了 IKE 的 Daemon 服务）。两台服务器的 strongSwan 使用 IKEv2 协议交换密钥，解决了密钥分发的问题。随后 strongSwan 会把交换得来的密钥设定进内核，这样内核就会自动加密指定的流量了。&lt;/p&gt;
&lt;p&gt;从数据包层面上看，IKE 是7层协议，密钥交换使用特殊的 UDP 包完成。而一般被加密的数据包会使用 ESP 封装，ESP 头一般紧跟在 IP 头后。ESP 也可以被封装进 UDP 用以穿越 NAT。&lt;/p&gt;
&lt;h2 id=&quot;没有-TUN-设备&quot;&gt;&lt;a href=&quot;#没有-TUN-设备&quot; class=&quot;headerlink&quot; title=&quot;没有 TUN 设备&quot;&gt;&lt;/a&gt;没有 TUN 设备&lt;/h2&gt;&lt;p&gt;内核 XFRM 的工作方式和基于 TUN 设备的 VPN 很不一样。一般基于 TUN 的 VPN 会加密所有进入 TUN 设备的流量，因此你可以直接使用路由表来控制哪些流量走 VPN，哪些不走。而 XFRM 的匹配基于策略（i.e. 源地址+目标地址+一些别的），如果某个数据包匹配到了一个策略，这个数据包就会根据这个策略指定的方式被加密。&lt;/p&gt;
&lt;p&gt;比方说有&lt;code&gt;A [fd00::1]&lt;/code&gt;和&lt;code&gt;B [fd00::2]&lt;/code&gt;，如果你从 A 发送一个数据包到 B，普通情况下这个数据包是明文的。如果你在 A 配置了&lt;code&gt;src=fd00::1,dst=fd00::2,encrypt=&amp;lt;...&amp;gt;&lt;/code&gt;的策略并再发一个数据包，这个包就会自动被加密。B 收到了这个数据包，但是它并不知道该如何解密，所以你必须同时在 B 配置一条&lt;code&gt;src=fd00::1,dst=fd00::2,decrypt=&amp;lt;...&amp;gt;&lt;/code&gt;的策略，这样 B 才能解密。对于从 B 到 A 的流量也需要类似的两条策略。使用 IKEv2 的话，这些策略 strongSwan 都会自动帮你设置好，无需操心。于是你会发现，尽管我们仍然在使用节点本身的 IP，但是流量却已经被加密了。&lt;/p&gt;
&lt;p&gt;对于那些必须使用路由表或是策略匹配不是很有效的场景, &lt;a href=&quot;https://wiki.strongswan.org/projects/strongswan/wiki/RouteBasedVPN&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Route-based IPsec VPN&lt;/a&gt; 也是存在的。我也许会在未来的某一期讲。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Networking" scheme="https://recursiveg.me/tags/Networking/"/>
    
      <category term="折腾" scheme="https://recursiveg.me/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="IPsec" scheme="https://recursiveg.me/tags/IPsec/"/>
    
      <category term="VPN" scheme="https://recursiveg.me/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>Linux + Windows 10 多系统安装 U 盘</title>
    <link href="https://recursiveg.me/2020/10/linux-windows-multiboot-usb/"/>
    <id>https://recursiveg.me/2020/10/linux-windows-multiboot-usb/</id>
    <published>2020-10-24T16:50:00.000Z</published>
    <updated>2020-11-05T00:06:24.634Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong><em>Update:</em></strong> Windows 的引导程序似乎有些问题，如果在同一块 U 盘上写入多个 ISO 分区的话，似乎引导会错乱，最终启动的安装程序版本不是引导程序所在分区的版本。所以暂时一个 U 盘还是只能放一个 Windows 版本。垃圾巨硬。</p></blockquote><p>日常折腾中总免不了要用 LiveCD 修理一下系统，或者是重装一下 Windows 之类的。这时候制作一个引导用的 U 盘基本是最方便的选项了。有不少工具都能创建 U 盘引导，比如 ArchLinux 的 ISO 镜像可以直接用<code>dd</code>写入，Windows 的安装盘也能用 <a href="https://rufus.ie" target="_blank" rel="noopener">Rufus</a> 创建。不过在使用上还是有些不便，比如<code>dd</code>会覆盖整个U盘，在ISO之外不能再存储其他文件。Rufus 只能在 Windows 上运行，而且一只 U 盘也只能放一份 ISO。于是尝试搞明白怎么把 Linux 的 LiveCD 和 Windows 的安装 ISO 写入到同一只 U 盘就很有必要了。</p><p>我个人使用的设备都支持 UEFI，所以这里制作的启动盘也只支持 UEFI 启动，需要 MBR 模式启动的读者请往它处寻。当然，Secure Boot 是要关掉的。制作过程我使用 Linux，纯 Windows 用户现在也可以退出了。基本上，我们需要创建一个 EFI 系统分区（EFI System Partition, ESP），其中包含基本的引导程序（Grub2）和 Linux LiveCD 的 ISO 文件。由于 Windows 的安装程序无法以 ISO 形式被引导，因此我们需要给每个 Windows ISO 文件创建一个分区，并将 ISO 中的内容解压进去。但是分区一旦创建不像文件那么好修改，所以创建每个 Windows ISO 分区的时候我都留了一些额外空间，以备以后 ISO 大小变化，这也意味着这些空间就基本浪费了。That&#39;s sad but I guess it&#39;s how things work.</p><p>另外，购买一个优质的 U 盘还是有必要的，不然不管是创建启动盘还是安装系统都会慢得让你痛不欲生。建议用之前先给 U 盘测一下速，什么拷贝速度只有 2MB/s 的金士顿可以直接进垃圾桶了。至于 U 盘大小取决于你要放多少个 ISO 文件和多少个 Windows 分区，一般 Linux 镜像大小在 500MB~3GB 的都有，Windows 10 的分区一般每个需要 5~6GB.</p><a id="more"></a><p>先给 U 盘分区，用<code>fdisk</code>或者别的什么工具都行。我用的 32GB 的 U 盘，分了 6GB 给 ESP，然后是另外两个 6GB 的分区给 Windows 10 的安装程序。剩下空间留着给以后使用。</p><p>然后格式化，ESP 需要 FAT32，Windows 分区用 NTFS 即可。记得多次检查盘符，不然格式化错盘就不好玩了。我给 NTFS 设置的卷标和 ISO 的一致，可以用<code>file &lt;img.iso&gt;</code>看到，不过我不确定这是不是必须的。</p><pre><code>sudo mkfs.fat -F 32 /dev/sdXYsudo mkfs.ntfs -f -L CPBA_X64FRE_ZH-CN_DV9 /dev/sdXY</code></pre><p>然后把 GRUB2 安装到 ESP 分区上，假设你的 ESP 分区挂载在了<code>$esp</code>:</p><pre><code>sudo grub-install --target=x86_64-efi --removable --boot-directory=$esp/boot --efi-directory=$esp</code></pre><p>接着复制 ISO 文件到 U 盘。Linux 的 ISO 可以直接放在 ESP 分区里的任意位置，我放在了<code>$esp/boot/iso/</code>。Windows ISO 需要用 7z 之类的工具解压到 NTFS 分区里：</p><pre><code>7z x cn_windows_10_business_editions_version_1909_updated_dec_2019_x64_dvd_262ac8af.iso -o&apos;/run/media/recursiveg/CPBA_X64FRE_ZH-CN_DV9&apos;</code></pre><p>最后需要手工编写<code>$esp/boot/grub/grub.cfg</code>文件。我从我系统的配置里复制了一部分图形初始化的指令，然后写了用来引导 LiveCD 和 Windows 的菜单项。一般每个发行版的启动命令都会不一样，需要自己查询。Windows 启动项中<code>search</code>的<code>--label</code>参数需要和格式化时设置的一样，当然你也可以用 UUID 等别的标识符。我还另外拷贝了一个 UEFI Shell 到 U 盘里。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># copied from arch boot config</span></span><br><span class="line"><span class="keyword">function</span> load_video &#123;</span><br><span class="line">  <span class="keyword">if</span> [ x<span class="variable">$feature_all_video_module</span> = xy ]; <span class="keyword">then</span></span><br><span class="line">    insmod all_video</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    insmod efi_gop</span><br><span class="line">    insmod efi_uga</span><br><span class="line">    insmod ieee1275_fb</span><br><span class="line">    insmod vbe</span><br><span class="line">    insmod vga</span><br><span class="line">    insmod video_bochs</span><br><span class="line">    insmod video_cirrus</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> loadfont unicode ; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">set</span> gfxmode=auto</span><br><span class="line">  load_video</span><br><span class="line">  insmod gfxterm</span><br><span class="line">  <span class="built_in">set</span> locale_dir=<span class="variable">$prefix</span>/locale</span><br><span class="line">  <span class="comment">#set lang=zh_CN</span></span><br><span class="line">  insmod gettext</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">insmod part_gpt</span><br><span class="line">insmod search_fs_uuid</span><br><span class="line"></span><br><span class="line"><span class="comment"># path to the partition holding ISO images (using UUID)</span></span><br><span class="line">probe -u <span class="variable">$root</span> --<span class="built_in">set</span>=rootuuid</span><br><span class="line"><span class="built_in">set</span> imgdevpath=<span class="string">"/dev/disk/by-uuid/<span class="variable">$rootuuid</span>"</span></span><br><span class="line"></span><br><span class="line">menuentry <span class="string">'archlinux-2020.10.01-x86_64.iso'</span> &#123;</span><br><span class="line">  <span class="built_in">set</span> isofile=<span class="string">'/boot/iso/archlinux-2020.10.01-x86_64.iso'</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">'Mounting archlinux-2020.10.01-x86_64.iso ...'</span></span><br><span class="line">  loopback loop <span class="variable">$isofile</span></span><br><span class="line">  linux (loop)/arch/boot/x86_64/vmlinuz-linux img_dev=<span class="variable">$imgdevpath</span> img_loop=<span class="variable">$isofile</span> earlymodules=loop</span><br><span class="line">  initrd (loop)/arch/boot/intel-ucode.img (loop)/arch/boot/amd-ucode.img (loop)/arch/boot/x86_64/initramfs-linux.img</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">menuentry <span class="string">"ubuntu-20.04.1-desktop-amd64.iso"</span> &#123;</span><br><span class="line">  <span class="built_in">set</span> isofile=<span class="string">"/boot/iso/ubuntu-20.04.1-desktop-amd64.iso"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">'Mounting ubuntu-20.04.1-desktop-amd64.iso ...'</span></span><br><span class="line">  loopback loop <span class="variable">$isofile</span></span><br><span class="line">  linux (loop)/casper/vmlinuz boot=casper iso-scan/filename=<span class="variable">$isofile</span> noprompt noeject</span><br><span class="line">  initrd (loop)/casper/initrd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">menuentry <span class="string">"Windows 10 Installer (CN Business editions 1909 Dec 2019)"</span> &#123;</span><br><span class="line">  insmod ntfs</span><br><span class="line">  search --no-floppy --<span class="built_in">set</span>=root --label CPBA_X64FRE_ZH-CN_DV9</span><br><span class="line">  chainloader /efi/boot/bootx64.efi</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Booting windows ..."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">menuentry <span class="string">"Windows 10 Installer (CN Oct 2020)"</span> &#123;</span><br><span class="line">  insmod ntfs</span><br><span class="line">  search --no-floppy --<span class="built_in">set</span>=root --label CCCOMA_X64FRE_ZH-CN_DV9</span><br><span class="line">  chainloader /efi/boot/bootx64.efi</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Booting windows ..."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">menuentry <span class="string">"shellx64_v2.efi"</span> &#123;</span><br><span class="line">  chainloader /boot/shellx64_v2.efi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">menuentry <span class="string">"Enter BIOS setup"</span> &#123;</span><br><span class="line">  fwsetup</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全部设置好以后可以用虚拟机测试一下是不是所有项目都能正常启动，如果都没有问题就 OK 了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Update:&lt;/em&gt;&lt;/strong&gt; Windows 的引导程序似乎有些问题，如果在同一块 U 盘上写入多个 ISO 分区的话，似乎引导会错乱，最终启动的安装程序版本不是引导程序所在分区的版本。所以暂时一个 U 盘还是只能放一个 Windows 版本。垃圾巨硬。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;日常折腾中总免不了要用 LiveCD 修理一下系统，或者是重装一下 Windows 之类的。这时候制作一个引导用的 U 盘基本是最方便的选项了。有不少工具都能创建 U 盘引导，比如 ArchLinux 的 ISO 镜像可以直接用&lt;code&gt;dd&lt;/code&gt;写入，Windows 的安装盘也能用 &lt;a href=&quot;https://rufus.ie&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Rufus&lt;/a&gt; 创建。不过在使用上还是有些不便，比如&lt;code&gt;dd&lt;/code&gt;会覆盖整个U盘，在ISO之外不能再存储其他文件。Rufus 只能在 Windows 上运行，而且一只 U 盘也只能放一份 ISO。于是尝试搞明白怎么把 Linux 的 LiveCD 和 Windows 的安装 ISO 写入到同一只 U 盘就很有必要了。&lt;/p&gt;
&lt;p&gt;我个人使用的设备都支持 UEFI，所以这里制作的启动盘也只支持 UEFI 启动，需要 MBR 模式启动的读者请往它处寻。当然，Secure Boot 是要关掉的。制作过程我使用 Linux，纯 Windows 用户现在也可以退出了。基本上，我们需要创建一个 EFI 系统分区（EFI System Partition, ESP），其中包含基本的引导程序（Grub2）和 Linux LiveCD 的 ISO 文件。由于 Windows 的安装程序无法以 ISO 形式被引导，因此我们需要给每个 Windows ISO 文件创建一个分区，并将 ISO 中的内容解压进去。但是分区一旦创建不像文件那么好修改，所以创建每个 Windows ISO 分区的时候我都留了一些额外空间，以备以后 ISO 大小变化，这也意味着这些空间就基本浪费了。That&amp;#39;s sad but I guess it&amp;#39;s how things work.&lt;/p&gt;
&lt;p&gt;另外，购买一个优质的 U 盘还是有必要的，不然不管是创建启动盘还是安装系统都会慢得让你痛不欲生。建议用之前先给 U 盘测一下速，什么拷贝速度只有 2MB/s 的金士顿可以直接进垃圾桶了。至于 U 盘大小取决于你要放多少个 ISO 文件和多少个 Windows 分区，一般 Linux 镜像大小在 500MB~3GB 的都有，Windows 10 的分区一般每个需要 5~6GB.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="折腾" scheme="https://recursiveg.me/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="装机" scheme="https://recursiveg.me/tags/%E8%A3%85%E6%9C%BA/"/>
    
      <category term="Windows" scheme="https://recursiveg.me/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>在 Raspberry Pi 4B 上安装 ArchLinux</title>
    <link href="https://recursiveg.me/2020/10/archlinux-on-raspberrypi-4b/"/>
    <id>https://recursiveg.me/2020/10/archlinux-on-raspberrypi-4b/</id>
    <published>2020-10-03T05:50:00.000Z</published>
    <updated>2020-10-30T03:57:48.330Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/archlinux-on-raspberrypi-4b/01-neofetch.png" alt="Neofetch"><br>很久之前就买了一个树莓派，不过一直在吃灰，正好最近有空就再拿出来折腾一下。原装系统是 32 位的，那么就必定要换一个 64 位的啦，不然对不起这 64 位的 CPU 呀。秉承“Arch大法好”的理念，我就决定用 Archlinux ARM 了。我非常建议先用原版系统<a href="https://www.raspberrypi.org/documentation/hardware/raspberrypi/booteeprom.md" target="_blank" rel="noopener">更新 Bootloader 和 EEPROM</a>到最新版本。这样可以避免各种奇怪的 bug 和使用一些新加入的功能，比如从网络启动什么的。</p><p>ArchLinux ARM 其实已经提供了<a href="https://archlinuxarm.org/platforms/armv8/broadcom/raspberry-pi-4" target="_blank" rel="noopener">树莓派的安装教程</a>，基本上只要跟着做即可，我用的是 AArch64 镜像，并且把根文件系统从 ext4 换成了 f2fs，希望在 SD 卡上能有一点点加成效果。装完以后发现串口没有输出，自然不能忍，继续折腾。RPi 4B 一共有<a href="https://www.raspberrypi.org/documentation/configuration/uart.md" target="_blank" rel="noopener">两个串口控制器</a>，一个 PL011，另一个被称作 MiniUART。默认情况下，PL011 连接到蓝牙模块，并且 MiniUART 被禁用，但是我们可以通过 <a href="https://www.raspberrypi.org/documentation/configuration/config-txt/README.md" target="_blank" rel="noopener"><code>config.txt</code> 加载 dtb overlay</a> 来调整。一些常见的配置有：</p><ul><li>启用 MiniUART 串口，PL011 继续负责蓝牙</li><li>禁用蓝牙，让 PL011 负责串口通信</li><li>启用 MiniUART，让 MiniUART 负责蓝牙，PL011 负责串口</li></ul><p>但是 ArchLinux ARM 使用 U-Boot 来启动内核，并不遵循 config.txt (╯°Д°)╯ ┻━┻</p><p>那么我们只能把 U-Boot 干掉了 （&lt;ゝω・）☆</p><a id="more"></a><h2 id="使用-MiniUART-作为串口"><a href="#使用-MiniUART-作为串口" class="headerlink" title="使用 MiniUART 作为串口"></a>使用 MiniUART 作为串口</h2><p>SD 卡的 <a href="https://www.raspberrypi.org/documentation/configuration/boot_folder.md" target="_blank" rel="noopener"><code>\boot</code> 目录</a>里需要这么7个文件，RPi 4B 的 bootloader 才好启动 Linux 内核：</p><ul><li><code>config.txt</code>: 主要配置文件，<code>uboot-raspberrypi</code> 有提供，但是我们手写。</li><li><code>start4.elf</code> 和 <code>fixup4.dat</code>: 第二阶段 Bootloader, 由 <code>raspberrypi-bootloader</code> 包提供。</li><li><code>rpi4.dtb</code>: RPi 4B 的 Device Tree 文件, <code>linux-aarch64</code> 包中提供了一个基于上游代码的，位于 <code>/boot/dtbs</code>。但是我试了几次都不能正常启动，所以还是从 Raspberry Pi <a href="https://github.com/raspberrypi/firmware/releases" target="_blank" rel="noopener">官方的 Github</a> 下载了一份。</li><li><code>Image</code>: 内核可执行文件，由 <code>linux-aarch64</code> 包提供。</li><li><code>initramfs-linux.img</code>：由 <code>mkinitcpio</code> 程序生成。</li><li><code>cmdline.txt</code>: 内核参数文件，手写。</li></ul><p>那么直接上配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enable_uart&#x3D;1                               # 启用 MiniUART</span><br><span class="line">kernel&#x3D;Image                                # 指定内核文件的名称</span><br><span class="line">arm_64bit&#x3D;1                                 # 要求以 64 位模式启动，否则默认是 32 位</span><br><span class="line">device_tree&#x3D;rpi4.dtb                        # Github 上的 bcm2711-rpi-4-b.dtb 文件，我改了个名</span><br><span class="line">initramfs initramfs-linux.img followkernel  # 指定 initramfs 文件</span><br></pre></td></tr></table></figure><p><code>start4.elf</code>、<code>fixup4.dat</code> 和 <code>cmdline.txt</code> 都是原名，就无需写进 <code>config.txt</code> 里了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console&#x3D;serial0,115200 root&#x3D;PARTUUID&#x3D;e10d384f-02 rootfstype&#x3D;f2fs rootflags&#x3D;rw elevator&#x3D;deadline audit&#x3D;0 rootwait</span><br></pre></td></tr></table></figure><ul><li><code>PARTUUID</code> 需要改成你自己的，可以用 <code>sudo blkid</code> 查看</li><li><code>rootflags</code> f2fs 似乎默认以只读挂载，会导致没有办法登录。</li><li><code>audit=0</code> 关掉 audit，否则内核信息撒得满地都是。</li></ul><p>全部折腾完以后把 SD 卡塞进树莓派，应该就能在串口看到登录界面了。</p><h2 id="使用-PL011-作为串口"><a href="#使用-PL011-作为串口" class="headerlink" title="使用 PL011 作为串口"></a>使用 PL011 作为串口</h2><p>我在安装的时候碰到一个 MiniUART 的 BUG，串口的 Baudrate 不对，内核输出一片乱码。可以尝试使用 PL011 作为串口，也可以升级内核解决。使用 PL011 需要在 boot 分区里加一个新的文件</p><ul><li><code>overlays/disable-bt.dtbo</code>: 需要从 Github 上下载，用来禁用蓝牙，并且让 PL011 负责串口通信。</li></ul><p>同时需要修改 config.txt 加上 <code>dtoverlay=disable-bt</code> 以启用。此时 <code>enable_uart=1</code> 不再是必要的了。</p><h2 id="登录之后"><a href="#登录之后" class="headerlink" title="登录之后"></a>登录之后</h2><p>登录之后建议先把 <code>uboot-raspberrypi</code> 卸了，然后 dhcpcd 连上网 <code>pacman -Syu</code> 一下，再重启确认一下启动过程都正常。之后就是标准的 ArchLinux 服务器配置过程：时区, 网络, 防火墙, etc. 搞定以后我们就有一台 AArch64 服务器了。</p><p>暂时没有 GUI 的需求，相关的配置就留到下次再折腾了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/archlinux-on-raspberrypi-4b/01-neofetch.png&quot; alt=&quot;Neofetch&quot;&gt;&lt;br&gt;很久之前就买了一个树莓派，不过一直在吃灰，正好最近有空就再拿出来折腾一下。原装系统是 32 位的，那么就必定要换一个 64 位的啦，不然对不起这 64 位的 CPU 呀。秉承“Arch大法好”的理念，我就决定用 Archlinux ARM 了。我非常建议先用原版系统&lt;a href=&quot;https://www.raspberrypi.org/documentation/hardware/raspberrypi/booteeprom.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;更新 Bootloader 和 EEPROM&lt;/a&gt;到最新版本。这样可以避免各种奇怪的 bug 和使用一些新加入的功能，比如从网络启动什么的。&lt;/p&gt;
&lt;p&gt;ArchLinux ARM 其实已经提供了&lt;a href=&quot;https://archlinuxarm.org/platforms/armv8/broadcom/raspberry-pi-4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;树莓派的安装教程&lt;/a&gt;，基本上只要跟着做即可，我用的是 AArch64 镜像，并且把根文件系统从 ext4 换成了 f2fs，希望在 SD 卡上能有一点点加成效果。装完以后发现串口没有输出，自然不能忍，继续折腾。RPi 4B 一共有&lt;a href=&quot;https://www.raspberrypi.org/documentation/configuration/uart.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;两个串口控制器&lt;/a&gt;，一个 PL011，另一个被称作 MiniUART。默认情况下，PL011 连接到蓝牙模块，并且 MiniUART 被禁用，但是我们可以通过 &lt;a href=&quot;https://www.raspberrypi.org/documentation/configuration/config-txt/README.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;config.txt&lt;/code&gt; 加载 dtb overlay&lt;/a&gt; 来调整。一些常见的配置有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启用 MiniUART 串口，PL011 继续负责蓝牙&lt;/li&gt;
&lt;li&gt;禁用蓝牙，让 PL011 负责串口通信&lt;/li&gt;
&lt;li&gt;启用 MiniUART，让 MiniUART 负责蓝牙，PL011 负责串口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是 ArchLinux ARM 使用 U-Boot 来启动内核，并不遵循 config.txt (╯°Д°)╯ ┻━┻&lt;/p&gt;
&lt;p&gt;那么我们只能把 U-Boot 干掉了 （&amp;lt;ゝω・）☆&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="折腾" scheme="https://recursiveg.me/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="硬件" scheme="https://recursiveg.me/tags/%E7%A1%AC%E4%BB%B6/"/>
    
      <category term="树莓派" scheme="https://recursiveg.me/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>MikroTik RB4011 访客网络配置备忘</title>
    <link href="https://recursiveg.me/2020/07/mikrotik-rb4011-setup-memo/"/>
    <id>https://recursiveg.me/2020/07/mikrotik-rb4011-setup-memo/</id>
    <published>2020-07-03T04:30:00.000Z</published>
    <updated>2020-07-03T23:06:13.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/images/mikrotik-rb4011-setup-memo/0-speedtest.png" alt="Speedtest"><br>由于之前陆陆续续添置了不少电子设备，以及更换 ISP 的原因，机架上连了5台设备，每台各负责一点点事情，不管是配置还是调试都很麻烦。再加上旧路由器不能很好同时处理千兆 NAT 和 VLAN，于是最近入手了一台 <a href="https://mikrotik.com/product/rb4011igs_5hacq2hnd_in" target="_blank" rel="noopener">RB4011iGS+5HacQ2HnD-IN</a>，把这一堆乱七八糟的设备统统换掉。主要需求有三点：</p><ol><li>划分2个 VLAN，一个内部网络，一个访客网络。</li><li>IPv4 和 IPv6 双栈接入。</li><li>因为路由器直接暴露在 Internet 上了，所以防火墙一定要配好，包括 VLAN 之间的访问也是靠防火墙来控制的。</li></ol><a id="more"></a><h1 id="端口及-VLAN-配置"><a href="#端口及-VLAN-配置" class="headerlink" title="端口及 VLAN 配置"></a>端口及 VLAN 配置</h1><p>MikroTik 家的路由器的二层交换配置是比较不统一的。受限制于不同产品的硬件，想要完全利用硬件交换，不同的型号在 Bridge 的设定上都略有不同。建议到 <a href="https://wiki.mikrotik.com/wiki/Manual:Switch_Chip_Features" target="_blank" rel="noopener">MikroTik Wiki: Switch Chip Features</a> 页面查询具体型号的配置方法。由于我的大部分内网流量还是要过 CPU 三层路由的，所以我没有在这一点上做特别优化，反正 RB4011 的性能够用。我这里以两个 VLAN，每个 VLAN 里各有一个 Ethernet 接口和一个 Wireless 接口为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;interface wireless</span><br><span class="line"># 修改内部无线网络接口 VLAN ID 为 900</span><br><span class="line">set [ find default-name&#x3D;wlan1 ] name&#x3D;wlan5g vlan-id&#x3D;900 vlan-mode&#x3D;use-tag &lt;...其他参数省略...&gt;</span><br><span class="line"># 增加访客无线网络接口 VLAN ID 为 200</span><br><span class="line">add master-interface&#x3D;wlan5g name&#x3D;wlan5g_guest vlan-id&#x3D;200 vlan-mode&#x3D;use-tag &lt;...其他参数省略...&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;interface bridge</span><br><span class="line"># 新建网桥，注意这个网桥自己的 VLAN ID 我们用不到，所以填什么都可以</span><br><span class="line">add frame-types&#x3D;admit-only-vlan-tagged ingress-filtering&#x3D;yes name&#x3D;LAN protocol-mode&#x3D;none pvid&#x3D;900 vlan-filtering&#x3D;yes</span><br><span class="line"></span><br><span class="line">&#x2F;interface bridge port</span><br><span class="line"># 把两个无线和两个有线都加进桥</span><br><span class="line">add bridge&#x3D;LAN frame-types&#x3D;admit-only-vlan-tagged ingress-filtering&#x3D;yes interface&#x3D;wlan5g pvid&#x3D;900</span><br><span class="line">add bridge&#x3D;LAN frame-types&#x3D;admit-only-vlan-tagged ingress-filtering&#x3D;yes interface&#x3D;wlan5g_guest pvid&#x3D;200</span><br><span class="line">add bridge&#x3D;LAN frame-types&#x3D;admit-only-untagged-and-priority-tagged ingress-filtering&#x3D;yes interface&#x3D;ether2_nas pvid&#x3D;900</span><br><span class="line">add bridge&#x3D;LAN frame-types&#x3D;admit-only-untagged-and-priority-tagged ingress-filtering&#x3D;yes interface&#x3D;ether3 pvid&#x3D;200</span><br><span class="line"></span><br><span class="line">&#x2F;interface bridge vlan</span><br><span class="line"># 配置桥的 VLAN 转发表</span><br><span class="line">add bridge&#x3D;LAN vlan-ids&#x3D;900 tagged&#x3D;LAN,wlan5g untagged&#x3D;ether2_nas</span><br><span class="line">add bridge&#x3D;LAN vlan-ids&#x3D;200 tagged&#x3D;LAN,wlan5g_guest untagged&#x3D;ether3</span><br><span class="line"></span><br><span class="line">&#x2F;interface vlan</span><br><span class="line"># 在桥上新建两个 VLAN 接口，之后 IP 地址以及 DHCP 服务器就分配给它们</span><br><span class="line">add interface&#x3D;LAN name&#x3D;LAN.guest vlan-id&#x3D;200</span><br><span class="line">add interface&#x3D;LAN name&#x3D;LAN.trusted vlan-id&#x3D;900</span><br><span class="line"></span><br><span class="line">&#x2F;ip address</span><br><span class="line"># 分配 IP</span><br><span class="line">add address&#x3D;192.168.9.1&#x2F;24 interface&#x3D;LAN.trusted network&#x3D;192.168.9.0</span><br><span class="line">add address&#x3D;192.168.2.1&#x2F;24 interface&#x3D;LAN.guest network&#x3D;192.168.2.0</span><br></pre></td></tr></table></figure><h1 id="DHCP-配置"><a href="#DHCP-配置" class="headerlink" title="DHCP 配置"></a>DHCP 配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># IPv4 DHCP 客户端</span><br><span class="line">&#x2F;ip dhcp-client</span><br><span class="line">add !dhcp-options disabled&#x3D;no interface&#x3D;ether1_ont use-peer-dns&#x3D;no use-peer-ntp&#x3D;no</span><br><span class="line"></span><br><span class="line"># IPv4 DHCP 服务器</span><br><span class="line">&#x2F;ip pool</span><br><span class="line">add name&#x3D;dhcp_trusted ranges&#x3D;192.168.9.200-192.168.9.250</span><br><span class="line">add name&#x3D;dhcp_guest ranges&#x3D;192.168.2.200-192.168.2.250</span><br><span class="line">&#x2F;ip dhcp-server</span><br><span class="line">add address-pool&#x3D;dhcp_trusted disabled&#x3D;no interface&#x3D;LAN.trusted name&#x3D;dhcp_trusted</span><br><span class="line">add address-pool&#x3D;dhcp_guest disabled&#x3D;no interface&#x3D;LAN.guest name&#x3D;dhcp_guest</span><br><span class="line">&#x2F;ip dhcp-server network</span><br><span class="line">add address&#x3D;192.168.2.0&#x2F;24 gateway&#x3D;192.168.2.1</span><br><span class="line">add address&#x3D;192.168.9.0&#x2F;24 gateway&#x3D;192.168.9.1</span><br><span class="line"></span><br><span class="line"># DHCPv6 获取前缀</span><br><span class="line">&#x2F;ipv6 dhcp-client</span><br><span class="line">add add-default-route&#x3D;yes interface&#x3D;ether1_ont pool-name&#x3D;ipv6_ont_pool request&#x3D;prefix use-peer-dns&#x3D;no</span><br><span class="line"></span><br><span class="line"># 配置 IPv6 SLAAC</span><br><span class="line">&#x2F;ipv6 address</span><br><span class="line">add from-pool&#x3D;ipv6_ont_pool interface&#x3D;LAN.trusted</span><br><span class="line">add from-pool&#x3D;ipv6_ont_pool interface&#x3D;LAN.guest</span><br></pre></td></tr></table></figure><h1 id="IPv4-防火墙配置"><a href="#IPv4-防火墙配置" class="headerlink" title="IPv4 防火墙配置"></a>IPv4 防火墙配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;ip firewall nat</span><br><span class="line">add action&#x3D;masquerade chain&#x3D;srcnat ipsec-policy&#x3D;out,none out-interface&#x3D;ether1_ont comment&#x3D;&quot;NAT&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;ip firewall filter</span><br><span class="line">add action&#x3D;accept chain&#x3D;input comment&#x3D;&quot;defconf: accept established,related,untracked&quot; connection-state&#x3D;established,related,untracked</span><br><span class="line">add action&#x3D;drop chain&#x3D;input comment&#x3D;&quot;defconf: drop invalid&quot; connection-state&#x3D;invalid</span><br><span class="line">add action&#x3D;drop chain&#x3D;input comment&#x3D;&quot;非内部网络不可访问路由器&quot; in-interface&#x3D;!LAN.trusted</span><br><span class="line"></span><br><span class="line">add action&#x3D;accept chain&#x3D;forward comment&#x3D;&quot;defconf: accept in ipsec policy&quot; ipsec-policy&#x3D;in,ipsec</span><br><span class="line">add action&#x3D;accept chain&#x3D;forward comment&#x3D;&quot;defconf: accept out ipsec policy&quot; ipsec-policy&#x3D;out,ipsec</span><br><span class="line">add action&#x3D;fasttrack-connection chain&#x3D;forward comment&#x3D;&quot;defconf: fasttrack&quot; connection-state&#x3D;established,related</span><br><span class="line">add action&#x3D;accept chain&#x3D;forward comment&#x3D;&quot;defconf: accept established,related, untracked&quot; connection-state&#x3D;established,related,untracked</span><br><span class="line">add action&#x3D;drop chain&#x3D;forward comment&#x3D;&quot;defconf: drop invalid&quot; connection-state&#x3D;invalid</span><br><span class="line">add action&#x3D;drop chain&#x3D;forward comment&#x3D;&quot;defconf: drop all from ether1 not DSTNATed&quot; connection-nat-state&#x3D;!dstnat connection-state&#x3D;new in-interface&#x3D;ether1_ont</span><br><span class="line">add action&#x3D;drop chain&#x3D;forward comment&#x3D;&quot;其他 VLAN 不可访问内部 VLAN&quot; out-interface&#x3D;LAN.trusted</span><br><span class="line">add action&#x3D;drop chain&#x3D;forward comment&#x3D;&quot;访客 VLAN 不可访问除 Internet 以外的网络&quot; in-interface&#x3D;LAN.guest out-interface&#x3D;!ether1_ont</span><br></pre></td></tr></table></figure><h1 id="IPv6-防火墙配置"><a href="#IPv6-防火墙配置" class="headerlink" title="IPv6 防火墙配置"></a>IPv6 防火墙配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;ipv6 firewall filter</span><br><span class="line">add action&#x3D;accept chain&#x3D;input comment&#x3D;&quot;defconf: accept established,related,untracked&quot; connection-state&#x3D;established,related,untracked</span><br><span class="line">add action&#x3D;drop chain&#x3D;input comment&#x3D;&quot;defconf: drop invalid&quot; connection-state&#x3D;invalid</span><br><span class="line">add action&#x3D;accept chain&#x3D;input comment&#x3D;&quot;允许所有 ICMPv6 报文&quot; protocol&#x3D;icmpv6</span><br><span class="line">add action&#x3D;accept chain&#x3D;input comment&#x3D;&quot;允许 DHCPv6 前缀分配报文&quot; dst-port&#x3D;546 protocol&#x3D;udp src-address&#x3D;fe80::&#x2F;16</span><br><span class="line">add action&#x3D;drop chain&#x3D;input comment&#x3D;&quot;非内部网络不可访问路由器&quot; in-interface&#x3D;!LAN.trusted</span><br><span class="line"></span><br><span class="line">add action&#x3D;accept chain&#x3D;forward comment&#x3D;&quot;defconf: accept in ipsec policy&quot; ipsec-policy&#x3D;in,ipsec</span><br><span class="line">add action&#x3D;accept chain&#x3D;forward comment&#x3D;&quot;defconf: accept out ipsec policy&quot; ipsec-policy&#x3D;out,ipsec</span><br><span class="line">add action&#x3D;accept chain&#x3D;forward comment&#x3D;&quot;defconf: accept established,related, untracked&quot; connection-state&#x3D;established,related,untracked</span><br><span class="line">add action&#x3D;drop chain&#x3D;forward comment&#x3D;&quot;defconf: drop invalid&quot; connection-state&#x3D;invalid</span><br><span class="line">add action&#x3D;accept chain&#x3D;forward comment&#x3D;&quot;允许访问互联网&quot; out-interface&#x3D;ether1_ont</span><br><span class="line">add action&#x3D;drop chain&#x3D;forward comment&#x3D;&quot;拒绝所有其他转发流量&quot;</span><br></pre></td></tr></table></figure><h1 id="测试总结"><a href="#测试总结" class="headerlink" title="测试总结"></a>测试总结</h1><p>配置完了以后我对这一套设备还是挺满意的。在 IPv6 没有 Fasttrack 只能纯 CPU 转发的情况下，双向同时 900Mbps 测速，CPU 占用在 80% 左右。发热也没有什么感觉，反正平时一直丢角落里，估计整台机器最烫的部分就是那个 SFP+ 的万兆收发器了吧。</p><p><img src="/images/mikrotik-rb4011-setup-memo/1-final-setup.jpg" alt="Final"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/mikrotik-rb4011-setup-memo/0-speedtest.png&quot; alt=&quot;Speedtest&quot;&gt;&lt;br&gt;由于之前陆陆续续添置了不少电子设备，以及更换 ISP 的原因，机架上连了5台设备，每台各负责一点点事情，不管是配置还是调试都很麻烦。再加上旧路由器不能很好同时处理千兆 NAT 和 VLAN，于是最近入手了一台 &lt;a href=&quot;https://mikrotik.com/product/rb4011igs_5hacq2hnd_in&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RB4011iGS+5HacQ2HnD-IN&lt;/a&gt;，把这一堆乱七八糟的设备统统换掉。主要需求有三点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;划分2个 VLAN，一个内部网络，一个访客网络。&lt;/li&gt;
&lt;li&gt;IPv4 和 IPv6 双栈接入。&lt;/li&gt;
&lt;li&gt;因为路由器直接暴露在 Internet 上了，所以防火墙一定要配好，包括 VLAN 之间的访问也是靠防火墙来控制的。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Life" scheme="https://recursiveg.me/categories/Life/"/>
    
    
      <category term="Networking" scheme="https://recursiveg.me/tags/Networking/"/>
    
      <category term="装机" scheme="https://recursiveg.me/tags/%E8%A3%85%E6%9C%BA/"/>
    
      <category term="RouterOS" scheme="https://recursiveg.me/tags/RouterOS/"/>
    
      <category term="MikroTik" scheme="https://recursiveg.me/tags/MikroTik/"/>
    
  </entry>
  
  <entry>
    <title>WinRAR 恢复记录添加及使用教程</title>
    <link href="https://recursiveg.me/2020/04/winrar-best-practice/"/>
    <id>https://recursiveg.me/2020/04/winrar-best-practice/</id>
    <published>2020-04-09T14:30:00.000Z</published>
    <updated>2020-10-30T03:49:49.971Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文中的所有图片及文字均使用 CC0 发布，可任意转载使用。</p></blockquote><p>本文属于疫情期间的摸鱼之作，旨在推广 RAR 压缩格式的正确压缩方法，让资源分享更轻松一些。</p><h1 id="获取-WinRAR"><a href="#获取-WinRAR" class="headerlink" title="获取 WinRAR"></a>获取 WinRAR</h1><p>先说一下为什么用 WinRAR 而不用 7zip, 因为 7zip 没有恢复记录。在百度网盘等平台分享文件时，文件可能发生损坏，没有恢复记录的话只能尝试重新下载浪费时间，而有恢复记录的话有大概率可以成功修复，正确解压。</p><p>国内特供版的 WinRAR 可以免费使用，但是有广告。如果不想要广告，你可以从以下链接下载官方无广告简体中文版</p><pre><code>https://www.win-rar.com/fileadmin/winrar-versions/sc/sc20200409/rrlb/winrar-x64-590sc.exe</code></pre><p>注意，如果你没有<code>rarreg.key</code>文件进行注册的话依然是有广告的。至于具体的注册方法请自行搜寻。</p><a id="more"></a><h1 id="添加恢复记录"><a href="#添加恢复记录" class="headerlink" title="添加恢复记录"></a>添加恢复记录</h1><p>恢复记录需要在创建压缩文件时添加，你需要先勾选<code>添加恢复记录</code>复选框。<br><img src="/images/winrar-best-practice/01-check-add-rr-box.png" alt="添加恢复记录"><br>然后检查恢复记录的百分比设置。<br><img src="/images/winrar-best-practice/02-rr-percentile.png" alt="检查恢复记录大小"><br>对于大于 100MB 的大型文件文件来说，默认的 3% 足够使用。如果你的文件非常小，比如只有 几MB 或者 十几MB 你可以考虑增加到 5%。增大这项设置会同时增大文件体积，因此不建议设置得过大，尤其是对于几个 GB 的文件来说。如果你在压缩时忘记添加恢复记录或者是想要修改恢复记录的大小，也可以在事后进行操作：<br><img src="/images/winrar-best-practice/03-modify-rr-percentile.png" alt="修改恢复记录大小"></p><h1 id="损坏压缩文件的修复"><a href="#损坏压缩文件的修复" class="headerlink" title="损坏压缩文件的修复"></a>损坏压缩文件的修复</h1><p>如果你在解压时遇到“校验和错误”，那么你下载到的压缩文件就是损坏了：<br><img src="/images/winrar-best-practice/04-broken-file-example.png" alt=""><br>你可以使用“工具”菜单尝试修复它。修复操作会生成一个新的，修复好的压缩包，你需要选择这个新文件的保存位置：<br><img src="/images/winrar-best-practice/05-select-fixed-save-location.png" alt=""><br>稍等片刻就会生成一个修复后的文件：<br><img src="/images/winrar-best-practice/06-fixed-file.png" alt=""><br>你也有可能在修复过程中遇到错误，但只要修复后的文件可以正确解压不报错，就没有问题。<br>但是只有添加了恢复记录的文件可以使用修复操作，因此所有人在压缩时都添加恢复记录是非常重要的。<br>如果修复后的文件依然不能正确解压，要么是损坏的部分过多无法修复，要么是资源发布者没有添加恢复记录。<br>在这种情况下就只能重新下载试试了。</p><h1 id="给压缩文件加密"><a href="#给压缩文件加密" class="headerlink" title="给压缩文件加密"></a>给压缩文件加密</h1><p>给压缩文件加密是防止文件被和谐的重要方法之一。<br><img src="/images/winrar-best-practice/07-add-password.png" alt=""></p><h1 id="分卷压缩"><a href="#分卷压缩" class="headerlink" title="分卷压缩"></a>分卷压缩</h1><p>如果你要分享一个非常巨大的压缩包，比如说十几个GB，直接作为一个文件分享一般不是一个好主意，因为下载者有可能下载到中途失败，不得不从头再来。将大压缩包切分成多个较小的文件可以有效减少这种情况的发生。<br><img src="/images/winrar-best-practice/08-split-volume.png" alt=""></p><h1 id="Linux-用户？"><a href="#Linux-用户？" class="headerlink" title="Linux 用户？"></a>Linux 用户？</h1><ul><li>很不幸地，创建或是修复带恢复记录的压缩包都需要<code>rar</code>而不是<code>unrar</code>。</li><li>如果遇到压缩包包含了文件名过长的文件，可以尝试创建一个 NTFS 格式的磁盘文件，用回环挂载，然后把文件解压进去。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文中的所有图片及文字均使用 CC0 发布，可任意转载使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文属于疫情期间的摸鱼之作，旨在推广 RAR 压缩格式的正确压缩方法，让资源分享更轻松一些。&lt;/p&gt;
&lt;h1 id=&quot;获取-WinRAR&quot;&gt;&lt;a href=&quot;#获取-WinRAR&quot; class=&quot;headerlink&quot; title=&quot;获取 WinRAR&quot;&gt;&lt;/a&gt;获取 WinRAR&lt;/h1&gt;&lt;p&gt;先说一下为什么用 WinRAR 而不用 7zip, 因为 7zip 没有恢复记录。在百度网盘等平台分享文件时，文件可能发生损坏，没有恢复记录的话只能尝试重新下载浪费时间，而有恢复记录的话有大概率可以成功修复，正确解压。&lt;/p&gt;
&lt;p&gt;国内特供版的 WinRAR 可以免费使用，但是有广告。如果不想要广告，你可以从以下链接下载官方无广告简体中文版&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://www.win-rar.com/fileadmin/winrar-versions/sc/sc20200409/rrlb/winrar-x64-590sc.exe&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意，如果你没有&lt;code&gt;rarreg.key&lt;/code&gt;文件进行注册的话依然是有广告的。至于具体的注册方法请自行搜寻。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="网盘" scheme="https://recursiveg.me/tags/%E7%BD%91%E7%9B%98/"/>
    
      <category term="WinRAR" scheme="https://recursiveg.me/tags/WinRAR/"/>
    
  </entry>
  
  <entry>
    <title>CMake 项目生成脚本</title>
    <link href="https://recursiveg.me/2020/03/cmake-environment-script/"/>
    <id>https://recursiveg.me/2020/03/cmake-environment-script/</id>
    <published>2020-03-16T15:00:00.000Z</published>
    <updated>2020-03-17T04:14:43.308Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 比较尴尬的一点就是缺少比较“傻瓜”的工具库，不得不依靠第三方来补充。想快速开始写个小的 Demo 的时候光找库就花去不少时间。于是糊了一个脚本去自动生成这些基础的东西。放在这里方便自己以后参考。</p><p>用到的库列表：</p><ul><li>{fmt}: 字符串格式化库</li><li>spdlog: 日志</li><li>backward-cpp: 崩溃时的堆栈输出</li><li>benchmark: 快速性能测试</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print_help</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Usage:"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"   cproject &lt;type&gt; &lt;name&gt;"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Types:"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"   bin, bench"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">die</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Unexpected error"</span></span><br><span class="line">    <span class="built_in">exit</span> 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ninja does not work with backward-cpp</span></span><br><span class="line"><span class="function"><span class="title">new_bin</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> name=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">    mkdir <span class="string">"<span class="variable">$name</span>"</span> || die</span><br><span class="line">    <span class="built_in">cd</span> <span class="string">"<span class="variable">$name</span>"</span> || die</span><br><span class="line">    git <span class="built_in">clone</span> <span class="string">'https://github.com/fmtlib/fmt.git'</span> third_party/fmt || die</span><br><span class="line">    git <span class="built_in">clone</span> <span class="string">'https://github.com/bombela/backward-cpp.git'</span> third_party/backward-cpp || die</span><br><span class="line">    git <span class="built_in">clone</span> <span class="string">'https://github.com/gabime/spdlog.git'</span> third_party/spdlog || die</span><br><span class="line">    cat &lt;&lt; EOF &gt; CMakeLists.txt</span><br><span class="line">cmake_minimum_required(VERSION 3.11)</span><br><span class="line">project(<span class="variable">$&#123;name&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(NOT CMAKE_BUILD_TYPE)</span><br><span class="line">    <span class="built_in">set</span>(CMAKE_BUILD_TYPE Debug)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS ON)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_C_STANDARD 11)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD 17)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_POSITION_INDEPENDENT_CODE ON)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">"\$&#123;CMAKE_CXX_FLAGS&#125; -Wall -Wextra"</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS_DEBUG <span class="string">"\$&#123;CMAKE_CXX_FLAGS_DEBUG&#125; -ggdb -O0"</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">"\$&#123;CMAKE_EXE_LINKER_FLAGS&#125; -rdynamic"</span>)</span><br><span class="line"></span><br><span class="line">add_subdirectory(third_party/fmt)</span><br><span class="line">add_subdirectory(third_party/spdlog)</span><br><span class="line">add_subdirectory(third_party/backward-cpp)</span><br><span class="line"></span><br><span class="line">add_executable(main)</span><br><span class="line">target_sources(main PRIVATE main.cpp \<span class="variable">$&#123;BACKWARD_ENABLE&#125;</span>)</span><br><span class="line">target_link_libraries(main PRIVATE fmt spdlog -ldw)</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">    cat &lt;&lt; <span class="string">'EOF'</span> &gt; main.cpp</span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">#include "fmt/format.h"</span></span><br><span class="line"><span class="comment">#include "spdlog/spdlog.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define CRASH(...)                      \</span></span><br><span class="line">    &#123; ::spdlog::critical(__VA_ARGS__);  \</span><br><span class="line">      int _ [[maybe_unused]] =          \</span><br><span class="line">         *reinterpret_cast&lt;int*&gt;(0); &#125;</span><br><span class="line"></span><br><span class="line">inline int <span class="function"><span class="title">get_return_code</span></span>() &#123;</span><br><span class="line">    CRASH(<span class="string">"unimplemented function: &#123;&#125;"</span>, __func__);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">    fmt::<span class="built_in">print</span>(<span class="string">"&#123;&#125;, &#123;&#125;\n\n"</span>, <span class="string">"hello"</span>, <span class="string">"world"</span>);</span><br><span class="line"></span><br><span class="line">    spdlog::set_level(spdlog::level::debug);</span><br><span class="line">    spdlog::debug(<span class="string">"debug message"</span>);</span><br><span class="line">    spdlog::info(<span class="string">"info message"</span>);</span><br><span class="line">    spdlog::warn(<span class="string">"warning message"</span>);</span><br><span class="line">    spdlog::error(<span class="string">"Some error message with arg: &#123;&#125;"</span>, 1);</span><br><span class="line">    <span class="built_in">return</span> get_return_code();</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Skeleton generated. Run the command and you shall see "</span> \</span><br><span class="line">         <span class="string">"the stacktrace demo."</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"  cd <span class="variable">$&#123;name&#125;</span> &amp;&amp; cmake -B build &amp;&amp; "</span> \</span><br><span class="line">         <span class="string">"make -C build -j main &amp;&amp; build/main"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">new_bench</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> name=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">    mkdir <span class="string">"<span class="variable">$name</span>"</span> || die</span><br><span class="line">    <span class="built_in">cd</span> <span class="string">"<span class="variable">$name</span>"</span> || die</span><br><span class="line">    git <span class="built_in">clone</span> <span class="string">'https://github.com/fmtlib/fmt.git'</span> third_party/fmt || die</span><br><span class="line">    git <span class="built_in">clone</span> <span class="string">'https://github.com/bombela/backward-cpp.git'</span> third_party/backward-cpp || die</span><br><span class="line">    git <span class="built_in">clone</span> <span class="string">'https://github.com/gabime/spdlog.git'</span> third_party/spdlog || die</span><br><span class="line">    git <span class="built_in">clone</span> <span class="string">'https://github.com/google/benchmark.git'</span> third_party/benchmark || die</span><br><span class="line">    git <span class="built_in">clone</span> <span class="string">'https://github.com/google/googletest.git'</span> third_party/benchmark/googletest || die</span><br><span class="line">    cat &lt;&lt; EOF &gt; CMakeLists.txt</span><br><span class="line">cmake_minimum_required(VERSION 3.11)</span><br><span class="line">project(<span class="variable">$&#123;name&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(NOT CMAKE_BUILD_TYPE)</span><br><span class="line">    <span class="built_in">set</span>(CMAKE_BUILD_TYPE Release)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS ON)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_C_STANDARD 11)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD 17)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_POSITION_INDEPENDENT_CODE ON)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">"\$&#123;CMAKE_CXX_FLAGS&#125; -Wall -Wextra -g"</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">"\$&#123;CMAKE_EXE_LINKER_FLAGS&#125; -rdynamic"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(BENCHMARK_ENABLE_LTO <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">add_subdirectory(third_party/fmt)</span><br><span class="line">add_subdirectory(third_party/spdlog)</span><br><span class="line">add_subdirectory(third_party/backward-cpp)</span><br><span class="line">add_subdirectory(third_party/benchmark)</span><br><span class="line"></span><br><span class="line">add_executable(bench)</span><br><span class="line">target_sources(bench PRIVATE bench.cpp \<span class="variable">$&#123;BACKWARD_ENABLE&#125;</span>)</span><br><span class="line">target_link_libraries(bench PRIVATE fmt spdlog benchmark::benchmark_main -ldw)</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">    cat &lt;&lt; <span class="string">'EOF'</span> &gt; bench.cpp</span><br><span class="line"><span class="comment">#include "benchmark/benchmark.h"</span></span><br><span class="line"><span class="comment">#include &lt;cinttypes&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdlib&gt;</span></span><br><span class="line"></span><br><span class="line">constexpr size_t ARRAY_LEN = 1024*64;</span><br><span class="line">static void BM_SeqArrayAccess(benchmark::State&amp; state) &#123;</span><br><span class="line">    int stride = state.range(0);</span><br><span class="line">    uint64_t arr[ARRAY_LEN];</span><br><span class="line">    <span class="keyword">for</span> (auto _ : state) &#123;</span><br><span class="line">        <span class="keyword">for</span> (size_t idx = 0; idx &lt; ARRAY_LEN; idx += stride) &#123;</span><br><span class="line">            arr[idx] = random();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BENCHMARK(BM_SeqArrayAccess)</span><br><span class="line">    -&gt;Arg(1)</span><br><span class="line">    -&gt;Arg(2)</span><br><span class="line">    -&gt;Arg(3)</span><br><span class="line">    -&gt;Arg(4)</span><br><span class="line">    -&gt;Arg(5)</span><br><span class="line">    -&gt;Arg(6)</span><br><span class="line">    -&gt;Arg(7)</span><br><span class="line">    -&gt;Arg(8);</span><br><span class="line">EOF</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Skeleton generated."</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"  cd <span class="variable">$&#123;name&#125;</span> &amp;&amp; cmake -B build &amp;&amp; "</span> \</span><br><span class="line">         <span class="string">"make -C build -j bench &amp;&amp; build/bench"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"You may also need to change your CPU scheduler:"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"  sudo cpupower frequency-set -g performance"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$2</span>"</span> == <span class="string">""</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Missing project name"</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    print_help</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ -e <span class="string">"<span class="variable">$2</span>"</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"File \"<span class="variable">$2</span>\" already exists"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$1</span>"</span> == <span class="string">"bin"</span> ]]; <span class="keyword">then</span></span><br><span class="line">    new_bin <span class="string">"<span class="variable">$2</span>"</span></span><br><span class="line"><span class="keyword">elif</span> [[ <span class="string">"<span class="variable">$1</span>"</span> == <span class="string">"bench"</span> ]]; <span class="keyword">then</span></span><br><span class="line">    new_bench <span class="string">"<span class="variable">$2</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Unknown type: <span class="variable">$1</span>"</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    print_help</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C++ 比较尴尬的一点就是缺少比较“傻瓜”的工具库，不得不依靠第三方来补充。想快速开始写个小的 Demo 的时候光找库就花去不少时间。于是糊了一个脚本去自动生成这些基础的东西。放在这里方便自己以后参考。&lt;/p&gt;
&lt;p&gt;用到的库列表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;{fmt}: 
      
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="编程" scheme="https://recursiveg.me/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="脚本" scheme="https://recursiveg.me/tags/%E8%84%9A%E6%9C%AC/"/>
    
      <category term="CMake" scheme="https://recursiveg.me/tags/CMake/"/>
    
      <category term="C++" scheme="https://recursiveg.me/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>简易内核开发环境</title>
    <link href="https://recursiveg.me/2020/01/simple-kernel-dev-environment/"/>
    <id>https://recursiveg.me/2020/01/simple-kernel-dev-environment/</id>
    <published>2020-01-12T04:30:00.000Z</published>
    <updated>2020-01-12T22:01:14.348Z</updated>
    
    <content type="html"><![CDATA[<p>近期尝试了一下写 Linux 内核代码，于是把折腾过程记录一下，方便以后参考。本文默认使用 x86_64 架构以及 Linux 作为宿主系统。</p><h2 id="使用-QEMU-运行-Linux-内核"><a href="#使用-QEMU-运行-Linux-内核" class="headerlink" title="使用 QEMU 运行 Linux 内核"></a>使用 QEMU 运行 Linux 内核</h2><p>在开始写代码之前，我们需要先准备好模拟器用于运行 Linux。我这里用了QEMU，你也可以用 VirtualBox 之类的虚拟机。一般来说，我们需要一个内核可执行文件（内核本体）和一个 initramfs 镜像（提供用户态程序）。当内核被加载后，它会自动载入 initramfs 镜像，并执行其中的<code>/init</code>程序。由于这一节的重点是 QEMU 配置，所以我直接使用宿主机的内核和 initramfs。以我的 Archlinux 系统为例，内核文件是<code>/boot/vmlinuz-linux</code>，initramfs 文件是<code>/boot/initramfs-linux.img</code>。使用以下命令启动 QEMU，按<code>Ctrl-A x</code>退出。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -kernel /boot/vmlinuz-linux \</span><br><span class="line">    -initrd /boot/initramfs-linux.img \</span><br><span class="line">    -nographic -append <span class="string">"console=ttyS0"</span> \</span><br><span class="line">    -m 512 \</span><br><span class="line">    --<span class="built_in">enable</span>-kvm \</span><br><span class="line">    -cpu host</span><br></pre></td></tr></table></figure><ul><li><code>-kernel</code> 指定内核可执行文件。</li><li><code>-initrd</code> 指定 initramfs disk 镜像文件。</li><li><code>-nographic -append &quot;console=ttyS0&quot;</code> 禁用视频输出并使用串口作为终端。</li><li><code>-m 512</code> 设定内存。</li><li><code>--enable-kvm</code> 使用KVM。</li><li><code>-cpu host</code> 使用宿主机的 CPU 特性。</li></ul><p>你应该能看到一些系统启动的信息以及无法挂载根分区的报错，这是正常现象，因为我们没有提供任何磁盘文件。你应该可以进入一个紧急修复 Shell, 执行一些简单的如 <code>ls</code> <code>cd</code> 之类的命令。</p><a id="more"></a><h2 id="创建自己的-initramfs"><a href="#创建自己的-initramfs" class="headerlink" title="创建自己的 initramfs"></a>创建自己的 initramfs</h2><p>确保 QEMU 能够正常工作后，我们来创建自己 initramfs 替换掉上一步中的<code>/boot/initramfs-linux.img</code>。这一节的内容主要来自 <a href="https://lyngvaer.no/log/create-linux-initramfs" target="_blank" rel="noopener">Creating a initramfs image from scratch</a> 一文。initramfs 镜像本质上是一个经过压缩的 cpio 归档文件（cpio 约等于 tar）。根据内核版本的不同，你可以使用不同的压缩算法。我的内核比较新，所以可以使用lz4压缩。同时，我们直接下载使用编译好的<code>busybox</code>可执行文件作为我们的 Shell。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mkdir initramfs_root  <span class="comment"># 创建initramfs的根目录</span></span><br><span class="line"><span class="built_in">cd</span> initramfs_root</span><br><span class="line"></span><br><span class="line">mkdir bin dev etc lib mnt proc sbin sys tmp var  <span class="comment"># 创建一系列必要的目录</span></span><br><span class="line"><span class="built_in">pushd</span> bin</span><br><span class="line">wget <span class="string">'https://busybox.net/downloads/binaries/1.31.0-defconfig-multiarch-musl/busybox-x86_64'</span> -Obusybox <span class="comment"># 下载busybox</span></span><br><span class="line">chmod +x busybox</span><br><span class="line"><span class="built_in">popd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /init 是一个脚本，由busybox解释执行</span></span><br><span class="line">cat &lt;&lt; <span class="string">'EOF'</span> &gt; init</span><br><span class="line"><span class="meta">#!/bin/busybox sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载必要的文件系统目录</span></span><br><span class="line">/bin/busybox mount -t devtmpfs devtmpfs /dev</span><br><span class="line">/bin/busybox mount -t proc     proc     /proc</span><br><span class="line">/bin/busybox mount -t sysfs    sysfs    /sys</span><br><span class="line">/bin/busybox mount -t tmpfs    tmpfs    /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印一些欢迎信息</span></span><br><span class="line">/bin/busybox <span class="built_in">echo</span> Hello from initramfs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行shell，将控制权交给用户</span></span><br><span class="line">/bin/busybox sh</span><br><span class="line">EOF</span><br><span class="line">chmod +x init</span><br><span class="line"></span><br><span class="line"><span class="comment"># find .  列举需要压缩的文件</span></span><br><span class="line"><span class="comment"># cpio -o 执行归档</span></span><br><span class="line"><span class="comment">#      -H newc 指定归档文件格式</span></span><br><span class="line"><span class="comment"># lz4  -l 使用内核可以识别的压缩格式</span></span><br><span class="line">find . | cpio -ov -H newc | lz4 -l -9 &gt; ../initramfs.cpio.lz4</span><br></pre></td></tr></table></figure><p>这样，一个自定义的<code>initramfs.cpio.lz4</code>文件就构建好了。用其替换掉<code>/boot/initramfs-linux.img</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -kernel /boot/vmlinuz-linux \</span><br><span class="line">    -initrd initramfs.cpio.lz4 \</span><br><span class="line">    -nographic -append <span class="string">"console=ttyS0"</span> \</span><br><span class="line">    -m 512 \</span><br><span class="line">    --<span class="built_in">enable</span>-kvm \</span><br><span class="line">    -cpu host</span><br></pre></td></tr></table></figure><p>这样你应该就能得到一条欢迎信息和一个 Shell。由于我们没有创建常用命令到<code>busybox</code>的软链接，所以执行指令时需要加上<code>busybox</code>的前缀。以下是我的运行结果。</p><pre><code>Hello from initramfssh: can&apos;t access tty; job control turned off/ # busybox lsbin   dev   etc   init  lib   mnt   proc  root  sbin  sys   tmp   var/ #</code></pre><h2 id="编译自己的内核"><a href="#编译自己的内核" class="headerlink" title="编译自己的内核"></a>编译自己的内核</h2><p>替换掉 initramfs 镜像后，我们接着来替换内核。自己编译内核大概分三步：下载代码；配置内核；编译内核。Linux 的内核源代码可以在 <a href="https://www.kernel.org/" target="_blank" rel="noopener">https://www.kernel.org/</a> 下载。下载并解压到某个文件夹，比方说<code>linux-5.5-rc5</code>。通常来说手动配置内核是个苦差事，于是我们直接使用默认配置就好。默认配置文件位于<code>arch/x86/configs/x86_64_defconfig</code>。</p><pre><code>linux-5.5-rc5$ make x86_64_defconfig  # 使用64位默认配置...此处省略若干行...linux-5.5-rc5$ make -j10  # 请根据你电脑的核心数量调整...此处省略若干行...Kernel: arch/x86/boot/bzImage is ready  (#1)</code></pre><p>依葫芦画瓢，用这个编译好的<code>bzImage</code>替换掉<code>/boot/vmlinuz-linux</code>，你应该得到和之前一样的欢迎信息和 Shell。</p><h2 id="Hello-world-不含-glibc"><a href="#Hello-world-不含-glibc" class="headerlink" title="Hello world! (不含 glibc)"></a>Hello world! (不含 glibc)</h2><p>使用 C 语言写 Hello world! 是一码事，不用 glibc 写 Hello world! 是另一码事。在我们创建的 initramfs 中，我们没有包含任何类似<code>glibc</code>的 C 标准库，因此我们不能使用诸如<code>printf()</code>之类的方便函数，需要直接使用系统调用进行输出。从汇编层面来说，要进行系统调用，只需要将系统调用号以及参数统统塞入一系列寄存器，然后执行<code>syscall</code>指令即可。更详细的我在几年前的一篇<a href="https://recursiveg.me/2014/05/programming-with-ptrace-part4/">《Programming with PTRACE, Part4 - 系统调用进阶》</a>里有讲到。那么直接贴代码：</p><figure class="highlight cpp"><figcaption><span>helloworld.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDOUT 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_write 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_exit 60</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_write</span><span class="params">(<span class="keyword">long</span> fd, <span class="keyword">const</span> <span class="keyword">void</span>* addr, <span class="keyword">long</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"mov %0, %%rax;"</span></span><br><span class="line">        <span class="string">"mov %1, %%rdi;"</span></span><br><span class="line">        <span class="string">"mov %2, %%rsi;"</span></span><br><span class="line">        <span class="string">"mov %3, %%rdx;"</span>    </span><br><span class="line">        <span class="string">"syscall"</span></span><br><span class="line"></span><br><span class="line">    ::  <span class="string">"i"</span>(SYS_write),</span><br><span class="line">        <span class="string">"r"</span>(fd),</span><br><span class="line">        <span class="string">"r"</span>(addr),</span><br><span class="line">        <span class="string">"r"</span>(len)</span><br><span class="line"></span><br><span class="line">    :   <span class="string">"%rax"</span>,</span><br><span class="line">        <span class="string">"%rdi"</span>,</span><br><span class="line">        <span class="string">"%rsi"</span>,</span><br><span class="line">        <span class="string">"%rdx"</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_exit</span><span class="params">(<span class="keyword">long</span> return_code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"mov %0, %%rax;"</span></span><br><span class="line">        <span class="string">"mov %1, %%rdi;"</span></span><br><span class="line">        <span class="string">"syscall"</span></span><br><span class="line"></span><br><span class="line">    ::  <span class="string">"i"</span>(SYS_exit),</span><br><span class="line">        <span class="string">"r"</span>(return_code)</span><br><span class="line"></span><br><span class="line">    :   <span class="string">"%rax"</span>,</span><br><span class="line">        <span class="string">"%rdi"</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[len] != <span class="string">'\0'</span>) len++;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _start() &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"Hello world!\n"</span>;</span><br><span class="line">    sys_write(STDOUT, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    sys_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个值得注意的点：使用<code>_start()</code>而不是<code>main()</code>；<code>exit()</code>系统调用不能省。另外这个程序编译的时候也需要一些特殊的技巧，需要静态链接并且不需要标准库支持：</p><pre><code>gcc -nostdlib -static helloworld.c -fno-stack-protector -o helloworld</code></pre><p>将编译出的文件放入<code>initramfs_root</code>并重新打包，然后在 QEMU 中运行就能看到效果了。</p><pre><code>Hello from initramfssh: can&apos;t access tty; job control turned off/ # /bin/helloworldHello world!</code></pre><h2 id="Challenge-Hello-world-from-kernel-space"><a href="#Challenge-Hello-world-from-kernel-space" class="headerlink" title="Challenge (Hello world from kernel space)"></a>Challenge (Hello world from kernel space)</h2><p>至此，我们已经知道了如何在 QEMU 中启动一个包含内核和用户空间程序的 Linux 系统，并且知道了如何利用系统调用让用户态程序输出字符串。有兴趣的读者可以尝试给内核添加一个新的系统调用，当被调用时向 kernel log 输出<code>Hello kernel world!</code>。就像这样：</p><pre><code>/ # /bin/helloworld_syscall[    4.621241] Hello kernel world!</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期尝试了一下写 Linux 内核代码，于是把折腾过程记录一下，方便以后参考。本文默认使用 x86_64 架构以及 Linux 作为宿主系统。&lt;/p&gt;
&lt;h2 id=&quot;使用-QEMU-运行-Linux-内核&quot;&gt;&lt;a href=&quot;#使用-QEMU-运行-Linux-内核&quot; class=&quot;headerlink&quot; title=&quot;使用 QEMU 运行 Linux 内核&quot;&gt;&lt;/a&gt;使用 QEMU 运行 Linux 内核&lt;/h2&gt;&lt;p&gt;在开始写代码之前，我们需要先准备好模拟器用于运行 Linux。我这里用了QEMU，你也可以用 VirtualBox 之类的虚拟机。一般来说，我们需要一个内核可执行文件（内核本体）和一个 initramfs 镜像（提供用户态程序）。当内核被加载后，它会自动载入 initramfs 镜像，并执行其中的&lt;code&gt;/init&lt;/code&gt;程序。由于这一节的重点是 QEMU 配置，所以我直接使用宿主机的内核和 initramfs。以我的 Archlinux 系统为例，内核文件是&lt;code&gt;/boot/vmlinuz-linux&lt;/code&gt;，initramfs 文件是&lt;code&gt;/boot/initramfs-linux.img&lt;/code&gt;。使用以下命令启动 QEMU，按&lt;code&gt;Ctrl-A x&lt;/code&gt;退出。&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;qemu-system-x86_64 \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -kernel /boot/vmlinuz-linux \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -initrd /boot/initramfs-linux.img \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -nographic -append &lt;span class=&quot;string&quot;&gt;&quot;console=ttyS0&quot;&lt;/span&gt; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -m 512 \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    --&lt;span class=&quot;built_in&quot;&gt;enable&lt;/span&gt;-kvm \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -cpu host&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-kernel&lt;/code&gt; 指定内核可执行文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-initrd&lt;/code&gt; 指定 initramfs disk 镜像文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-nographic -append &amp;quot;console=ttyS0&amp;quot;&lt;/code&gt; 禁用视频输出并使用串口作为终端。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-m 512&lt;/code&gt; 设定内存。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--enable-kvm&lt;/code&gt; 使用KVM。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-cpu host&lt;/code&gt; 使用宿主机的 CPU 特性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你应该能看到一些系统启动的信息以及无法挂载根分区的报错，这是正常现象，因为我们没有提供任何磁盘文件。你应该可以进入一个紧急修复 Shell, 执行一些简单的如 &lt;code&gt;ls&lt;/code&gt; &lt;code&gt;cd&lt;/code&gt; 之类的命令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="编程" scheme="https://recursiveg.me/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Kernel" scheme="https://recursiveg.me/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>AMD Threadripper 3960X 装机</title>
    <link href="https://recursiveg.me/2019/12/build-amd-3960x-pc/"/>
    <id>https://recursiveg.me/2019/12/build-amd-3960x-pc/</id>
    <published>2019-12-24T04:00:00.000Z</published>
    <updated>2020-01-12T19:04:35.210Z</updated>
    
    <content type="html"><![CDATA[<p>眼看2019年就要结束了，发现自己的手竟然还在。于是决定连着胳膊一起剁掉。<br><img src="/images/build-amd-3960x-pc/01-all.jpg" alt="配件合照"></p><a id="more"></a><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>没什么好说的，AMD YES 就完事儿了。<br><img src="/images/build-amd-3960x-pc/02-cpu.jpg" alt="AMD Threadripper 3960X"></p><h2 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h2><p>主板选了微星的 TRX40 PRO 10G (我就是不喜欢 Asus 你来打我啊)。10G 版比 WIFI 少了无线模块，多了一张万兆以太网卡。不过不管哪样我都暂时用不上。另外还有一张 PCI-E x8 转两个 M.2 的转接卡，没那么多 SSD，同样用不上就是了。除此以外就是说明书、光污染线之类的玩意儿。<br><img src="/images/build-amd-3960x-pc/03-mobo.jpg" alt="MSI TRX40 PRO 10G"></p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>极度非主流的内存配置，4根英睿达的 16G ECC 内存。型号为<code>CT16G4WFD8266</code>。</p><p>于是先把 CPU 和内存装上主板：<br><img src="/images/build-amd-3960x-pc/04-cpu-mem-installed.jpg" alt="CPU &amp; Memory Installed"></p><h2 id="一体式水冷"><a href="#一体式水冷" class="headerlink" title="一体式水冷"></a>一体式水冷</h2><p>随便选的 九州神风堡垒360EX。少数几个当时能以合理价格买到的支持 TR4 的一体水冷。<br><img src="/images/build-amd-3960x-pc/05-aio-cooler.jpg" alt="Deepcool Castle 360EX"><br>另外现在的风扇都这么花哨了吗，怎么扇叶上都装扰流板了？<br><img src="/images/build-amd-3960x-pc/06-aio-cooler-fan.jpg" alt="Deepcool Castle 360EX - Fan"></p><h2 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h2><p>随便选的 海韵 Focus GX-850。少数几个当时能以合理价格买到的便宜的 850W 电源。另外这电源还送了一个测试器，本质就是把 ATX 接头里的某两根线短接一下，用以测试电源本身能不能工作。但是我为什么不直接把它插到主板上去测试呢？<br><img src="/images/build-amd-3960x-pc/07-psu1.jpg" alt="Seasonic Focus GX-850"><br><img src="/images/build-amd-3960x-pc/07-psu2.jpg" alt="Seasonic Focus GX-850"></p><h2 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h2><p>显卡方面，AMD 好像不是很香，但我还是选了 RX590。别问为什么，问就是 <a href="https://youtu.be/iYWzMvlj2RQ" target="_blank" rel="noopener">Fuck you NVIDIA</a>。<br><img src="/images/build-amd-3960x-pc/08-rx590.jpg" alt="Sapphire Pulse RX 590"></p><h2 id="40Gbps"><a href="#40Gbps" class="headerlink" title="40Gbps"></a>40Gbps</h2><p>之前提到用不到万兆网卡，一是没有万兆交换机，二是有捡垃圾捡回来的 40G Infiniband 卡，台式机和 NAS 之间用 QSPF 线直连，速度反正比机械硬盘快就是了。顺带把旧机器上的系统盘也拆过来。<br><img src="/images/build-amd-3960x-pc/09-ib-nvme.jpg" alt="ConnectX-3 &amp; Samsung 960 EVO"></p><h2 id="塞进机箱"><a href="#塞进机箱" class="headerlink" title="塞进机箱"></a>塞进机箱</h2><p>机箱选了毫无灯光的 Fractal Design Define C，这个机箱没有前置的 USB Type-C 接口比较可惜。显卡的 PCI-E 供电线荡在那儿还是有点丑。<br><img src="/images/build-amd-3960x-pc/10-internal.jpg" alt="Internal"><br>背面走线随便走走，机箱能合上就是胜利。<br><img src="/images/build-amd-3960x-pc/11-internal-back.jpg" alt="Internal - Back"></p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>新机器插电一次亮，不过意料之中的，进不去系统。根据 <a href="https://www.phoronix.com/scan.php?page=news_item&px=Linux-Boot-Threadripper-Zen2MCE" target="_blank" rel="noopener">Phoronix 的报道</a>，需要在内核参数中添加<code>mce=off</code>才能正常启动。然后进 BIOS 把虚拟化、IOMMU、ECC 之类的都开起来，这机器就算装完了。随意跑了一下<code>s-tui</code>，48个线程满载还是蛮恐怖的。<br><img src="/images/build-amd-3960x-pc/12-stressing.png" alt="htop+s-tui"><br>一般空载整机功耗 100W 左右。单烤 CPU 全核频率在 4GHz 左右，整机功耗 400W，想必加上显卡后能轻松过 500W，电费也要开始燃烧了。另外这接近 80℃ 的温度感觉有点高，难道是水冷没装好？</p><p>装机总结：AMD YES</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;眼看2019年就要结束了，发现自己的手竟然还在。于是决定连着胳膊一起剁掉。&lt;br&gt;&lt;img src=&quot;/images/build-amd-3960x-pc/01-all.jpg&quot; alt=&quot;配件合照&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Life" scheme="https://recursiveg.me/categories/Life/"/>
    
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="AMD" scheme="https://recursiveg.me/tags/AMD/"/>
    
      <category term="装机" scheme="https://recursiveg.me/tags/%E8%A3%85%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Haskell 简易指南</title>
    <link href="https://recursiveg.me/2019/03/haskell-intro/"/>
    <id>https://recursiveg.me/2019/03/haskell-intro/</id>
    <published>2019-03-20T18:00:00.000Z</published>
    <updated>2020-01-12T19:20:05.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>用任何你喜欢的方法安装 <a href="https://www.haskell.org/" target="_blank" rel="noopener">Glasgow Haskell Compiler</a> (a.k.a. GHC)。Cabal 之类的<br>依赖管理系统就用不着了。 <del>因为我也不会用。</del> 保证能够执行<code>ghc</code>和<code>ghci</code>命令就行。</p><h1 id="GHCi基础"><a href="#GHCi基础" class="headerlink" title="GHCi基础"></a>GHCi基础</h1><p>首先，把以下文件保存成<code>helloworld.hs</code>。</p><figure class="highlight haskell"><figcaption><span>helloworld.hs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> = <span class="string">"hello, world"</span></span><br></pre></td></tr></table></figure><p>然后执行<code>ghci helloworld.hs</code>，然后在<code>&gt;</code>提示符后输入<code>foo</code>并回车</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GHCi, version 8.6.3: http:&#x2F;&#x2F;www.haskell.org&#x2F;ghc&#x2F;  :? for help</span><br><span class="line">[1 of 1] Compiling Main             ( helloworld.hs, interpreted )</span><br><span class="line">Ok, one module loaded.</span><br><span class="line">*Main&gt; foo</span><br><span class="line">&quot;hello, world&quot;</span><br><span class="line">*Main&gt;</span><br></pre></td></tr></table></figure><p>你可以使用<code>:r</code>来重新载入文件，也可以使用<code>:l &lt;文件名&gt;</code>来载入代码。</p><a id="more"></a><h1 id="基础表达式"><a href="#基础表达式" class="headerlink" title="基础表达式"></a>基础表达式</h1><p>你可以修改你的代码文件，并在GHCi中观察程序行为。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里是注释</span></span><br><span class="line"></span><br><span class="line"><span class="title">foo</span> = <span class="string">"hello, world"</span>  <span class="comment">-- 名称绑定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义一个函数，返回参数加一</span></span><br><span class="line"><span class="title">plus1</span> x=x+<span class="number">1</span></span><br><span class="line"><span class="comment">-- 函数调用的格式为 &lt;函数名&gt; &lt;参数1&gt; &lt;参数2&gt; ……</span></span><br><span class="line"><span class="comment">-- *Main&gt; plus1 41</span></span><br><span class="line"><span class="comment">-- 42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 递归调用，定义的顺序很重要，在前面的定义优先考虑</span></span><br><span class="line"><span class="title">fact</span> <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="title">fact</span> n = n * fact (n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列表 (a.k.a. 数组)</span></span><br><span class="line"><span class="title">list1</span> = [<span class="string">"I"</span>, <span class="string">"am"</span>, <span class="string">"a"</span>, <span class="string">"list"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 元组</span></span><br><span class="line"><span class="title">tuple1</span> = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="title">triple1</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 元组的模式匹配</span></span><br><span class="line"><span class="title">sumOfTuple</span> (x1, x2) = x1+x2</span><br><span class="line"><span class="comment">-- *Main&gt; sumOfTuple tuple1</span></span><br><span class="line"><span class="comment">-- 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列表与列表合并</span></span><br><span class="line"><span class="title">list2</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">list3</span> = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="title">list4</span> = list2 ++ list3</span><br><span class="line"><span class="comment">-- *Main&gt; list4</span></span><br><span class="line"><span class="comment">-- [1,2,3,4,5,6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串是字符组成的列表</span></span><br><span class="line"><span class="title">str1</span> = <span class="string">"foo"</span> ++ ['b','a','r']</span><br><span class="line"><span class="comment">-- *Main&gt; str1</span></span><br><span class="line"><span class="comment">-- "foobar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列表头部插入, 以下四种表达方式等价</span></span><br><span class="line"><span class="title">list5</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">list6</span> = <span class="number">1</span>:[<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">list7</span> = <span class="number">1</span>:<span class="number">2</span>:[<span class="number">3</span>]</span><br><span class="line"><span class="title">list8</span> = <span class="number">1</span>:<span class="number">2</span>:<span class="number">3</span>:[]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列表的模式匹配</span></span><br><span class="line"><span class="title">sumOfList</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">sumOfList</span> (headElement:remainingElements) = headElement + sumOfList remainingElements</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 强制前缀表达式</span></span><br><span class="line"><span class="title">three</span> = (+) <span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 强制中缀表达式，mod为取模函数</span></span><br><span class="line"><span class="title">four</span> = <span class="number">18</span> `mod` <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数部分求值 (Partial application)，以下两个函数等价</span></span><br><span class="line"><span class="comment">-- 单引号没有特殊意义，是合法函数名的一部分</span></span><br><span class="line"><span class="title">plus2</span>  x = (+) <span class="number">2</span> x</span><br><span class="line"><span class="title">plus2'</span>   = (+) <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- if 条件 (类似三目运算符)</span></span><br><span class="line"><span class="title">five</span> = <span class="keyword">if</span> <span class="type">False</span> <span class="keyword">then</span> <span class="number">4</span> <span class="keyword">else</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- let 名称绑定</span></span><br><span class="line"><span class="title">six</span>  = <span class="keyword">let</span> x = <span class="number">7</span> <span class="keyword">in</span> x<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Guard</span></span><br><span class="line"><span class="title">sign</span> x</span><br><span class="line">    | x &lt; <span class="number">0</span>     = <span class="number">-1</span></span><br><span class="line">    | x == <span class="number">0</span>    = <span class="number">0</span></span><br><span class="line">    | otherwise = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数复合</span></span><br><span class="line"><span class="title">plus4</span>  x = plus2 (plus2 x)</span><br><span class="line"><span class="title">plus4'</span> x = (plus2 . plus2) x</span><br><span class="line"><span class="title">plus4''</span>  = plus2 . plus2</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Lambda表达式 (a.k.a. 匿名函数)</span></span><br><span class="line"><span class="title">sum'</span>  = (\x y -&gt; x+y)</span><br><span class="line"><span class="title">plus5</span> = (\x   -&gt; sum' x <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>这里仅列出了极少数基本用法。更多关于语言本身的以及数据结构的特定语法规则请参考相关Haskell教程。</p><h1 id="类型标记"><a href="#类型标记" class="headerlink" title="类型标记"></a>类型标记</h1><p>Haskell 是一门具有类型推导的静态类型语言。每个表达式都有自己的类型，在 GHCi 的交互模式下，可以使用<code>:t &lt;表达式&gt;</code>来检查表达式的类型。类型注记通常写为<code>&lt;表达式&gt; :: &lt;类型&gt;</code>。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 布尔型</span></span><br><span class="line">*<span class="type">Main</span>&gt; :t <span class="type">True</span></span><br><span class="line"><span class="type">True</span>::<span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 元组</span></span><br><span class="line">*<span class="type">Main</span>&gt; :t (<span class="type">True</span>, <span class="type">False</span>)</span><br><span class="line">(<span class="type">True</span>, <span class="type">False</span>) :: (<span class="type">Bool</span>, <span class="type">Bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列表</span></span><br><span class="line">*<span class="type">Main</span>&gt; :t <span class="string">"123"</span></span><br><span class="line"><span class="string">"123"</span> :: [<span class="type">Char</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数</span></span><br><span class="line">*<span class="type">Main</span>&gt; :t (+)</span><br><span class="line">(+) :: <span class="type">Num</span> a =&gt; a -&gt; a -&gt; a</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 部分求值后，新的函数只需要一个参数</span></span><br><span class="line">*<span class="type">Main</span>&gt; :t (+) <span class="number">1</span></span><br><span class="line">(+) <span class="number">1</span> :: <span class="type">Num</span> a =&gt; a -&gt; a</span><br></pre></td></tr></table></figure><p>函数类型以 <code>(参数1的类型) -&gt; (参数2的类型) -&gt; ... -&gt; (返回值的类型)</code> 形式表达。不明显区分参数和返回值。<code>Num</code>是代表数字的类型类，可以近似理解成Java中的接口。<code>Num a =&gt;</code> 表示 “在后续的类型定义中，<code>a</code>可以被替换成任何满足<code>Num</code>的类型”。整数<code>Int</code>和浮点数<code>Float</code>都是<code>Num</code>类型类的成员，所以加法函数既可以将整数相加，也可以将浮点数相加。</p><p>类型箭头都是右结合，但是你可以手动添加括号来改变类型的意义</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 接受一个整型参数，返回一个新函数。这个新函数接受一个整型，返回一个整型</span></span><br><span class="line"><span class="title">product'</span> :: <span class="type">Int</span> -&gt; (<span class="type">Int</span> -&gt; <span class="type">Int</span>)</span><br><span class="line"><span class="title">product'</span> x y = x * y</span><br><span class="line"><span class="title">timesThree</span> = product' <span class="number">3</span></span><br><span class="line"><span class="title">nine</span> = timesThree <span class="number">3</span></span><br><span class="line"><span class="title">nine'</span> = (product' <span class="number">3</span>) <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 接受一个参数，该参数是“接受一个整型，返回一个整型”的函数，然后返回一个整型</span></span><br><span class="line"><span class="title">some_func</span> :: (<span class="type">Int</span> -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">some_func</span> f = f <span class="number">42</span></span><br><span class="line"><span class="comment">-- *Main&gt; some_func (* 2)</span></span><br><span class="line"><span class="comment">-- 84</span></span><br></pre></td></tr></table></figure><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>Haskell 中定义新类型的基本语法是<code>data &lt;新类型名&gt; [类型参数..] = &lt;构造函数1&gt; [成员类型...] | &lt;构造函数2&gt; [成员类型...] | ...</code>。类型名和构造函数都需要首字母大写。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">NameAndAge</span> = <span class="type">MakeNameAndAge</span> <span class="type">String</span> <span class="type">Int</span></span></span><br><span class="line"><span class="comment">-- *Main&gt; :t MakeNameAndAge</span></span><br><span class="line"><span class="comment">-- MakeNameAndAge :: String -&gt; Int -&gt; NameAndAge</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">IntOrBool</span> = <span class="type">MakeInt</span> <span class="type">Int</span> | <span class="type">MakeBool</span> <span class="type">Bool</span></span></span><br><span class="line"><span class="comment">-- *Main&gt; :t MakeInt</span></span><br><span class="line"><span class="comment">-- MakeInt :: Int -&gt; IntOrBool</span></span><br><span class="line"><span class="comment">-- *Main&gt; :t MakeBool</span></span><br><span class="line"><span class="comment">-- MakeBool :: Bool -&gt; IntOrBool</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Weekends</span> = <span class="type">Saturday</span> | <span class="type">Sunday</span></span></span><br><span class="line"><span class="comment">-- Saturday :: Weekends</span></span><br><span class="line"><span class="comment">-- Sunday :: Weekends</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">TupleOf</span> a = <span class="type">MakeTupleOf</span> a a</span></span><br><span class="line"><span class="comment">-- MakeTupleOf :: a -&gt; a -&gt; TupleOf a</span></span><br><span class="line"><span class="comment">-- MakeTupleOf False True :: TupleOf Bool</span></span><br><span class="line"><span class="comment">-- MakeTupleOf 1 2 :: Num a =&gt; TupleOf a</span></span><br><span class="line"><span class="comment">-- MakeTupleOf plus1 plus2 :: Num a =&gt; TupleOf (a -&gt; a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 你可以使用函数的模式匹配来提取数据结构中的成员</span></span><br><span class="line"><span class="title">printNameAndAge</span> :: <span class="type">NameAndAge</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">printNameAndAge</span> (<span class="type">MakeNameAndAge</span> name age) =</span><br><span class="line">    <span class="string">"I'm "</span> ++ name ++ <span class="string">" and I'm "</span> ++ (show age) ++ <span class="string">" years old."</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 你也可以使用模式匹配来判断是哪一个构造函数</span></span><br><span class="line"><span class="title">printIntOrBool</span> :: <span class="type">IntOrBool</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">printIntOrBool</span> (<span class="type">MakeInt</span> n) = <span class="string">"Wow, an integer: "</span> ++ (show n)</span><br><span class="line"><span class="title">printIntOrBool</span> (<span class="type">MakeBool</span> b) = <span class="string">"Wow, a boolean: "</span> ++ (show b)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 你甚至可以进行递归类型定义 。当然，你需要一个终止条件。</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">ListOf</span> a = <span class="type">EmptyList</span> | <span class="type">AppendList</span> (<span class="type">ListOf</span> <span class="title">a</span>) a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 相关操作也需要使用递归函数来完成</span></span><br><span class="line"><span class="title">contains</span> :: (<span class="type">Eq</span> a) =&gt; <span class="type">ListOf</span> a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">contains</span> <span class="type">EmptyList</span> _ = <span class="type">False</span></span><br><span class="line"><span class="title">contains</span> (<span class="type">AppendList</span> list x') x =</span><br><span class="line">    <span class="keyword">if</span> x == x' <span class="keyword">then</span> <span class="type">True</span> <span class="keyword">else</span> contains list x</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为 ListOf a 类型实现 Eq 类型类</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Eq</span> a =&gt; <span class="type">Eq</span> (<span class="type">ListOf</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    <span class="type">EmptyList</span> == <span class="type">EmptyList</span>                   = <span class="type">True</span></span><br><span class="line">    (<span class="type">AppendList</span> l1 a1) == (<span class="type">AppendList</span> l2 a2) = a1 == a2 &amp;&amp; l1 == l2</span><br><span class="line">    _ == _                                   = <span class="type">False</span></span><br></pre></td></tr></table></figure><p>注意：<code>a</code>是一个类型，<code>ListOf a</code>是一个类型，但是 <strong><em>ListOf 不是类型，ListOf 不是类型，ListOf 不是类型。</em></strong> 这个定义表示：<code>ListOf a</code>满足<code>Eq</code> 仅当 <code>a</code>满足<code>Eq</code>。要查看类型的相关信息，可以在 GHCi 中执行<code>:info</code>指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*Main&gt; :info Eq</span><br><span class="line">class Eq a where</span><br><span class="line">  (&#x3D;&#x3D;) :: a -&gt; a -&gt; Bool</span><br><span class="line">  (&#x2F;&#x3D;) :: a -&gt; a -&gt; Bool</span><br><span class="line">  &#123;-# MINIMAL (&#x3D;&#x3D;) | (&#x2F;&#x3D;) #-&#125;</span><br><span class="line">  -- Defined in ‘GHC.Classes’</span><br><span class="line">instance [safe] Eq a &#x3D;&gt; Eq (ListOf a) -- Defined at [omitted]</span><br><span class="line">[... omitted ...]</span><br></pre></td></tr></table></figure><h1 id="也许是个单子"><a href="#也许是个单子" class="headerlink" title="也许是个单子"></a>也许是个单子</h1><p><code>Maybe a</code>类似Java中的<code>Optional&lt;T&gt;</code>，常用于表示“会失败”的函数。</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Maybe</span> a = <span class="type">Nothing</span> | <span class="type">Just</span> a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一些函数</span></span><br><span class="line"><span class="title">func1</span> :: <span class="type">Float</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">func2</span> :: <span class="type">Int</span> -&gt; <span class="type">Maybe</span> <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p><code>Monad</code>是个类型类</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; :info <span class="type">Monad</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad</span> (<span class="title">m</span> :: * -&gt; *) <span class="keyword">where</span></span></span><br><span class="line">  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line">  (&gt;&gt;) :: m a -&gt; m b -&gt; m b</span><br><span class="line">  return :: a -&gt; m a</span><br><span class="line">  fail :: <span class="type">String</span> -&gt; m a</span><br></pre></td></tr></table></figure><p>简化一下</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line">  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line">  return :: a -&gt; m a</span><br></pre></td></tr></table></figure><p>当我们说<code>Maybe</code>是一个<code>Monad</code>的时候，一方面指 Maybe 属于 Monad 这个类型类<code>instance Monad Maybe where ...</code>。另一方面指<code>Maybe(数据结构)</code>，<code>(&gt;&gt;=)::Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b (函数)</code>，<code>return::a -&gt; Maybe a (函数)</code>这三者构成了一个满足某些条件的数学结构，这些条件被称为<a href="https://wiki.haskell.org/Monad_laws" target="_blank" rel="noopener">Monad Laws</a>。事实上，Haskell编译器不会检查 Monad Laws 是否满足，你可以胡乱写一些数据结构和函数，然后将其塞入 Monad 这个类型类中。换句话说，Haskell中的Monad就是一个接口，任何实现接口的数据类型都可以称其为Monad。</p><p>回到<code>Maybe</code>上，现在你想把这两个会失败的函数连接在一起</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">func3</span> :: <span class="type">Float</span> -&gt; <span class="type">Maybe</span> <span class="type">Bool</span></span><br><span class="line"><span class="comment">-- 错误示范，类型不匹配</span></span><br><span class="line"><span class="comment">-- func3 = func2.func1</span></span><br><span class="line"><span class="comment">-- 正确示范</span></span><br><span class="line"><span class="title">func3</span> n = <span class="keyword">case</span> (func1 n) <span class="keyword">of</span></span><br><span class="line">    <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></span><br><span class="line">    <span class="type">Just</span> n' -&gt; func2 n'</span><br></pre></td></tr></table></figure><p>看上去不错，我们需要一种操作，能把任意两个可失败的函数连在一起，这样以后再碰到这种情况直接复用就行了。如果第一个函数类型是<code>a-&gt;Maybe b</code>，第二个函数类型是<code>b-&gt;Maybe c</code>，那么复合函数的类型应该是<code>a-&gt;Maybe c</code></p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">composite</span> :: (b -&gt; <span class="type">Maybe</span> c) -&gt; (a -&gt; <span class="type">Maybe</span> b) -&gt; (a -&gt; <span class="type">Maybe</span> c)</span><br><span class="line"><span class="title">composite</span> f g = \x -&gt;</span><br><span class="line">    <span class="keyword">case</span> g x <span class="keyword">of</span></span><br><span class="line">        <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></span><br><span class="line">        <span class="type">Just</span> y  -&gt; f y</span><br><span class="line"></span><br><span class="line"><span class="title">func3'</span> = composite func2 func1</span><br></pre></td></tr></table></figure><p>看上去不错，不过有个小问题，执行的第一步<code>g x</code>并不需要<code>composite</code>函数来操心，完全可以由调用者算好了传进来，于是我们再简化下</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">composite</span> :: (b -&gt; <span class="type">Maybe</span> c) -&gt; (<span class="type">Maybe</span> b) -&gt; (<span class="type">Maybe</span> c)</span><br><span class="line"><span class="title">composite</span> f gx =</span><br><span class="line">    <span class="keyword">case</span> gx <span class="keyword">of</span></span><br><span class="line">        <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></span><br><span class="line">        <span class="type">Just</span> y  -&gt; f y</span><br><span class="line"></span><br><span class="line"><span class="title">func3''</span> x = composite func2 (func1 x)</span><br></pre></td></tr></table></figure><p>只要交换一下两个参数的顺序，我们就有了<code>Monad Maybe</code>的<code>&gt;&gt;=</code>函数。对于<code>Maybe</code>来说，它恰好有一个操作能满足Monad的定义，于是<code>Maybe</code>就是一个Monad。</p><h1 id="做得越多，写得越少"><a href="#做得越多，写得越少" class="headerlink" title="做得越多，写得越少"></a>做得越多，写得越少</h1><p><code>do</code>是Haskell中的一个关于<code>&gt;&gt;=</code>的语法糖，考虑有多个“可失败”函数需要调用的情况</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f1</span> x = <span class="type">Just</span> (x+<span class="number">1</span>)</span><br><span class="line"><span class="title">f2</span> x = <span class="type">Just</span> (x*<span class="number">2</span>)</span><br><span class="line"><span class="title">f3</span> x = <span class="type">Just</span> (x<span class="number">-3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 &gt;&gt;= 函数</span></span><br><span class="line"><span class="title">just16</span> = (<span class="type">Just</span> <span class="number">5</span>)</span><br><span class="line">         &gt;&gt;= (\x -&gt; f1 (x+<span class="number">1</span>))</span><br><span class="line">         &gt;&gt;= (\y -&gt; f2 (y+<span class="number">2</span>))</span><br><span class="line">         &gt;&gt;= (\z -&gt; f3 (z+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 do 语法</span></span><br><span class="line"><span class="title">just16'</span> = <span class="keyword">do</span></span><br><span class="line">    x &lt;- <span class="type">Just</span> <span class="number">5</span></span><br><span class="line">    y &lt;- f1 (x+<span class="number">1</span>)</span><br><span class="line">    z &lt;- f2 (y+<span class="number">2</span>)</span><br><span class="line">    f3 (z+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><code>do</code>会按照规则展开成<code>&gt;&gt;=</code>函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do x &lt;- expr</span><br><span class="line">   more_exprs</span><br><span class="line">会被展开成</span><br><span class="line">expr &gt;&gt;&#x3D; (\x -&gt; more_exprs)</span><br></pre></td></tr></table></figure><p>因此两者是等价的。但是<code>do</code>语法更加整齐易于阅读。</p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul><li><a href="https://www.haskell.org/documentation/" target="_blank" rel="noopener">一大堆的资料</a></li><li><a href="http://learnyouahaskell.com/chapters" target="_blank" rel="noopener">Learn You a Haskell for Great Good!</a>: 是一本 Haskell 教程</li><li><a href="https://hoogle.haskell.org/" target="_blank" rel="noopener">Hoogle</a>：Haskell 函数查询工具</li><li><a href="https://www.google.com" target="_blank" rel="noopener">Google</a>：你永远的好伙伴 ;-)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;用任何你喜欢的方法安装 &lt;a href=&quot;https://www.haskell.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Glasgow Haskell Compiler&lt;/a&gt; (a.k.a. GHC)。Cabal 之类的&lt;br&gt;依赖管理系统就用不着了。 &lt;del&gt;因为我也不会用。&lt;/del&gt; 保证能够执行&lt;code&gt;ghc&lt;/code&gt;和&lt;code&gt;ghci&lt;/code&gt;命令就行。&lt;/p&gt;
&lt;h1 id=&quot;GHCi基础&quot;&gt;&lt;a href=&quot;#GHCi基础&quot; class=&quot;headerlink&quot; title=&quot;GHCi基础&quot;&gt;&lt;/a&gt;GHCi基础&lt;/h1&gt;&lt;p&gt;首先，把以下文件保存成&lt;code&gt;helloworld.hs&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;figcaption&gt;&lt;span&gt;helloworld.hs&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;hello, world&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后执行&lt;code&gt;ghci helloworld.hs&lt;/code&gt;，然后在&lt;code&gt;&amp;gt;&lt;/code&gt;提示符后输入&lt;code&gt;foo&lt;/code&gt;并回车&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GHCi, version 8.6.3: http:&amp;#x2F;&amp;#x2F;www.haskell.org&amp;#x2F;ghc&amp;#x2F;  :? for help&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[1 of 1] Compiling Main             ( helloworld.hs, interpreted )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ok, one module loaded.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*Main&amp;gt; foo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;hello, world&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*Main&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你可以使用&lt;code&gt;:r&lt;/code&gt;来重新载入文件，也可以使用&lt;code&gt;:l &amp;lt;文件名&amp;gt;&lt;/code&gt;来载入代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="编程" scheme="https://recursiveg.me/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Haskell" scheme="https://recursiveg.me/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>编写一个简易的Chrome扩展</title>
    <link href="https://recursiveg.me/2017/05/simple-chrome-extension/"/>
    <id>https://recursiveg.me/2017/05/simple-chrome-extension/</id>
    <published>2017-05-12T09:30:00.000Z</published>
    <updated>2020-01-12T19:20:05.830Z</updated>
    
    <content type="html"><![CDATA[<p>时隔半年的毫无诚心的流水帐作品。<br>假设读者有基础的Javascript能力。</p><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>常去的某资源站的某资源发布者喜欢把重要的内容加上花里胡哨的特殊效果并藏在页面的角落里。<br>虽说要尊重资源的发布者，不过这种给人添堵的行为实在令我感到不爽，于是研究了一下Chrome的扩展程序（Extension）。</p><h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><p>要干的事情有两件：</p><ol><li>将内容移到页面的显著位置</li><li><del>去掉辣眼睛的特殊效果</del> 好吧，其实这条并不重要，毕竟内容已经被移到显著位置了</li></ol><p>很自然的，直接用Javascript操纵DOM树即可实现希望的效果。<br>那么要怎么自动载入脚本呢？</p><a id="more"></a><h1 id="编写扩展"><a href="#编写扩展" class="headerlink" title="编写扩展"></a>编写扩展</h1><p>感谢Chrome提供了强大的扩展系统。自动载入脚本这种功能自然是小菜一碟啦。<br>首先编写一个脚本<code>content_script.js</code>操纵页面元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (page_require_modification()) &#123;</span><br><span class="line">    <span class="keyword">var</span> content = <span class="built_in">document</span>.getElementById(<span class="string">"hidden-div"</span>).innerHTML;</span><br><span class="line">    <span class="keyword">var</span> clean_content = <span class="built_in">document</span>.createElement(<span class="string">"p"</span>);</span><br><span class="line">    clean_content.append(<span class="built_in">document</span>.createTextNode(content));</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"main-div"</span>).append(clean_content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有魔法，想干啥就写啥，就像是HTML本身引用了一个JS文件一样。也不需要考虑<code>document.ready</code>的问题，因为Chrome默认会在文档加载完成后再加载自定义的JS。</p><p>接着需要一个<code>manifest.json</code>文件，这样Chrome才能将其作为一个Extension加载。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"manifest_version"</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"在这里填上扩展的名称"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"这里填一些描述"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">"content_scripts"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="attr">"matches"</span>: [<span class="string">"https://www.google.com/*"</span>],</span><br><span class="line">          <span class="attr">"js"</span>: [<span class="string">"content_script.js"</span>]</span><br><span class="line">      &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>你觉得我会把实际的URL写出来嘛？肯定不会啦！</del><br>Chrome把这种注入到页面中的脚本称做<code>content_scripts</code>。当页面的URL符合<code>matches</code>中的pattern时，就自动加载<code>js</code>中指定的脚本。当然，脚本的文件名可以自由决定，只要前后一致即可。</p><p>最后一步，将<code>manifest.json</code>和<code>content_script.js</code>放入同一个文件夹。然后在<code>chrome://extensions</code>选择<code>加载已解压的扩展程序</code>即可加载扩展啦。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>manifest.json</code>文件指示了一个Chrome扩展</li><li>Chrome扩展能将自定义脚本注入到符合指定URL的页面中</li><li>这种单纯的脚本注入任务可能Greasemonkey更适合一些，不过这次就先研究Chrome扩展啦~ 有机会再研究油猴脚本。</li><li>Chrome扩展可以和浏览器本身做到更紧密的结合，比如提供菜单项或者是GUI之类的，不过这篇文章完全没有涉及。</li><li><a href="https://developer.chrome.com/extensions" target="_blank" rel="noopener">Google的官方扩展指南</a>永远是你的好伙伴</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时隔半年的毫无诚心的流水帐作品。&lt;br&gt;假设读者有基础的Javascript能力。&lt;/p&gt;
&lt;h1 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h1&gt;&lt;p&gt;常去的某资源站的某资源发布者喜欢把重要的内容加上花里胡哨的特殊效果并藏在页面的角落里。&lt;br&gt;虽说要尊重资源的发布者，不过这种给人添堵的行为实在令我感到不爽，于是研究了一下Chrome的扩展程序（Extension）。&lt;/p&gt;
&lt;h1 id=&quot;基本思路&quot;&gt;&lt;a href=&quot;#基本思路&quot; class=&quot;headerlink&quot; title=&quot;基本思路&quot;&gt;&lt;/a&gt;基本思路&lt;/h1&gt;&lt;p&gt;要干的事情有两件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将内容移到页面的显著位置&lt;/li&gt;
&lt;li&gt;&lt;del&gt;去掉辣眼睛的特殊效果&lt;/del&gt; 好吧，其实这条并不重要，毕竟内容已经被移到显著位置了&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;很自然的，直接用Javascript操纵DOM树即可实现希望的效果。&lt;br&gt;那么要怎么自动载入脚本呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="编程" scheme="https://recursiveg.me/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="技术宅" scheme="https://recursiveg.me/tags/%E6%8A%80%E6%9C%AF%E5%AE%85/"/>
    
      <category term="Chrome" scheme="https://recursiveg.me/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>借助IPsec和strongSwan建立隧道并分配IPv6地址</title>
    <link href="https://recursiveg.me/2016/12/assign-ipv6-through-ipsec-and-strongswan/"/>
    <id>https://recursiveg.me/2016/12/assign-ipv6-through-ipsec-and-strongswan/</id>
    <published>2016-12-24T07:54:08.000Z</published>
    <updated>2020-01-12T19:20:06.296Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>在一年前，我写过一篇<a href="/2015/09/get-ipv6-via-gre-tunnel/">文章</a>，介绍利用GRE隧道将一台服务器的IPv6地址“分配”给另一台电脑，令其能访问IPv6网络的方法。<br>不过那种方法存在一些问题：</p><ul><li>不能通过NAT</li><li>数据不加密</li><li>需要在服务器手动更新IP</li></ul><p>于是热爱折腾<del>作死</del>的我研究了一下使用IPsec配合IKEv2对流量进行加密的方法。</p><p>服务器与本地均为ArchLinux（Arch大法好），strongSwan软件包可从AUR安装。<br>服务器需要至少有一个公网IPv4和一段Routed IPv6 Subnet。</p><a id="more"></a><h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><p>我们一共需要三对“密钥-证书”对：</p><ul><li>CA密钥和证书：用于签署其它的证书，同时CA证书需要分发到所有机器上。</li><li>服务器密钥和证书</li><li>客户端密钥和证书</li></ul><p>我使用了ECC证书，因为其具有更短的长度。如果老版本不支持ECC的，也可以使用RSA证书。<br>先生成三把私钥：</p><pre><code>certtool --generate-privkey --ecc --outfile ca.keycerttool --generate-privkey --ecc --outfile server.keycerttool --generate-privkey --ecc --outfile client.key</code></pre><p>然后自签名CA证书，<code>Common Name</code>可以随意填，但是和之后的配置一定要统一：</p><pre><code>certtool --generate-self-signed --load-privkey ca.key --outfile ca.crt</code></pre><p>接着再用CA证书签名其它两把密钥，<code>Common Name</code>同样可以随意填，但是不要一样：</p><pre><code>certtool --generate-certificate --load-ca-privkey ca.key --load-ca-certificate ca.crt --load-privkey server.key --outfile server.crtcerttool --generate-certificate --load-ca-privkey ca.key --load-ca-certificate ca.crt --load-privkey client.key --outfile client.crt</code></pre><p>这样就一共产生了六个文件，保存备用。</p><h2 id="服务端设置"><a href="#服务端设置" class="headerlink" title="服务端设置"></a>服务端设置</h2><p>首先需要把密钥文件放到对应的位置：</p><ul><li><code>ca.crt</code>放入<code>/etc/ipsec.d/cacerts/</code></li><li><code>server.key</code>放入<code>/etc/ipsec.d/private/</code></li><li><code>server.crt</code>放入<code>/etc/ipsec.d/certs/</code></li></ul><p>然后编辑<code>/etc/ipsec.secrets</code>文件，注意空格</p><pre><code>&quot;CN=IPsec server&quot; : ECDSA &quot;server.key&quot;</code></pre><p>前面<code>CN=...</code>那一串是证书的Subject，CN即Common Name，可以通过<code>certtool -i &lt; server.crt</code>查看。</p><p>最后编辑<code>/etc/ipsec.conf</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">config setup</span><br><span class="line">    charondebug&#x3D;&quot;cfg 2, dmn 2, ike 2, net 2&quot;</span><br><span class="line"></span><br><span class="line">conn serverconn #此处是链接名称，可以自由填写</span><br><span class="line">    left&#x3D;%any</span><br><span class="line">    leftcert&#x3D;server.crt</span><br><span class="line">    leftid&#x3D;&quot;&#123;这边填入server.crt的Subject&#125;&quot;</span><br><span class="line">    leftca&#x3D;&quot;&#123;这边填入ca.crt的Subject&#125;&quot;</span><br><span class="line">    leftsubnet&#x3D;::&#x2F;0     #表示整个IPv6网络都在这端</span><br><span class="line"></span><br><span class="line">    right&#x3D;%any</span><br><span class="line">    rightca&#x3D;&quot;&#123;这边填入ca.crt的Subject&#125;&quot;</span><br><span class="line">    rightsourceip&#x3D;2001:abc:def:123:456::&#x2F;80 #客户端IP所在的&#x2F;80段</span><br><span class="line"></span><br><span class="line">    auto&#x3D;add</span><br><span class="line">    keyexchange&#x3D;ikev2</span><br><span class="line">    ike&#x3D;aes256gcm128-sha2_512-modp4096! #选择你喜欢的加密方法</span><br></pre></td></tr></table></figure><p>然后打开IPv6 Forwarding并启动服务</p><pre><code>sudo sysctl net.ipv6.conf.all.forwarding=1sudo systemctl start strongswan</code></pre><h2 id="客户端设置"><a href="#客户端设置" class="headerlink" title="客户端设置"></a>客户端设置</h2><p>步骤基本相同。</p><ul><li><code>ca.crt</code>放入<code>/etc/ipsec.d/cacerts/</code></li><li><code>client.key</code>放入<code>/etc/ipsec.d/private/</code></li><li><code>client.crt</code>放入<code>/etc/ipsec.d/certs/</code></li><li>编辑<code>ipsec.secrets</code>为<code>&quot;CN=...&quot; : ECDSA &quot;client.key&quot;</code></li></ul><p>编辑<code>/etc/ipsec.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">config setup</span><br><span class="line">    charondebug&#x3D;&quot;cfg 2, dmn 2, ike 2, net 2&quot;</span><br><span class="line"></span><br><span class="line">conn clientconn #此处是链接名称，可以自由填写</span><br><span class="line">    left&#x3D;%any</span><br><span class="line">    leftcert&#x3D;client.crt</span><br><span class="line">    leftsourceip&#x3D;%config6 #从服务器获取一个IPv6地址</span><br><span class="line"></span><br><span class="line">    right&#x3D;&#123;这里填上你服务器的IPv4地址&#125;</span><br><span class="line">    rightid&#x3D;&quot;&#123;这边填入server.crt的Subject&#125;&quot;</span><br><span class="line">    rightsubnet&#x3D;::&#x2F;0 #表示整个IPv6网络都在另一端</span><br><span class="line"></span><br><span class="line">    auto&#x3D;start        #自动连接</span><br><span class="line">    dpdaction&#x3D;restart #自动重连</span><br><span class="line">    keyexchange&#x3D;ikev2</span><br><span class="line">    ike&#x3D;aes256gcm128-sha2_512-modp4096!</span><br></pre></td></tr></table></figure><p>然后执行<code>sudo ipsec start --nofork</code>，如果出现<code>keeping connection path</code>字样应该就连接成功了。网卡上会出现一个新的IPv6地址，然后就可以直接访问IPv6网络了。</p><p>如果连接不成功或者是无法访问网络，可以考虑检查一下防火墙是不是把数据包drop了。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://wiki.strongswan.org/projects/strongswan/wiki" target="_blank" rel="noopener">strongSwan Wiki</a> strongSwan的官方文档库，同时提供了很多IPsec的资料</li><li><a href="https://www.gnutls.org/manual/html_node/certtool-Invocation.html" target="_blank" rel="noopener">certtool使用手册</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;在一年前，我写过一篇&lt;a href=&quot;/2015/09/get-ipv6-via-gre-tunnel/&quot;&gt;文章&lt;/a&gt;，介绍利用GRE隧道将一台服务器的IPv6地址“分配”给另一台电脑，令其能访问IPv6网络的方法。&lt;br&gt;不过那种方法存在一些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能通过NAT&lt;/li&gt;
&lt;li&gt;数据不加密&lt;/li&gt;
&lt;li&gt;需要在服务器手动更新IP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是热爱折腾&lt;del&gt;作死&lt;/del&gt;的我研究了一下使用IPsec配合IKEv2对流量进行加密的方法。&lt;/p&gt;
&lt;p&gt;服务器与本地均为ArchLinux（Arch大法好），strongSwan软件包可从AUR安装。&lt;br&gt;服务器需要至少有一个公网IPv4和一段Routed IPv6 Subnet。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Networking" scheme="https://recursiveg.me/tags/Networking/"/>
    
      <category term="IPsec" scheme="https://recursiveg.me/tags/IPsec/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境TCP Socket与Epoll使用备忘</title>
    <link href="https://recursiveg.me/2015/12/linux-socket-epoll-demo/"/>
    <id>https://recursiveg.me/2015/12/linux-socket-epoll-demo/</id>
    <published>2015-12-25T11:15:13.000Z</published>
    <updated>2020-01-12T19:20:06.730Z</updated>
    
    <content type="html"><![CDATA[<p>流水帐式地记录了 Linux 下 TCP Socket 通信的方法和基本的 Epoll 使用方法。<br>没有错误处理。</p><h2 id="地址解析"><a href="#地址解析" class="headerlink" title="地址解析"></a>地址解析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">listen_addr</span>;</span> <span class="comment">//存放解析结果。参见`man getaddrinfo`</span></span><br><span class="line">getaddrinfo(<span class="string">"0.0.0.0"</span>, <span class="string">"55553"</span>, <span class="literal">NULL</span>, &amp;listen_addr); <span class="comment">// getaddrinfo([主机名],[端口],[hint],[结果])。成功返回 `0`</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">freeaddrinfo(listen_addr); <span class="comment">//释放资源，返回void</span></span><br></pre></td></tr></table></figure><h2 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h2><p>这种方式只能同时处理一个连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// int socket(int domain, int type, int protocol); 参见`man 3 socket` 创建文件描述符， 出错返回-1</span></span><br><span class="line">bind(fd, listen_addr-&gt;ai_addr, listen_addr-&gt;ai_addrlen);</span><br><span class="line">    <span class="comment">// int bind(int socket, const struct sockaddr *address,socklen_t address_len);</span></span><br><span class="line">    <span class="comment">// 绑定地址，出错返回-1，参见`man 3 bind`</span></span><br><span class="line"><span class="built_in">listen</span>(fd, SOMAXCONN);</span><br><span class="line">    <span class="comment">// int listen(int fd, int backlog(最大队列长度))</span></span><br><span class="line">    <span class="comment">// 开始监听，出错返回-1</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> new_fd = accept(fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// accept([fd], [监听地址], [监听地址结构体长度]) 第2，3个参数同bind()</span></span><br><span class="line">        <span class="comment">// 接受连接请求，若无请求则阻塞(也有可能是EAGAIN,取决于你需要什么)</span></span><br><span class="line">        <span class="comment">// 返回用于和对端通信的新的文件描述符,出错返回-1</span></span><br><span class="line">    <span class="comment">// ... handle(new_fd);</span></span><br><span class="line">    <span class="built_in">close</span>(new_fd); <span class="comment">// 关闭文件描述符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">server_addr</span>;</span></span><br><span class="line">getaddrinfo(<span class="string">"127.0.0.1"</span>, <span class="string">"55553"</span>, <span class="literal">NULL</span>, &amp;server_addr);</span><br><span class="line"><span class="keyword">int</span> server_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">connect</span>(server_socket, server_addr-&gt;ai_addr, server_addr-&gt;ai_addrlen)</span><br><span class="line">    <span class="comment">// 基本同bind() 参见 man 3 connect</span></span><br><span class="line">    <span class="comment">// 成功后可用server_socket与服务器通信</span></span><br><span class="line"><span class="comment">// ... send(...)</span></span><br><span class="line"><span class="comment">// ... recv(...)</span></span><br><span class="line"><span class="built_in">close</span>(server_socket);</span><br><span class="line">freeaddrinfo(server_addr);</span><br></pre></td></tr></table></figure><h2 id="传送数据"><a href="#传送数据" class="headerlink" title="传送数据"></a>传送数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *payload = <span class="string">"hello"</span></span><br><span class="line">send(new_fd, payload, <span class="built_in">strlen</span>(payload), <span class="number">0</span>); <span class="comment">// send([fd], [buffer], [需发送消息长度], [flag]) 返回实际发送的消息长度</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">255</span>];</span><br><span class="line">recv(new_fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>); <span class="comment">// send([fd], [buffer], [最大接收消息长度], [flag]) 返回实际接收的消息长度。阻塞模式下，若无消息则阻塞</span></span><br></pre></td></tr></table></figure><h2 id="多进程请求处理"><a href="#多进程请求处理" class="headerlink" title="多进程请求处理"></a>多进程请求处理</h2><p>对于每一个请求fork()一个新的进程进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> new_fd = accept(fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123; <span class="comment">// fork()返回0说明是子进程</span></span><br><span class="line">        <span class="comment">// ... handle(new_fd);</span></span><br><span class="line">        <span class="built_in">close</span>(new_fd);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> epollfd = epoll_create(<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">// 创建epoll文件描述符，出错返回-1</span></span><br><span class="line">    <span class="comment">// int epoll_create(int size) 从Linux2.6.8开始，size值被忽略，不过为保持兼容需要设定为一个正整数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span> <span class="comment">// 记录套接字相关信息</span></span><br><span class="line">ev.events = EPOLLIN; <span class="comment">// 监视有数据可读事件</span></span><br><span class="line">ev.data.fd = fd; <span class="comment">// 文件描述符数据，其实这里可以放任何数据。</span></span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;ev);</span><br><span class="line">    <span class="comment">// int epoll_ctl([Epoll FD], [Operation], [fd], [epoll_event]);</span></span><br><span class="line">    <span class="comment">// 加入监听列表，当fd上有对应事件产生时，epoll_wait会将epoll_event填充到events_in数组里</span></span><br><span class="line">    <span class="comment">// 出错返回-1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events_in</span>[16];</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> event_count = epoll_wait(epollfd, events_in, <span class="number">16</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 等待事件，epoll_wait会将事件填充至events_in内</span></span><br><span class="line">        <span class="comment">// int epoll_wait([epoll fd], struct epoll_event *events, [最大事件数量], int timeout);</span></span><br><span class="line">        <span class="comment">// 返回 获得的事件数量，若超时且没有任何事件返回0，出错返回-1。timeout设置为-1表示无限等待。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;event_count; i++) &#123; <span class="comment">// 遍历所有事件</span></span><br><span class="line">        <span class="keyword">if</span> (events_in[i].data.fd == fd) &#123; <span class="comment">// 新连接请求</span></span><br><span class="line">            <span class="keyword">int</span> new_fd = accept(fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            ev.events = EPOLLIN; <span class="comment">// 参见man 7 epoll 如果要使用Edge Trigger还需将new_fd设为非阻塞</span></span><br><span class="line">            ev.data.fd = new_fd;</span><br><span class="line">            epoll_ctl(epollfd, EPOLL_CTL_ADD, new_fd, &amp;ev); <span class="comment">// 将新连接加入监视列表</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> new_fd = events_in[i].data.fd;</span><br><span class="line">            <span class="comment">// ... handle(new_fd);</span></span><br><span class="line">            epoll_ctl(epollfd, EPOLL_CTL_DEL, new_fd, <span class="literal">NULL</span>); <span class="comment">// 不再监听fd，最后一个参数被忽略</span></span><br><span class="line">            <span class="built_in">close</span>(new_fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><ul><li><a href="http://www.linux-mag.com/id/308/" target="_blank" rel="noopener">Blocking 与 Non-Blocking I/O</a></li><li><a href="http://www.ccvita.com/515.html" target="_blank" rel="noopener">Epoll 的 Edge-Trigger 与 Level-Trigger</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;流水帐式地记录了 Linux 下 TCP Socket 通信的方法和基本的 Epoll 使用方法。&lt;br&gt;没有错误处理。&lt;/p&gt;
&lt;h2 id=&quot;地址解析&quot;&gt;&lt;a href=&quot;#地址解析&quot; class=&quot;headerlink&quot; title=&quot;地址解析&quot;&gt;&lt;/a&gt;地址解析&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;addrinfo&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;listen_addr&lt;/span&gt;;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//存放解析结果。参见`man getaddrinfo`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getaddrinfo(&lt;span class=&quot;string&quot;&gt;&quot;0.0.0.0&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;55553&quot;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &amp;amp;listen_addr); &lt;span class=&quot;comment&quot;&gt;// getaddrinfo([主机名],[端口],[hint],[结果])。成功返回 `0`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;freeaddrinfo(listen_addr); &lt;span class=&quot;comment&quot;&gt;//释放资源，返回void&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;监听&quot;&gt;&lt;a href=&quot;#监听&quot; class=&quot;headerlink&quot; title=&quot;监听&quot;&gt;&lt;/a&gt;监听&lt;/h2&gt;&lt;p&gt;这种方式只能同时处理一个连接&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fd = socket(AF_INET, SOCK_STREAM, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// int socket(int domain, int type, int protocol); 参见`man 3 socket` 创建文件描述符， 出错返回-1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bind(fd, listen_addr-&amp;gt;ai_addr, listen_addr-&amp;gt;ai_addrlen);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// int bind(int socket, const struct sockaddr *address,socklen_t address_len);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 绑定地址，出错返回-1，参见`man 3 bind`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;listen&lt;/span&gt;(fd, SOMAXCONN);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// int listen(int fd, int backlog(最大队列长度))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 开始监听，出错返回-1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; new_fd = accept(fd, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// accept([fd], [监听地址], [监听地址结构体长度]) 第2，3个参数同bind()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 接受连接请求，若无请求则阻塞(也有可能是EAGAIN,取决于你需要什么)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 返回用于和对端通信的新的文件描述符,出错返回-1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ... handle(new_fd);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;close&lt;/span&gt;(new_fd); &lt;span class=&quot;comment&quot;&gt;// 关闭文件描述符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="Epoll" scheme="https://recursiveg.me/tags/Epoll/"/>
    
      <category term="Socket" scheme="https://recursiveg.me/tags/Socket/"/>
    
      <category term="TCP" scheme="https://recursiveg.me/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Linux下建立GRE隧道并获取IPv6地址</title>
    <link href="https://recursiveg.me/2015/09/get-ipv6-via-gre-tunnel/"/>
    <id>https://recursiveg.me/2015/09/get-ipv6-via-gre-tunnel/</id>
    <published>2015-09-19T06:35:10.000Z</published>
    <updated>2020-01-12T19:20:07.180Z</updated>
    
    <content type="html"><![CDATA[<p>虽然HE有提供免费的Tunnelbroker，不过那速度实在不怎么样。于是考虑在有IPv6地址托管主机上建立一个GRE Tunnel。<br>GRE Tunnel需要有内核模块<code>ip_gre</code>支持。远程主机有一段/64的IPv6，我将其中的一段/80分配给自己的机器。<br>使用iproute2工具。当然，你自己的机器需要有一个公网IPv4地址。</p><ol><li>服务器的公网IPv4是<code>$server_ipv4</code></li><li>自己电脑（或者路由器）的公网IPv4是<code>$client_ipv4</code>。</li><li>服务器的IPv6段是<code>a:b:c:d::/64</code></li><li>要分配下去的IPv6段是<code>a:b:c:d:e::/80</code></li></ol><h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><p>脚本如下，需要root，建议用<code>sudo -i</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip tunnel add gre-tunnel mode gre remote <span class="variable">$client_ipv4</span> ttl 64</span><br><span class="line">ip link <span class="built_in">set</span> gre-tunnel up</span><br><span class="line">ip addr add a:b:c:d:e::1/80 dev gre-tunnel</span><br></pre></td></tr></table></figure><ul><li>第一行建立隧道，<code>gre-tunnel</code>是隧道名称，可以按自己喜欢的来，记得其他的也要一起改</li><li>第二行激活隧道</li><li>第三行分配IP地址</li></ul><a id="more"></a><h2 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h2><p>脚本如下，和服务端配置几乎一样，同样需要root：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip tunnel add gre-tunnel mode gre remote <span class="variable">$server_ipv4</span> ttl 64</span><br><span class="line">ip link <span class="built_in">set</span> gre-tunnel up</span><br><span class="line">ip addr add a:b:c:d:e::2/80 dev gre-tunnel</span><br><span class="line">ip -6 route add default dev gre-tunnel</span><br></pre></td></tr></table></figure><ul><li>第一行建立隧道，隧道名称不必和服务器的一样</li><li>第二行激活隧道</li><li>第三行分配IP地址，注意不要和服务器的冲突，这个IP也是将要暴露在网络上的IP</li><li>第四行设定路由，让IPv6流量都走隧道</li></ul><h2 id="访问网络"><a href="#访问网络" class="headerlink" title="访问网络"></a>访问网络</h2><p>现在，两台机器应该可以互ping了。有的比较奇葩的情况可能需要手动<code>ip link set gre0 up</code>一下，gre0似乎是内核模块自动加入的玩意儿，具体怎么回事我也不清楚--_--|<br>但是现在还不能访问外网，还需要在服务器执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv6.conf.all.forwarding=1</span><br><span class="line">sysctl net.ipv6.conf.all.proxy_ndp=1</span><br><span class="line">ip -6 neigh add proxy a:b:c:d:e::2 dev eth0</span><br></pre></td></tr></table></figure><p>第一行开启forward<br>二三行和IPv6的NDP(邻居发现)有关，又是个没搞明白的东西真是残念......<br>eth0是服务器实际连接网络的接口。</p><h2 id="删除-amp-修改"><a href="#删除-amp-修改" class="headerlink" title="删除 &amp; 修改"></a>删除 &amp; 修改</h2><p>要删除Tunnel，在两端均执行:</p><pre><code>ip link set gre-tunnel downip tunnel del gre-tunnel</code></pre><p>如果客户端IP变化:</p><pre><code>ip tunnel change gre-tunnel remote $new_client_ipv4</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>虽然叫做“隧道”，但是内容依然是<em>明文</em>，对保密要求高的同学们要注意了。<br>另外直接用命令建立的隧道在重启后会没有，所以可以考虑用networkd之类的东西来管理。<br>Linux在访问有IPv6地址的域名时会优先使用IPv6，所以要当心服务器流量爆炸。当然配置成IPv4优先也是可以的。<br>如果你的本地IPv4经常变动的话，你可能需要些脚本之类的东西自动更新服务器的Remote IP。<br>对于每一个新的IP(新的设备)，都需要在服务端执行<code>ip -6 neigh add</code>，有知道怎么解决这个问题的请务必留言...</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然HE有提供免费的Tunnelbroker，不过那速度实在不怎么样。于是考虑在有IPv6地址托管主机上建立一个GRE Tunnel。&lt;br&gt;GRE Tunnel需要有内核模块&lt;code&gt;ip_gre&lt;/code&gt;支持。远程主机有一段/64的IPv6，我将其中的一段/80分配给自己的机器。&lt;br&gt;使用iproute2工具。当然，你自己的机器需要有一个公网IPv4地址。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务器的公网IPv4是&lt;code&gt;$server_ipv4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;自己电脑（或者路由器）的公网IPv4是&lt;code&gt;$client_ipv4&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;服务器的IPv6段是&lt;code&gt;a:b:c:d::/64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;要分配下去的IPv6段是&lt;code&gt;a:b:c:d:e::/80&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;服务器配置&quot;&gt;&lt;a href=&quot;#服务器配置&quot; class=&quot;headerlink&quot; title=&quot;服务器配置&quot;&gt;&lt;/a&gt;服务器配置&lt;/h2&gt;&lt;p&gt;脚本如下，需要root，建议用&lt;code&gt;sudo -i&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ip tunnel add gre-tunnel mode gre remote &lt;span class=&quot;variable&quot;&gt;$client_ipv4&lt;/span&gt; ttl 64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ip link &lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt; gre-tunnel up&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ip addr add a:b:c:d:e::1/80 dev gre-tunnel&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;第一行建立隧道，&lt;code&gt;gre-tunnel&lt;/code&gt;是隧道名称，可以按自己喜欢的来，记得其他的也要一起改&lt;/li&gt;
&lt;li&gt;第二行激活隧道&lt;/li&gt;
&lt;li&gt;第三行分配IP地址&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="GRE Tunnel" scheme="https://recursiveg.me/tags/GRE-Tunnel/"/>
    
      <category term="IPv6" scheme="https://recursiveg.me/tags/IPv6/"/>
    
  </entry>
  
  <entry>
    <title>IDEA下建立Forge开发环境的正确姿势</title>
    <link href="https://recursiveg.me/2014/12/setup-forge-workspace-with-idea/"/>
    <id>https://recursiveg.me/2014/12/setup-forge-workspace-with-idea/</id>
    <published>2014-12-11T06:17:48.000Z</published>
    <updated>2020-01-12T19:20:07.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>本文作于2014年末，其中记载的方法可能已经过期，请读者谨慎参考</strong><br>见过不少教程都是基于Eclipse的，而基于IDEA的文章少得可怜，遂决定写此文。<br>本文通篇基于Linux/IntellijIDEA进行讲解，Windows/MAC/Eclipse用户请自行依葫芦画瓢。</p><h1 id="设置Forge工作区"><a href="#设置Forge工作区" class="headerlink" title="设置Forge工作区"></a>设置Forge工作区</h1><p>当然，你得首先去<a href="http://files.minecraftforge.net/" target="_blank" rel="noopener">MinecraftForge</a>下载一份源代码。我这里用的是最新的<code>forge-1.7.10-10.13.2.1258-src.zip</code><br>接着，找个地方建立一个文件夹，这将是你的工程目录，我的叫做<code>Forge1.7.10-1258</code>。然后再在里面建立一个目录，比方说就叫<code>forge-1.7.10-10.13.2.1258-src</code>，把你的Forge源码解压进去。<br>现在，你的文件夹层次应该看起来是这样的：</p><pre><code>Forge1.7.10-1258└── forge-1.7.10-10.13.2.1258-src     ├── build.gradle     ├── CREDITS-fml.txt     ├── eclipse     ├── forge-1.7.10-10.13.2.1258-changelog.txt     ├── gradle     ├── gradlew     ├── gradlew.bat     ├── LICENSE-fml.txt     ├── MinecraftForge-Credits.txt     ├── MinecraftForge-License.txt     ├── README.txt     └── src</code></pre><p>你可以先按自己喜好改动一下<code>build.gradle</code>。比如，我喜欢手动指定一下mappings的版本：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">minecraft &#123;</span><br><span class="line">    version = <span class="string">"1.7.10-10.13.2.1258"</span></span><br><span class="line">    runDir = <span class="string">"eclipse"</span></span><br><span class="line">    mappings = <span class="string">"stable_12"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，cd到forge-1.7.10-10.13.2.1258-src目录下，执行如下两条命令：</p><pre><code>gradle -i setupDecompWorkspacegradle -i ideaModule</code></pre><p>然后请耐心等待指令完成，可以去喝杯牛奶睡个觉什么的。</p><a id="more"></a><h1 id="导入到IDEA"><a href="#导入到IDEA" class="headerlink" title="导入到IDEA"></a>导入到IDEA</h1><p>等以上操作完成后，就可以打开IDEA，选“Create New Project”，注意要建立一个<strong>空工程</strong>（Empty Project）</p><p><img src="/images/setup-forge-workspace-with-idea/1.png" alt="Create New Project"><br>&quot;Project Name&quot;自然可以随意填写，&quot;Project Location&quot;则是之前创建的目录，下方的&quot;Project Format&quot;推荐选&quot;Directory Based&quot;<br>点&quot;Finish&quot;之后应该会自动打开&quot;Project Structure&quot;窗口，如果没有的话可以按Ctrl+Alt+Shift+S或是从菜单栏&quot;File --&gt; Project Structure&quot;<br>打开窗口之后我们首先要选择SDK版本：先点左边的&quot;Project&quot;，然后在右边&quot;Project SDK&quot;里选一个，我是选了Java8，你当然可以选择任何版本（不要低于Java6）<br><img src="/images/setup-forge-workspace-with-idea/2.png" alt="Select Project SDK"><br>接着点左边的&quot;Modules&quot;,再点那个绿色的“+”号，接着选&quot;Import Module&quot;<br><img src="/images/setup-forge-workspace-with-idea/3.png" alt="Location of &quot;Import Module&quot;"><br>然后选forge-1.7.10-10.13.2.1258-src目录下的<code>forge-1.7.10-10.13.2.1258-src.iml</code>文件就好。<br>Import完了之后检查下有没有报错，如果没问题就可以点右下角OK。</p><p>重新cd到forge-1.7.10-10.13.2.1258-src目录下，执行如下三条命令让gradle自动建立运行配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ln -s ../.idea .</span><br><span class="line">gradle -i genIntellijRun</span><br><span class="line">rm .idea</span><br></pre></td></tr></table></figure><p>回到IDEA，然后有必要的话重新加载一下Project。继续选菜单栏&quot;Run --&gt; Edit Configurations&quot;,点左侧的&quot;Minecraft Client&quot;，修改&quot;Working Directory&quot;到<code>forge-1.7.10-10.13.2.1258-src/eclipse</code>。<br><img src="/images/setup-forge-workspace-with-idea/4.png" alt="Edit Configuration"><br>你也可以像我一样指定一个username。接着对&quot;Minecraft Server&quot;也如法炮制。然后右下角&quot;OK&quot;退出。</p><p>现在Forge应该就可以运行了，在IDEA的主界面右上角有这么一片区域，选&quot;Minecraft Client&quot;然后点右侧那个绿色的三角箭头即可<br><img src="/images/setup-forge-workspace-with-idea/5.png" alt="Execution Control Bar"></p><h1 id="一个Mod！"><a href="#一个Mod！" class="headerlink" title="一个Mod！"></a>一个Mod！</h1><p>如果之前的步骤都没有问题，你就可以继续了<br>为了更好地演示运行配置以及发布流程，我决定写一个Mod，添加一种矿石：“Xp Ore”,顾名思义，挖掉后能得到大量经验。</p><p>我们需要新建一个Module来写我们的代码：菜单栏&quot;File --&gt; New Module&quot;<br>我就叫XpOre好了，然后继续打开&quot;Project Structure&quot;，将<code>forge-1.7.10-10.13.2.1258-src</code>添加成为它的依赖。<br><img src="/images/setup-forge-workspace-with-idea/6.png" alt="Add to Dependencies"><br>那个菜单同样是点右边的绿色加号出来，点&quot;Module Dependency&quot;后在弹出来的窗口里选&quot;forge-1.7.10-10.13.2.1258-src&quot;然后&quot;OK&quot;即可。</p><p>之后就可以写Mod了！至于具体Mod怎么写我就不在这里提了，请各位参考其他文章。<br>这是我的代码和目录层次结构，请自行调整，我就不把每一步的细节都写出来了。<br>请记得把<code>java</code>和<code>resources</code>两个目录设置成代码根目录和资源根目录，具体方法是在文件夹上右键然后&quot;Mark Directory As&quot;<br><img src="/images/setup-forge-workspace-with-idea/7.png" alt="The Module Tree"><br>（xp_ore.png是矿石的材质，其实就是拿金矿石的材质把几个像素涂成绿色让它看起来比较像附魔瓶的颜色）<br>为了防止图挂，我再拿文本形式列一下目录</p><pre><code>XpOre├── src│   └── main│       ├── java (Sources Root)│       │   └── org│       │       └── devinprogress│       │           └── xpore│       │               └── XpOre.java│       └── resources (Resources Root)│           ├── assets│           │   └── xpore│           │       ├── lang│           │       │   └── en_US.lang│           │       └── textures│           │           └── blocks│           │               └── xp_ore.png│           └── mcmod.info└── XpOre.iml</code></pre><p>要想让这个Mod在IDEA里运行起来，有两种方式。第一种比较简单，直接菜单栏&quot;Run --&gt; Edit Configurations --&gt; &#39;Minecraft Client&#39; --&gt; Use classpath of mod ...&quot;下拉列表里选&quot;XpOre&quot;，保存退出运行即可。这种方式比较适合只开发一个Mod的情况。<br>当有N个Module互相依赖的时候，我推荐创建另一个Module，比方说，叫&quot;Run&quot;。然后令其依赖<code>forge-1.7.10-10.13.2.1258-src</code>和你需要加载的其他Module，然后&quot;Use classpath of mod&quot;选择&quot;Run&quot;即可。</p><h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><p>发布其实相当方便，把forge-1.7.10-10.13.2.1258-src文件夹里的<code>build.gradle</code>复制到<code>XpOre</code>文件夹下面<br>按自己喜好修改其中的<code>version</code>,<code>group</code>和<code>archivesBaseName</code>即可。比方说我的是：</p><pre><code>version = &quot;v0.1&quot;group= &quot;org.devinprogress.xpore&quot;archivesBaseName = &quot;XpOre-1.7.10&quot;</code></pre><p>然后在XpOre文件夹下<code>gradle build</code>即可。运行完成后，就能在<code>XpOre/build/libs/</code>文件夹下找到编译好的jar了。</p><p>最后来一张Mod的效果图<br><img src="/images/setup-forge-workspace-with-idea/8.png" alt="XpOre Mod"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;本文作于2014年末，其中记载的方法可能已经过期，请读者谨慎参考&lt;/strong&gt;&lt;br&gt;见过不少教程都是基于Eclipse的，而基于IDEA的文章少得可怜，遂决定写此文。&lt;br&gt;本文通篇基于Linux/IntellijIDEA进行讲解，Windows/MAC/Eclipse用户请自行依葫芦画瓢。&lt;/p&gt;
&lt;h1 id=&quot;设置Forge工作区&quot;&gt;&lt;a href=&quot;#设置Forge工作区&quot; class=&quot;headerlink&quot; title=&quot;设置Forge工作区&quot;&gt;&lt;/a&gt;设置Forge工作区&lt;/h1&gt;&lt;p&gt;当然，你得首先去&lt;a href=&quot;http://files.minecraftforge.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MinecraftForge&lt;/a&gt;下载一份源代码。我这里用的是最新的&lt;code&gt;forge-1.7.10-10.13.2.1258-src.zip&lt;/code&gt;&lt;br&gt;接着，找个地方建立一个文件夹，这将是你的工程目录，我的叫做&lt;code&gt;Forge1.7.10-1258&lt;/code&gt;。然后再在里面建立一个目录，比方说就叫&lt;code&gt;forge-1.7.10-10.13.2.1258-src&lt;/code&gt;，把你的Forge源码解压进去。&lt;br&gt;现在，你的文件夹层次应该看起来是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Forge1.7.10-1258
└── forge-1.7.10-10.13.2.1258-src
     ├── build.gradle
     ├── CREDITS-fml.txt
     ├── eclipse
     ├── forge-1.7.10-10.13.2.1258-changelog.txt
     ├── gradle
     ├── gradlew
     ├── gradlew.bat
     ├── LICENSE-fml.txt
     ├── MinecraftForge-Credits.txt
     ├── MinecraftForge-License.txt
     ├── README.txt
     └── src&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你可以先按自己喜好改动一下&lt;code&gt;build.gradle&lt;/code&gt;。比如，我喜欢手动指定一下mappings的版本：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;minecraft &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    version = &lt;span class=&quot;string&quot;&gt;&quot;1.7.10-10.13.2.1258&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    runDir = &lt;span class=&quot;string&quot;&gt;&quot;eclipse&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mappings = &lt;span class=&quot;string&quot;&gt;&quot;stable_12&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;接着，cd到forge-1.7.10-10.13.2.1258-src目录下，执行如下两条命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gradle -i setupDecompWorkspace
gradle -i ideaModule&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后请耐心等待指令完成，可以去喝杯牛奶睡个觉什么的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Minecraft" scheme="https://recursiveg.me/tags/Minecraft/"/>
    
      <category term="Java" scheme="https://recursiveg.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Minecraft Coremod开发杂事记</title>
    <link href="https://recursiveg.me/2014/11/minecraft-modding-with-asm/"/>
    <id>https://recursiveg.me/2014/11/minecraft-modding-with-asm/</id>
    <published>2014-11-04T13:48:53.000Z</published>
    <updated>2020-01-12T19:20:08.093Z</updated>
    
    <content type="html"><![CDATA[<p>表示最近时间荒废得厉害，主要都是耗在了<a href="http://www.minecraft.net" target="_blank" rel="noopener">Minecraft</a>这款游戏上。<br>Minecraft的一大魅力在于其几乎无穷的MODs，于是我也小试了一下Mod开发，顺便学习一下Java。<del>于是掉入了万劫不复的深坑</del><br>当然，我要做点和加个方块、改个合成表之类的不一样的事。<br>（教程中不少内容都参考了szszss的<a href="http://www.hakugyokurou.net/wordpress/?page_id=126" target="_blank" rel="noopener">博客</a>，在此表示深深的感谢）</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>关于这篇文章，不适合特别特别新的新人，我假设各位读者都有一些基础的编程经验。如果你是入门级别的，在MCBBS论坛的<a href="http://www.mcbbs.net/thread-54579-1-1.html" target="_blank" rel="noopener">编程开发板块</a>有不少不错的入门教程。<br>我假设各位读者都具备以下能力:</p><ul><li>会安装软件</li><li>了解基本的程序流程控制，比如判断、循环等</li><li>了解基本的OOP概念，比如类，继承等 （其实这条不是那么重要，Java看多了就自然会了 <del>一个原C程序员如是说</del>）</li><li>了解命令行、终端的基本使用方法</li><li>有方法正常访问国际互联网，如Facebook等</li><li>了解基本英语单词（这条似乎也不是那么重要，主要是希望大家能够在遇到问题时不要怕阅读英文资料）</li><li>（本教程面向Linux用户，Mac用户大同小异，Windows用户自己看着办）</li></ul><a id="more"></a><p>然后再来介绍一下要用到的工具:</p><ul><li><a href="http://mcp.ocean-labs.de/" target="_blank" rel="noopener">MCP</a>(Minecraft Coders&#39; Pack)主要负责反混淆Minecraft的代码，同时向Forge提供对应的文档</li><li><a href="http://files.minecraftforge.net/fml/" target="_blank" rel="noopener">FML</a>(Forge Mod Loader)提供了一些底层功能，如Mod加载，ASM等。</li><li><a href="http://www.minecraftforge.net" target="_blank" rel="noopener">Forge</a>提供了更高级的接口，如增加方块，修改合成表等。</li><li>ForgeGradle帮助建立开发环境和发布</li></ul><p>一般来说，FML都会附带在Forge里，在某些情况下，比如现在（2014年11月5日）1.8的Forge还未完成，但FML已放出，就可以单独只安装FML，先开始Coremod的开发。</p><h1 id="Intellij-IDEA配置教程"><a href="#Intellij-IDEA配置教程" class="headerlink" title="Intellij IDEA配置教程"></a>Intellij IDEA配置教程</h1><p>网上大部分教程都是讲Eclipse的，但是个人偏好IDEA，所以讲一下IDEA的配置流程。</p><ol><li><p>安装IDEA，没有必要找破解版，免费的Community Edition足够</p></li><li><p><a href="http://files.minecraftforge.net/" target="_blank" rel="noopener">下载</a>Forge代码，就是Src那个链接。请选择自己需要的版本，我以<code>1.7.10-Recommended</code>为例</p></li><li><p>解压到一个你看着顺眼的地方，然后依次执行以下命令</p><pre><code>gradle setupDecompWorkspacegradle ideagradle genIntellijRun</code></pre><p>没有装gradle也不想装的，可以用<code>./gradlew</code><br>强烈建议挂着代理或VPN做这事，否则将是极端痛苦的过程。<br>你也可以加上<code>-i</code>选项看滚滚的数据输出以不至于那么无聊。</p></li><li><p>打开IDEA，直接Open Project，选择目录下的.ipr文件应该就好了，你可以试着Run一下看看有没有什么问题。</p></li></ol><p>注：直接<code>gradle idea</code>现在是不被推荐的，可以尝试用<code>gradle ideaModule</code>代替，具体方法在<a href="/2014/12/setup-forge-workspace-with-idea/">我的另一篇日志</a>里有讲。<br>如果需要Socks代理的，可以这么来<code>gradle -DsocksProxyHost={代理服务器地址} -DsocksProxyPort={代理端口}</code></p><h1 id="代码管理与开发"><a href="#代码管理与开发" class="headerlink" title="代码管理与开发"></a>代码管理与开发</h1><p><del>源代码和资源文件都是放在<code>src</code>文件夹里的，有时要在多个不同的Mod间切换开发，我目前的解决方法是将代码统一放在别处，将src文件夹做软链接进来。同时我也非常推荐也用这种方法处理<code>build.gradle</code>文件。将代码放在别处还有个好处，就是可以用<code>git</code>来管理版本，而且可以用分支方便地管理对不同Minecraft版本做的修改。不管什么方式，自己习惯就好。</del></p><p>用了<code>gradle ideaModule</code>后，代码本身就分开放置了，不再需要这种方法了。</p><p>对于开发这一部分，自己深感无力(其实就是懒)，请参阅szszss的系列教程。<br>另外，现在已经没有Coremod文件夹了，所以所有Mod都放在Mods文件夹下，不同之处只在于<code>MANIFEST.MF</code>文件。</p><h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><p>感谢ForgeGradle，打包发布不再需要手动拷贝压缩一大堆文件了。首先，你需要修改下<code>build.gradle</code>文件，这也是我为什么推荐用软链接来管理它的原因。<br>以原始的文件为例：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version = <span class="string">"1.0"</span></span><br><span class="line">group= <span class="string">"com.yourname.modid"</span> <span class="comment">// http://maven.apache.org/guides/mini/guide-naming-conventions.html</span></span><br><span class="line">archivesBaseName = <span class="string">"modid"</span></span><br><span class="line"></span><br><span class="line">minecraft &#123;</span><br><span class="line">    version = <span class="string">"1.7.10-10.13.2.1230"</span></span><br><span class="line">    runDir = <span class="string">"eclipse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>archivesBaseName</code>和第一行<code>version</code>都可以自由修改，只会影响输出的jar文件的名字，关于<code>group</code>用途不明，有了解的求留言告知。<br>如果你打算把Mod升级到一个新的Forge版本，请务必修改<code>minecraft.version</code>和你的开发环境一致，否则会出现奇奇怪怪的问题。<br>修改好后，就可以用<code>gradle build</code>来编译了，同样建议开代理。编译好的jar在<code>build/libs</code>下。</p><p>如果是需要对MANIFEST进行修改的，比如Coremod，需要在<code>build.gradle</code>中minecraft块之后添加jar块:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jar &#123;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes <span class="string">'FMLCorePlugin'</span>: <span class="string">'org.devinprogress.uniskinmod.SkinCore'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你的一个jar包里既有普通Mod（以<code>@Mod</code>作Annotation的）又有Coremod，你还需要</p><pre><code>attributes &apos;FMLCorePluginContainsFMLMod&apos;: true</code></pre><p>否则普通Mod不会被载入。</p><h1 id="ASMTransformer"><a href="#ASMTransformer" class="headerlink" title="ASMTransformer"></a>ASMTransformer</h1><p>因为MCP坑爹的反混淆机制，开发者在处理Method或Field时需要对付三种不同的名字：</p><ol><li>形似<code>a</code>这样的混淆名，<code>obfName</code></li><li>形似<code>func_xxxx_a</code>这样的半混淆名，有时也称作<code>srgName</code></li><li>形似<code>doTick</code>这样的反混淆名，或称<code>mcpName</code></li></ol><p>关于为什么要有srgName，MCP是这么解释的：因为mcpName是任何人都可以贡献的（这是真的），所以会出现这么一种情况，有时为了更好地描述某个函数的功能，在次要版本升级时（比如1.7.1升级1.7.2），mcpName会发生变化，如果直接以mcpName进行编译，那么为1.7.1编译的Mod就无法在1.7.2上使用，即使其他方面都没有问题。于是为了解决这个问题，引入了相对固定的srgName。FML是这么处理名称的，在<code>gradle build</code>时，代码中所有的mcpName均会被混淆成srgName。然后在玩家运行游戏时，所有的obfName均被反混淆成srgName，即<code>RuntimeDeobfuscation</code>，运行时反混淆。</p><p>在你修改某个方法之前，首先必须定位它（废话）。定位一个方法需要四个信息：</p><ul><li>方法所在的类的完全限定名（这里这里指的是反混淆了的类名）</li><li>方法的srgName</li><li>方法的mcpName(用于在开发时确定方法，有时和srgName相同)</li><li>方法的Description，或者说，参数列表。</li></ul><p>类很好确定，每当一个新的类被加载时，都会调用<code>IClassTransformer</code>接口的<code>transform</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IClassTransformer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] transform(String obfuscatedClassName, String transformedClassName, <span class="keyword">byte</span>[] bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个参数就是反混淆了的类名，并且是点分割，大小写正确的，可以直接用<code>equals()</code>来判断。<br>但是方法名的判断就比较复杂，因为在ASM转换时，运行时反混淆还没有被执行，所以方法名全部都是obfName。更要命的是，如果方法的参数里有Minecraft的类，那么这个类名也是被混淆了的类名。</p><p>不过谢天谢地，我们有<code>FMLDeobfuscatingRemapper</code>，你可以用<code>FMLDeobfuscatingRemapper.INSTANCE</code>来取得实例。这个类提供了几个重要的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">mapMethodName</span><span class="params">(String obfedClassName, String obfedMethodName, String obfedMethodDescription)</span></span></span><br><span class="line"><span class="function">String <span class="title">mapFieldName</span><span class="params">(String obfedClassName, String obfedFieldName, String obfedFieldDescription)</span></span></span><br><span class="line"><span class="function">String <span class="title">mapMethodDesc</span><span class="params">(String obfedMethodDescription)</span></span></span><br></pre></td></tr></table></figure><p>其中<code>mapMethodName</code>和<code>mapFieldName</code>返回对应方法和字段的srgName，<code>mapMethodDesc</code>返回反混淆了的Description，也就是将<code>(Lbee;F)V</code>这种变为<code>(Lnet/minecraft/client/gui/GuiMainMenu;F)V</code>。</p><p>如果你需要在某个方法中添加大段的代码，我极度不推荐写长长的代码将所有这些操作码全部加到目标方法里去，这种方法枯燥至极，又不直观，还难于调试。我一般的方法是，使用<code>INVOKESTATIC</code>调用自己写好的函数，并将需要修改的变量作为参数传递，这样需要的代码不多，也易于调试和维护。</p><p>在向代码中添加操作，尤其是费时的操作时（比如网络IO）请务必谨慎选择插入的位置。因为大部分代码会在主线程中执行，一旦卡住轻则界面冻结，重则直接被服务器超时踢出。</p><p>我不是非常推荐让ASM自动计算栈大小和本地变量区大小，因为碰到一些比较复杂的类时会悲剧，比如<code>AbstractClientPlayer</code></p><p>如果你想清空一个方法让它什么都不做，请还是不要忘记加上RETURN</p><p>有时，开发环境下编译出的class和原始的class会有区别，所以还是建议用javap之类的工具看一下原始的字节码。</p><h1 id="AccessTransformer"><a href="#AccessTransformer" class="headerlink" title="AccessTransformer"></a>AccessTransformer</h1><p>有时，我们需要频繁调用某个private的Method或是Field，使用反射会有性能损失，而ASMTransformer也无效(因为无法通过编译)，这就到了AccessTransformer大显身手的时候了。<br>AccessTransformer用于将private或是protected的Method和Field变为public，这样在代码中就可以直接使用了。<br>你需要首先创建一个<code>*_at.cfg</code>的配置文件放在resources目录（就是放<code>mcmod.info</code>的目录）下，然后将其软链接到根目录下（和<code>build.gradle</code>同目录）。<br>配置文件的语法类似这样（这是<code>fml_at.cfg</code>的一部分）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> net.minecraft.entity.<span class="function">EntityList <span class="title">func_75618_a</span><span class="params">(Ljava/lang/Class;Ljava/lang/String;I)</span>V</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> net.minecraft.entity.EntityList field_75625_b #nameToClassMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> net.minecraft.item.crafting.CraftingManager <span class="title">func_92103_a</span><span class="params">(Lnet.minecraft.item.ItemStack;[Ljava/lang/Object;)</span>Lnet.minecraft.item.crafting.ShapedRecipes</span>;</span><br></pre></td></tr></table></figure><p>接着重建工作区：</p><pre><code>gradle clean setupDecompWorkspace idea --refresh-dependencies</code></pre><p>同样建议挂代理，用eclipse的同学把<code>idea</code>换成<code>eclipse</code>，有强迫症的同学可以加上<code>-i</code>选项。这样，开发环境下代码的改动就完成了。我在挂着代理的情况下大约需要8分钟。</p><p>为了让其在混淆环境下也能正常工作，你需要创建一个新的类，继承<code>AccessTransformer</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyATransformer</span> <span class="keyword">extends</span> <span class="title">AccessTransformer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyATransformer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"mymod_at.cfg"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的字符串就是配置文件名，然后在实现了<code>IFMLLoadingPlugin</code>的类里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAccessTransformerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MyATransformer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外需要注意的是，AccessTransformer不会自动转换衍生类，所以在转换基类时请务必当心，否则会编译不通过。</p><p>在1.7.10及以上的版本中，可以在build.gradle文件的中加入以下内容，这样就不必再写IFMLLoadingPlugin了。其中的<code>mymod_at.cfg</code>文件要放在META-INF文件夹下。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jar &#123;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes <span class="string">'FMLAT'</span>: <span class="string">'mymod_at.cfg'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他杂七杂八的东西"><a href="#其他杂七杂八的东西" class="headerlink" title="其他杂七杂八的东西"></a>其他杂七杂八的东西</h1><ul><li>如果你想给MCP贡献mcpName，可以去IRC esper#mcp 找 MCPBot_Reborn</li><li>最新的反混淆名对应表可以在<a href="http://export.mcpbot.bspk.rs/" target="_blank" rel="noopener">MCPBot Export</a>找到</li><li>如果你厌倦了用文本编辑器搜索字符串来找srgName的话，可以试试<a href="https://github.com/bspkrs/MCPMappingViewer/" target="_blank" rel="noopener">MCPMappingViewer</a></li><li><a href="https://bitbucket.org/mstrobel/procyon" target="_blank" rel="noopener">Procyon</a>是个极好的Java反编译器</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;表示最近时间荒废得厉害，主要都是耗在了&lt;a href=&quot;http://www.minecraft.net&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Minecraft&lt;/a&gt;这款游戏上。&lt;br&gt;Minecraft的一大魅力在于其几乎无穷的MODs，于是我也小试了一下Mod开发，顺便学习一下Java。&lt;del&gt;于是掉入了万劫不复的深坑&lt;/del&gt;&lt;br&gt;当然，我要做点和加个方块、改个合成表之类的不一样的事。&lt;br&gt;（教程中不少内容都参考了szszss的&lt;a href=&quot;http://www.hakugyokurou.net/wordpress/?page_id=126&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;博客&lt;/a&gt;，在此表示深深的感谢）&lt;/p&gt;
&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h1&gt;&lt;p&gt;关于这篇文章，不适合特别特别新的新人，我假设各位读者都有一些基础的编程经验。如果你是入门级别的，在MCBBS论坛的&lt;a href=&quot;http://www.mcbbs.net/thread-54579-1-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;编程开发板块&lt;/a&gt;有不少不错的入门教程。&lt;br&gt;我假设各位读者都具备以下能力:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会安装软件&lt;/li&gt;
&lt;li&gt;了解基本的程序流程控制，比如判断、循环等&lt;/li&gt;
&lt;li&gt;了解基本的OOP概念，比如类，继承等 （其实这条不是那么重要，Java看多了就自然会了 &lt;del&gt;一个原C程序员如是说&lt;/del&gt;）&lt;/li&gt;
&lt;li&gt;了解命令行、终端的基本使用方法&lt;/li&gt;
&lt;li&gt;有方法正常访问国际互联网，如Facebook等&lt;/li&gt;
&lt;li&gt;了解基本英语单词（这条似乎也不是那么重要，主要是希望大家能够在遇到问题时不要怕阅读英文资料）&lt;/li&gt;
&lt;li&gt;（本教程面向Linux用户，Mac用户大同小异，Windows用户自己看着办）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Minecraft" scheme="https://recursiveg.me/tags/Minecraft/"/>
    
      <category term="Java" scheme="https://recursiveg.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>域名注册商更换</title>
    <link href="https://recursiveg.me/2014/07/domain-name-registrar-switched/"/>
    <id>https://recursiveg.me/2014/07/domain-name-registrar-switched/</id>
    <published>2014-07-16T05:43:25.000Z</published>
    <updated>2020-01-12T19:20:08.510Z</updated>
    
    <content type="html"><![CDATA[<p>昨天折腾了一天，把域名从Godaddy转移到了Name.com<br>表示基本没遇到什么麻烦，信用卡借用了家长的，付款也很方便。<br>关键是便宜啊。转入9美刀，续期11美刀,比Godaddy坑爹的18刀便宜太多了啊<del>~<br>而且还有免费的WHOIS保护啊</del>优惠码<code>PRIVACYPLEASE</code>超好记有木有！<br>虽然不是最便宜的但是Name.com的控制台相当美观呐~<br>结尾吐槽一句：在万网注册的都是真的勇士。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天折腾了一天，把域名从Godaddy转移到了Name.com&lt;br&gt;表示基本没遇到什么麻烦，信用卡借用了家长的，付款也很方便。&lt;br&gt;关键是便宜啊。转入9美刀，续期11美刀,比Godaddy坑爹的18刀便宜太多了啊&lt;del&gt;~&lt;br&gt;而且还有免费的WHOIS保护啊&lt;/de
      
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Site Management" scheme="https://recursiveg.me/tags/Site-Management/"/>
    
  </entry>
  
  <entry>
    <title>Programming with PTRACE, Part6 - 时间控制</title>
    <link href="https://recursiveg.me/2014/07/programming-with-ptrace-part6/"/>
    <id>https://recursiveg.me/2014/07/programming-with-ptrace-part6/</id>
    <published>2014-07-07T08:51:03.000Z</published>
    <updated>2020-01-12T19:04:30.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="不同的时间计算方法"><a href="#不同的时间计算方法" class="headerlink" title="不同的时间计算方法"></a>不同的时间计算方法</h1><p>程序运行会占用一小段时间（废话），事实上，我们有不止一种方法来表示一个程序运行了多长时间。最直观的应该是“墙上时间”，也就是说，你掐个秒表，看看程序从开始到结束用了多长时间。除此之外，还有“用户态时间”和“内核态时间”，这两个时间都是以CPU实际运算的时间，也就是CPU周期，来计数的。“用户态时间”就是程序在用户态执行的时间，包括程序所引用的库中的代码（比如STL），“内核态时间”就是指程序在内核态执行的时间，一般是各种系统调用（比如各种IO操作）。这两种时间和墙上时间的区别在于，因为CPU其实是在多个程序中快速切换的，所以在运行某个程序的时间里，CPU也处理了属于其他进程的任务，而且CPU切换任务也需要一定的时间（真的很短）。如果处于被调试状态，tracer的运行时间也会被计算在内，这些不属于这个进程的时间片也会被计算在这个进程的“墙上时间”里。所以一般以用户态时间和内核态时间的总和作为进程的运行时间。</p><p>在Linux系统里有一个叫<code>time</code>的命令可以查看一个命令执行了多长时间。这个命令有两个版本，一个是shell内置的，另一个是独立的可执行文件，可以用<code>type time</code>命令查看。虽然可执行版本功能更强一点，但内置的功能足够，这一点区别可以不管。用法是： <code>time [命令] &lt;参数&gt;</code>。给个例子：</p><pre><code>time ffmpeg -i sample.mp4 target.mp3...5.42s user0.10s system100% cpu5.520 total</code></pre><a id="more"></a><h1 id="动手写个带时限的time"><a href="#动手写个带时限的time" class="headerlink" title="动手写个带时限的time"></a>动手写个带时限的time</h1><p>还在对上个PART的<code>setrlimit</code>耿耿于怀么？我们现在就来用它！相关的定义位于<code>sys/resource.h</code>头文件里。我们这次要用到<code>RLIMIT_CPU</code>,这个选项限制进程所能占用的CPU时间，以秒为单位，可以把它理解为用户态时间和内核态时间的和。我们首先要使用<code>getrlimit</code>获得当前的限制：</p><pre><code>struct rlimit TimeL;getrlimit(RLIMIT_CPU,&amp;TimeL);</code></pre><p><code>rlimit</code>结构有两个成员:</p><ul><li><code>rlim_cur</code> 软限制</li><li><code>rlim_max</code> 硬限制</li></ul><p>系统一般会用比较平和的方式对待那些达到软限制的进程，比如发个SIGSEGV什么的。而那些达到硬限制的进程会被直接SIGKILL。我们接下来要修改软限制，注意单位是秒。</p><pre><code>TimeL.rlim_cur=Timeout;</code></pre><p>以上工作都要在<code>fork()</code>之前完成，之后要在<em>子进程</em>里应用这个限制（没错就是exec那里）</p><pre><code>setrlimit(RLIMIT_CPU,&amp;TimeL);</code></pre><p>这样，如果子进程超过软限制，系统就会发送<code>SIGXCPU</code>信号给子进程。当然，因为ptrace的原因，信号会被先发送给父进程，这样就可以用part3里介绍的方法进行处理。这样子进程是要清蒸还是油炸就都由父进程决定了。<br>当然，我们还有别的方法获取时间信息。一是用<code>gettimeofday()</code>函数配合<code>timeval</code>结构，可以获得当前时间，精确到微秒（百万分之一秒）。在程序开始时调用下，结束时调用下，相减即可得到墙上时间。另一种方法是利用<code>wait4</code>里的<code>ru</code>参数，它其实是个<code>rusage</code>结构,成员<a href="http://man7.org/linux/man-pages/man2/getrusage.2.html" target="_blank" rel="noopener">见此</a>。其中的<code>ru_utime</code>和<code>ru_stime</code>成员是<code>timeval</code>结构，分别记录了用户态时间和内核态时间，同样精确到微秒。</p><h1 id="程序睡着了"><a href="#程序睡着了" class="headerlink" title="程序睡着了"></a>程序睡着了</h1><p><code>RLIMIT_CPU</code>大多数情况下都能正常工作，配合<code>timeval</code>结构甚至能进一步提高精度。但是有两个例外（如果有更多请务必告诉我）：</p><ol><li>程序主动调用<code>sleep()</code></li><li>交互状态下<code>scanf()</code>一类的函数等待键盘输入</li></ol><p>在这两种情况下：进程不占用CPU时间，<code>RLIMIT_CPU</code>管不着；没有系统调用，<code>wait4()</code>不返回。为了能够在这种情况下依然能够限制时间，我想出了两种方法。一是限制和<code>sleep()</code>相关的系统调用，二是父进程设置ALARM。我在这里讲一下第二种方法。<br>Linux提供了一个<code>alarm()</code>函数，可以在指定的秒数<strong>(墙上时间)</strong>后给这个进程本身发送<code>SIGALRM</code>信号。而且，我们可以给信号绑定一个处理函数（就是当信号到达时调用的函数），在这个处理函数里，可以用<code>kill</code>命令给子进程发送信号（比如<code>SIGUSR1</code>），这样就能使父进程里的<code>wait4()</code>返回，就可以控制子进程了。以下是一个简要指导：<br>首先我们需要一个信号处理函数,记得把pid改成全局变量：</p><pre><code>void AlarmIn(int sig){    if(sig==SIGALRM)    kill(pid,SIGUSR1);}</code></pre><p>然后在子程序开始执行的时候绑定信号并设置Alarm，我在这设置超时一秒:</p><pre><code>signal(SIGALRM,AlarmIn);alarm(1);</code></pre><p>然后请根据part3所讲的内容在while循环里正确处理<code>SIGUSR1</code>。最后记得取消Alarm，如果没超时的话：</p><pre><code>alarm(0);</code></pre><h1 id="完整代码？"><a href="#完整代码？" class="headerlink" title="完整代码？"></a>完整代码？</h1><p>表示完整代码太长了，放这儿太不美观，<del>我会稍后贴到gist上去。</del>代码被幽幽子吃掉了大家自己写把。</p><h1 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h1><ul><li><a href="http://zh.wikipedia.org/wiki/%E6%95%B0%E9%87%8F%E7%BA%A7_%28%E6%97%B6%E9%97%B4%29" target="_blank" rel="noopener">Wikipedia - 数量级 (时间)</a> 我把这个链接放这儿是因为老有人把微秒缩写成<code>ms</code>然后和毫秒搞混</li><li><a href="http://blog.csdn.net/xwdok/article/details/542109" target="_blank" rel="noopener">协同式多任务与抢占式多任务</a></li><li><a href="http://www.cnblogs.com/iceocean/articles/1650929.html" target="_blank" rel="noopener">Linux时间管理</a></li><li><a href="http://russelltao.iteye.com/blog/1405353" target="_blank" rel="noopener">浅谈时间函数gettimeofday的成本</a></li></ul>]]></content>
    
    <summary type="html">
    
      Sixth part of serial of tutorial: Programming with PTRACE
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="PTRACE" scheme="https://recursiveg.me/tags/PTRACE/"/>
    
  </entry>
  
  <entry>
    <title>Programming with PTRACE, Part5 - 内存管理</title>
    <link href="https://recursiveg.me/2014/05/programming-with-ptrace-part5/"/>
    <id>https://recursiveg.me/2014/05/programming-with-ptrace-part5/</id>
    <published>2014-05-26T02:00:32.000Z</published>
    <updated>2020-01-12T19:04:29.750Z</updated>
    
    <content type="html"><![CDATA[<p>这个part主要讲解Linux的内存管理机制，以及如何查看并限制子进程的内存使用。</p><h1 id="内存的划分"><a href="#内存的划分" class="headerlink" title="内存的划分"></a>内存的划分</h1><p>（嘛。。。这一部分也算是现学现卖的，如果大家觉得有什么讲的不到位的请翻下方的拓展阅读部分）<br>大家都知道，32位系统最大可以寻址4GB的地址空间（不考虑<a href="http://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E6%89%A9%E5%B1%95" target="_blank" rel="noopener">物理地址扩展</a>），那么这个“地址”究竟指的是哪儿的地址呢？你可以写一个小程序，malloc一点内存，然后把地址打印出来，重复几次，你会发现，分配的内存几乎都在同一个位置。这是因为，对于程序来说，这些地址都是虚拟地址，虚拟地址空间对于每个进程都是独立的，也就是说，对于不同的进程，同样虚拟地址上的数据是不同的。<br>当然，数据肯定是存放在内存条上的，我们把可以直接读写内存条的地址叫做物理地址。物理地址以一定的方式映射到虚拟地址上，所以当程序试图访问虚拟地址时，系统要以一定方式把虚拟地址变成物理地址，这项工作通常是由<a href="http://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83" target="_blank" rel="noopener">MMU(内存管理单元)</a>来完成的。内存的映射不是大块大块的，而是一小片一小片分别映射的，所以在虚拟地址上连续的地址可能在物理地址上相差十万八千里，这些一小片一小片的内存被称为“页”。<br>页的存在给内存分配带来了极大的灵活性，页可以存储在内存里，也可以存储在交换分区里，可以将同一块物理内存映射到不同进程的虚拟空间里（动态库经常这么干），甚至可以映射到磁盘上的某个文件。光说可能有点抽象，于是给幅图(来自Wikipedia)<br><img src="http://upload.wikimedia.org/wikipedia/commons/3/32/Virtual_address_space_and_physical_address_space_relationship.svg" alt="内存页映射是不连续的"><br>虚拟地址被分成多个段，数据有序存放于其中。这是32位Linux的新内存布局(Linux 2.6.7之后):<br><img src="http://static.duartes.org/img/blogPosts/linuxFlexibleAddressSpaceLayout.png" alt="Linux新内存布局"><br>如果你研究过可执行文件的结构，你就会发现，虚拟地址的段就是按可执行文件的段来填充的。另外，由于代码段的起点地址是固定的(0x08048000)，所以编译器就可以预先算出函数的地址了。顺带一提，因为动态库加载时的虚拟地址是不固定的，不能预先计算出函数地址，所以要在编译时使用<code>-fPIC</code>选项生成位置无关代码，否则每次被一个新进程使用时都要进行重定位(可以理解为重新计算函数地址)，并生成该动态库的一个副本，这样压根没有起到节约内存的作用。<br>扯远了，回来。尽管每个进程的虚拟地址空间时互相独立的，但并不意味着进程想访问哪儿就能访问的，比如3GB以上的区域，那儿是内核的领地。即使是堆段，也只能访问已申请的内存部分，非法的内存访问将会引发段错误(Segmentation Fault)。回到<code>malloc()</code>函数上，malloc最终会调用<code>brk</code>或<code>mmap</code>系统调用，brk用于在堆中分配小块内存，mmap则用于在Memory Mapping Segment中分配大块内存。但是并不是每次malloc都会调用brk，这是因为分配的内存实在是太小了，而brk只能分配大一点的内存，所以C运行库(比如glibc)在收到一个malloc时会先用brk向系统“批发”一块大一点的内存，而收到后续分配请求时则把这块大内存“零售”给程序，直到售完再次brk。<br>如果有一个程序死循环单纯malloc内存，内存会不会被吃光呢？答案是不会(我不清楚是不是真的有如此单纯的系统真的会挂掉)，因为系统发现，你只是分配了内存，却没有使用，于是它很机智地将那片内存设置为“可访问”，却没有把它映射到任何一个实际的内存页上！</p><a id="more"></a><h1 id="你用了多少内存？"><a href="#你用了多少内存？" class="headerlink" title="你用了多少内存？"></a>你用了多少内存？</h1><p>还记得之前的<code>rusage</code>结构么？其成员可在<a href="http://man7.org/linux/man-pages/man2/getrusage.2.html" target="_blank" rel="noopener">这里</a>找到。事实上，这是一种非常简陋的内存使用信息获取方式，我们只关心其中的<code>ru_maxrss</code>一项，RSS即&quot;Resident Set Size&quot;，表示该进程在物理内存中的占用大小，不包括交换分区中的内存大小，也不包含分配了却未使用而没有物理内存页的内存。为了获得更详细的内存信息，我们需要访问<code>/proc</code>目录。该目录下各文件的用途在<code>man 5 proc</code>里描述得很清楚，<a href="http://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="noopener">这里</a>是网页版本。关于这个目录的作用，我就偷懒，将man手册中的描述翻译如下：</p><blockquote><p><code>proc</code>文件系统是一个伪文件系统，提供了访问内核数据结构的接口。它通常被挂载在<code>/proc</code>上并且大部分是只读的，除了少数文件被允许用来改变内核参数。</p></blockquote><p><code>/proc</code>下有N多文件夹，大部分是按进程的pid来命名的，我们关心的是这些文件夹中的<code>status</code>文件。来看一个例子：<code>cat /proc/1/status|grep Vm</code></p><pre><code>VmPeak:      173616 kBVmSize:      107968 kBVmLck:           0 kBVmPin:           0 kBVmHWM:        3816 kBVmRSS:        3744 kBVmData:       83744 kBVmStk:         136 kBVmExe:        1140 kBVmLib:        2268 kBVmPTE:          72 kBVmSwap:           0 kB</code></pre><p>我们看到了两个令人感兴趣的东西：<code>VmData</code>和<code>VmStk</code>。分别代表了数据区和栈的大小，而且这两个数据是真正的可访问的虚拟内存大小，即不会像RSS那样，漏掉那些分配了而未访问的内存。当然，其他数据也都是很有趣的，有兴趣的人可以自己去翻man手册。这段代码计算给定进程的数据段和堆栈段内存使用总和。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getMemory</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pid_t</span> pid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> stat_loc[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">long</span> VmData,VmStk;</span><br><span class="line">    <span class="built_in">sprintf</span>(stat_loc,<span class="string">"/proc/%d/status"</span>,pid);</span><br><span class="line">    FILE *stat=fopen(stat_loc,<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">line</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">while</span>(EOF!=<span class="built_in">fscanf</span>(stat,<span class="string">"%[^\n]"</span>,<span class="built_in">line</span>))&#123;</span><br><span class="line">        <span class="built_in">sscanf</span>(<span class="built_in">line</span>,<span class="string">"VmData: %ld"</span>,&amp;VmData);</span><br><span class="line">        <span class="built_in">sscanf</span>(<span class="built_in">line</span>,<span class="string">"VmStk: %ld"</span>,&amp;VmStk);</span><br><span class="line">        fgetc(stat);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> VmData+VmStk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="限制内存"><a href="#限制内存" class="headerlink" title="限制内存"></a>限制内存</h1><p>也许你们已经知道，有一个叫做<code>setrlimit</code>的函数可以用来限制资源使用，你们也许已经翻过了它的man手册，看到了<code>RLIMIT_AS</code> <code>RLIMIT_DATA</code> <code>RLIMIT_RSS</code>等一票似乎很有用的参数。现在，请你立刻忘掉他们！既然我们之前讲了<code>/proc</code>当然要用起来啦。我们不用<code>setrlimit</code>是因为，这种限制策略会导致malloc失败（确切的讲是brk和mmap失败），而大部分OIer都没有检查malloc返回值的的习惯，最终导致本应是MLE(Memory Limit Exceeded)的情况变成了由访问无效内存导致的RE(Runtime Error)。更糟糕的是，如果是系统栈增长被限制了，进程会被直接<code>SIGSEGV</code>，连errno都没有，这种情况下就更难分辨了。那么，有什么好的方法来限制内存呢？答案就是在每次分配内存的系统调用（不限于brk和mmap）时通过proc来检查内存使用，注意要在返回时检查哦。一旦超过，就由父进程直接杀死子进程，方法多种多样，你可以使用<code>ptrace(PTRACE_KILL,pid,0,0)</code>，或是用Part3所讲的方法发送信号，或是直接用<a href="http://man7.org/linux/man-pages/man2/kill.2.html" target="_blank" rel="noopener">kill函数</a>。这种方法看上去很不优雅，但确实很有效。至于那些对<code>setrlimit</code>耿耿于怀的同学，不要担心，下个part时间限制，将会大量用到。</p><h1 id="拓展阅读-amp-参考资料"><a href="#拓展阅读-amp-参考资料" class="headerlink" title="拓展阅读&amp;参考资料"></a>拓展阅读&amp;参考资料</h1><ul><li><a href="http://xixinfei.iteye.com/blog/1949123" target="_blank" rel="noopener">Linux内存管理详解</a></li><li><a href="http://www.itvane.net/?p=1240" target="_blank" rel="noopener">Linux进程地址空间详解</a></li><li><a href="http://www.cnblogs.com/clover-toeic/p/3754433.html" target="_blank" rel="noopener">Linux虚拟地址空间布局</a></li><li><a href="http://acm.tongji.edu.cn/cnfaqs" target="_blank" rel="noopener">OJ系统各状态含义</a>(见Question #6；应该还有一个RF:Restricted Function)</li><li><a href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/" target="_blank" rel="noopener">Anatomy of a Program in Memory</a></li><li>man手册</li></ul>]]></content>
    
    <summary type="html">
    
      Fifth part of serial of tutorial: Programming with PTRACE
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="PTRACE" scheme="https://recursiveg.me/tags/PTRACE/"/>
    
  </entry>
  
  <entry>
    <title>Programming with PTRACE, Part4 - 系统调用进阶</title>
    <link href="https://recursiveg.me/2014/05/programming-with-ptrace-part4/"/>
    <id>https://recursiveg.me/2014/05/programming-with-ptrace-part4/</id>
    <published>2014-05-26T02:00:31.000Z</published>
    <updated>2020-01-12T19:04:29.316Z</updated>
    
    <content type="html"><![CDATA[<p>这个part是<a href="/2014/04/programming-with-ptrace-part2/">Part2</a>的延续，所以我强烈建议你弄明白Part2中的内容后再来看本part。那么进入正题，我将在这个部分讲解系统调用的参数传递顺序以及如何利用ptrace系统调用获得用户空间的数据。</p><h2 id="参数与寄存器"><a href="#参数与寄存器" class="headerlink" title="参数与寄存器"></a>参数与寄存器</h2><p>我在Part2中提到过，系统调用的参数是以一定顺序保存在寄存器里的，那么这个顺序是什么呢？在<code>man 2 syscall</code>中有两张表格解释了这个问题，你也可以在<a href="http://man7.org/linux/man-pages/man2/syscall.2.html" target="_blank" rel="noopener">这里</a>看到，就在&quot;Architecture calling conventions&quot;下面。我知道很多人很懒，所以我就把这两张表格复制过来了。</p><center><table><thead><tr><th align="left">arch/ABI</th><th align="left">instruction</th><th align="left">syscall #</th><th align="left">retval</th><th align="left">Notes</th></tr></thead><tbody><tr><td align="left">arm/OABI</td><td align="left">swi NR</td><td align="left">-</td><td align="left">a1</td><td align="left">NR is syscall #</td></tr><tr><td align="left">arm/EABI</td><td align="left">swi 0x0</td><td align="left">r7</td><td align="left">r0</td><td align="left"></td></tr><tr><td align="left">blackfin</td><td align="left">excpt 0x0</td><td align="left">P0</td><td align="left">R0</td><td align="left"></td></tr><tr><td align="left">i386</td><td align="left">int $0x80</td><td align="left">eax</td><td align="left">eax</td><td align="left"></td></tr><tr><td align="left">ia64</td><td align="left">break 0x100000</td><td align="left">r15</td><td align="left">r10/r8</td><td align="left">bool error/errno value</td></tr><tr><td align="left">parisc</td><td align="left">ble 0x100(%sr2, %r0)</td><td align="left">r20</td><td align="left">r28</td><td align="left"></td></tr><tr><td align="left">s390</td><td align="left">svc 0</td><td align="left">r1</td><td align="left">r2</td><td align="left">See below</td></tr><tr><td align="left">s390x</td><td align="left">svc 0</td><td align="left">r1</td><td align="left">r2</td><td align="left">See below</td></tr><tr><td align="left">sparc/32</td><td align="left">t 0x10</td><td align="left">g1</td><td align="left">o0</td><td align="left"></td></tr><tr><td align="left">sparc/64</td><td align="left">t 0x6d</td><td align="left">g1</td><td align="left">o0</td><td align="left"></td></tr><tr><td align="left">x86_64</td><td align="left">syscall</td><td align="left">rax</td><td align="left">rax</td><td align="left"></td></tr></tbody></table><table><thead><tr><th align="left">arch/ABI</th><th align="left">arg1</th><th align="left">arg2</th><th align="left">arg3</th><th align="left">arg4</th><th align="left">arg5</th><th align="left">arg6</th><th align="left">arg7</th></tr></thead><tbody><tr><td align="left">arm/OABI</td><td align="left">a1</td><td align="left">a2</td><td align="left">a3</td><td align="left">a4</td><td align="left">v1</td><td align="left">v2</td><td align="left">v3</td></tr><tr><td align="left">arm/EABI</td><td align="left">r0</td><td align="left">r1</td><td align="left">r2</td><td align="left">r3</td><td align="left">r4</td><td align="left">r5</td><td align="left">r6</td></tr><tr><td align="left">blackfin</td><td align="left">R0</td><td align="left">R1</td><td align="left">R2</td><td align="left">R3</td><td align="left">R4</td><td align="left">R5</td><td align="left">-</td></tr><tr><td align="left">i386</td><td align="left">ebx</td><td align="left">ecx</td><td align="left">edx</td><td align="left">esi</td><td align="left">edi</td><td align="left">ebp</td><td align="left">-</td></tr><tr><td align="left">ia64</td><td align="left">out0</td><td align="left">out1</td><td align="left">out2</td><td align="left">out3</td><td align="left">out4</td><td align="left">out5</td><td align="left">-</td></tr><tr><td align="left">parisc</td><td align="left">r26</td><td align="left">r25</td><td align="left">r24</td><td align="left">r23</td><td align="left">r22</td><td align="left">r21</td><td align="left">-</td></tr><tr><td align="left">s390</td><td align="left">r2</td><td align="left">r3</td><td align="left">r4</td><td align="left">r5</td><td align="left">r6</td><td align="left">r7</td><td align="left">-</td></tr><tr><td align="left">s390x</td><td align="left">r2</td><td align="left">r3</td><td align="left">r4</td><td align="left">r5</td><td align="left">r6</td><td align="left">r7</td><td align="left">-</td></tr><tr><td align="left">sparc/32</td><td align="left">o0</td><td align="left">o1</td><td align="left">o2</td><td align="left">o3</td><td align="left">o4</td><td align="left">o5</td><td align="left">-</td></tr><tr><td align="left">sparc/64</td><td align="left">o0</td><td align="left">o1</td><td align="left">o2</td><td align="left">o3</td><td align="left">o4</td><td align="left">o5</td><td align="left">-</td></tr><tr><td align="left">x86_64</td><td align="left">rdi</td><td align="left">rsi</td><td align="left">rdx</td><td align="left">r10</td><td align="left">r8</td><td align="left">r9</td><td align="left">-</td></tr></tbody></table></center><a id="more"></a>表格内容虽多，但其实我们关心的只有i386和x86_64（32位和64位）一共4行（因为有两张表格嘛）。精简提炼下，一共就两句话<blockquote><p>对于32位系统，系统调用号存放在EAX寄存器，参数依次放入EBX、ECX、EDX、ESI ... 返回值位于EAX寄存器<br>  对于64位系统，系统调用号存放在RAX寄存器，参数依次放入RDI、RSI、RDX、R10 ... 返回值位于RAX寄存器</p></blockquote><p>以64位系统下的<code>write()</code>调用为例:</p><pre><code>ssize_t write(int fd, const void *buf, size_t count);</code></pre><p>那么RAX是1(write的调用号)，RDI一般为1(stdout),RSI存储着指向用户空间中将要被输出的字符串的地址，RDX自然就是字符串长度啦。</p><h2 id="获取那个字符串"><a href="#获取那个字符串" class="headerlink" title="获取那个字符串"></a>获取那个字符串</h2><p>理论讲完了，进入实战。这次我们拿<code>open()</code>系统调用开刀，一是因为监视程序打开了什么文件比得知输出了什么更常用，二是因为传递给<code>open()</code>的字符串没有长度信息，只能自己通过<code>\0</code>判断，更有挑战性。我们这次要使用ptrace的一个新功能<code>PTRACE_PEEKTEXT</code>,其实还有另外一个叫做<code>PTRACE_PEEKDATA</code>的，不过根据man手册的描述，这两个的功能是一样的。它的用法是这样的</p><pre><code>data = ptrace(PTRACE_PEEKTEXT,pid,addr,0);</code></pre><p>即从子进程（由pid标识）的addr内存地址处取出对应字长(64位为8字节，32位4字节)的数据，做为返回值。也就是说，读取一次能得到八个字符。现在如果我们要取得从<code>base_addr</code>地址开始的一个字符串，那么我们只要8个字节8个字节读取，直到碰到<code>\0</code>为止。把这个功能写成函数就是这样：（32位系统不要忘记改那个define）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WORD_LEN 8</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">peek_str</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">long</span> base_addr,<span class="keyword">char</span> target[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">union</span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">word</span>;</span><br><span class="line">    <span class="keyword">char</span> str[WORD_LEN];</span><br><span class="line">  &#125; data;<span class="comment">/*利用union把WORD_LEN字节的整数变为字符数组*/</span></span><br><span class="line">  <span class="keyword">long</span> offset=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> done=<span class="number">0</span>,i;</span><br><span class="line">  target[<span class="number">0</span>]=<span class="string">'\0'</span>;</span><br><span class="line">  <span class="keyword">while</span>(!done)&#123;<span class="comment">/*循环读取*/</span></span><br><span class="line">    data.<span class="keyword">word</span>=ptrace(PTRACE_PEEKTEXT,pid,base_addr+offset,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">strncat</span>(target,data.str,WORD_LEN);<span class="comment">/*追加至多WORD_LEN个字符*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;WORD_LEN;i++)<span class="comment">/*检查是否有'\0'*/</span></span><br><span class="line">      <span class="keyword">if</span>(data.str[i]==<span class="string">'\0'</span>)</span><br><span class="line">        done=<span class="number">1</span>;</span><br><span class="line">    offset+=WORD_LEN;<span class="comment">/*准备读取下一个WORD_LEN字节*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主程序的大<code>while()</code>循环里的代码是这样的（我已经设置了<code>PTRACE_O_TRACESYSGOOD</code>标记）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">wait4(pid,&amp;sta,<span class="number">0</span>,&amp;ru);</span><br><span class="line"><span class="keyword">if</span>(WIFEXITED(sta))&#123;<span class="built_in">printf</span>(<span class="string">"Exited with code %d"</span>,WEXITSTATUS(sta));<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(WIFSIGNALED(sta))&#123;<span class="built_in">printf</span>(<span class="string">"Terminated by signal: %s"</span>,strsignal(WTERMSIG(sta)));<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">int</span> sig_no;<span class="keyword">if</span>(WIFSTOPPED(sta))sig_no=WSTOPSIG(sta);<span class="keyword">else</span>&#123;<span class="built_in">puts</span>(<span class="string">"Unknown Status"</span>);<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(sig_no!=(SIGTRAP|<span class="number">0x80</span>))&#123;ptrace(PTRACE_SYSCALL,pid,<span class="number">0</span>,sig_no);<span class="keyword">continue</span>;&#125;</span><br><span class="line"><span class="keyword">if</span> (intocall)&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> <span class="title">reg</span>;</span></span><br><span class="line">  ptrace(PTRACE_GETREGS,pid,<span class="number">0</span>,&amp;reg);</span><br><span class="line">  <span class="keyword">if</span> (reg.orig_rax==SYS_open)&#123;</span><br><span class="line">    <span class="keyword">char</span> file[<span class="number">255</span>];</span><br><span class="line">    peek_str(pid,reg.rdi,file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"open() opened: %s\n"</span>,file);</span><br><span class="line">  &#125;      </span><br><span class="line">&#125;</span><br><span class="line">intocall^=<span class="number">1</span>;</span><br><span class="line">ptrace(PTRACE_SYSCALL,pid,<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在这里我使用的<code>PTRACE_GETREGS</code>和<code>user_regs_struct</code>结构来一次性获得所有寄存器的值，该结构定义于<code>sys/user.h</code>头文件中。另外，我还使用了<code>SYS_open</code>来判断系统调用号，避免了Magic Number。<code>SYS_*</code>宏定义于<code>sys/syscall.h</code>头文件中。传递RDI寄存器也很容易理解，查询<code>man 2 open</code>可知open系统调用的路径是第一个参数。现在，重新编译你的<code>target</code>，不要加<code>-static</code>,然后运行，你应该能看到类似这样的输出。</p><pre><code>Parent startedChild PiD == 4717Child exec...Child execve() returned with 0open() opened: /usr/lib/tls/x86_64/libc.so.6open() opened: /usr/lib/tls/libc.so.6open() opened: /usr/lib/x86_64/libc.so.6open() opened: /usr/lib/libc.so.6Hello World!Exited with code 0</code></pre><p>可以很明显的看到程序搜索动态链接库的过程。<br>如果你觉得这还不够过瘾，那么你可以看<a href="http://www.kgdb.info/gdb/playing_with_ptrace_part_i/" target="_blank" rel="noopener">Playing with ptrace, part1</a>,后面提供了一个配合使用<code>PTRACE_PEEKTEXT</code>和<code>PTRACE_POKETEXT</code>来将<code>write</code>输出的字符串反转的例子</p><h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><ul><li><a href="http://godorz.info/2011/02/how-debuggers-work-part-1" target="_blank" rel="noopener">调试器是怎样工作的</a></li><li><a href="http://linuxgazette.net/issue81/sandeep.html" target="_blank" rel="noopener">Process Tracing Using Ptrace</a></li></ul><h2 id="不是后记的后记"><a href="#不是后记的后记" class="headerlink" title="不是后记的后记"></a>不是后记的后记</h2><p>不知不觉已经写到Part4了，期间一边查资料一边写代码做验证一边写这篇文章，又发现了好多好多之前遗漏的信息和好文章。同时深深感觉自己真是个蒟蒻，好多东西觉得很重要，想讲却心有余而力不足，而且越来越像是在翻译man手册了……我是不是一开始就应该去翻译手册而不是写这系列文章呢？（笑）<br>下个part开始，估计就要暂时和ptrce说再见，然后和内存管理开始较劲了。</p>]]></content>
    
    <summary type="html">
    
      Fourth part of serial of tutorial: Programming with PTRACE
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="PTRACE" scheme="https://recursiveg.me/tags/PTRACE/"/>
    
  </entry>
  
  <entry>
    <title>Programming with PTRACE, Part3 - 进程的终止与信号</title>
    <link href="https://recursiveg.me/2014/05/programming-with-ptrace-part3/"/>
    <id>https://recursiveg.me/2014/05/programming-with-ptrace-part3/</id>
    <published>2014-05-25T10:26:20.000Z</published>
    <updated>2020-01-12T19:04:28.883Z</updated>
    
    <content type="html"><![CDATA[<p>在Part2中，我们粗略了解了如何使用<code>ptrace</code>获得系统调用信息，即在一个大循环里不断获取程序信息，如果程序退出则停止循环。当然，那个判断异常简陋，几乎无法处理任何特殊情况。我将在本Part中详细解说各种异常情况的处理，同时讲解各种信号相关的问题。</p><h2 id="一些重要的宏"><a href="#一些重要的宏" class="headerlink" title="一些重要的宏"></a>一些重要的宏</h2><p>在使用<code>wait4</code>后，程序的信息被存储在<code>sta</code>变量中，这些信息被存储在这个整数的不同二进制位上，这儿有一系列宏用于帮我们提取这些信息。以下信息是我对<code>man 3 wait</code>中相关部分的翻译,同时参考了<a href="http://www.manualpages.de/OpenBSD/OpenBSD-5.0/man2/WIFEXITED.2.html" target="_blank" rel="noopener">这个</a>页面</p><pre><code>WIFEXITED   如果进程正常退出，返回一个非0值(通常是进程调用了`exit()`或是`_exit()`)WIFSIGNALED 如果进程由于一个未被捕获的信号而被终止，返回一个非0值WIFSTOPPED  当进程被停止(非终止)时，返回一个非0值(通常发生在当进程处于`traced`状态时)WEXITSTATUS 当`WIFEXITED`为非0值，获得进程`main()`函数的返回值WTERMSIG    如果`WIFSIGNALED`为非0值，获得引起进程终止的信号代码WSTOPSIG    如果`WIFSTOPPED`为非0值，获得引起进程停止的信号代码</code></pre><p>除了这六个，还有<code>WIFCONTINUED</code>和<code>WCOREDUMP</code>两个宏，不过我们用不到，我也没仔细研究，就不说了。<br>当进程自行终止时，<code>WIFEXITED</code>即为<code>true</code>，配套使用<code>WEXITSTATUS</code>获得返回值，不做过多解释。当子进程进行系统调用时，<code>WIFSTOPPED</code>为<code>true</code>,同时<code>WSTOPSIG</code>等于<code>SIGTRAP</code>(信号代码为7),我们可以用这种方法区分<code>syscall-stop</code>和<code>signal-delivery-stop</code>。当有一个外部信号要发送给子进程，这个信号会先到达父进程，使<code>WIFSTOPPED</code>为<code>true</code>，同时<code>WSTOPSIG</code>等于该信号的信号代码。父进程可以选择将这个信号继续传递或是不传递，甚至传递另一个信号给子进程。一旦信号真正到达子进程，就进入子进程自己的处理流程或是系统默认动作，可能触发<code>WIFSIGNALED</code>，比如<code>SIGINT</code>。<br>在所有信号中，<code>SIGKILL</code>是一个例外，它不会经过父进程引发<code>WIFSTOPPED</code>，而是直接传递到子进程，引发<code>WIFSIGNALED</code>。</p><a id="more"></a><h2 id="信号的传递与修改"><a href="#信号的传递与修改" class="headerlink" title="信号的传递与修改"></a>信号的传递与修改</h2><p>之前提到，父进程需要将信号传递给子进程，这是由<code>ptrace(PTRACE_SYSCALL,pid,0,0)</code>的第四个参数决定的。如果为0,就不传递信号，否则传递对应代码的信号，比如<code>ptrace(PTRACE_SYSCALL,pid,0,9)</code>就将信号9(SIGKILL)传递给了子进程。<br>修改信号简直信手拈来，传一个你想要传的信号即可。</p><h2 id="strsignal-和代码"><a href="#strsignal-和代码" class="headerlink" title="strsignal()和代码"></a>strsignal()和代码</h2><p><code>strsignal()</code>接受一个整数参数，返回<code>const char*</code>，用于把信号代码变为对应的、人类可读的字符串描述，定义于<code>string.h</code>。下面给出判断程序退出的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wait4(pid,&amp;sta,<span class="number">0</span>,&amp;ru);</span><br><span class="line"><span class="keyword">if</span>(WIFEXITED(sta))&#123;<span class="built_in">printf</span>(<span class="string">"Exited with code %d"</span>,WEXITSTATUS(sta));<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(WIFSIGNALED(sta))&#123;<span class="built_in">printf</span>(<span class="string">"Terminated by signal: %s"</span>,strsignal(WTERMSIG(sta)));<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">int</span> sig_no;</span><br><span class="line"><span class="keyword">if</span>(WIFSTOPPED(sta))sig_no=WSTOPSIG(sta);</span><br><span class="line"><span class="keyword">if</span>(sig_no==SIGTRAP)sig_no=<span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line">ptrace(PTRACE_SYSCALL,pid,<span class="number">0</span>,sig_no);</span><br></pre></td></tr></table></figure><h2 id="来自ptrace的高级选项"><a href="#来自ptrace的高级选项" class="headerlink" title="来自ptrace的高级选项"></a>来自ptrace的高级选项</h2><p>你也许会纠结，如果外部传递了一个<code>SIGTRAP</code>信号，那么如何分辨呢？答案是使用<code>PTRACE_SETOPTIONS</code>设置<code>PTRACE_O_TRACESYSGOOD</code>标记，即在while之前，第一个wait之后，第一个<code>PTRACE_SYSCALL</code>之前，使用<code>ptrace(PTRACE_SETOPTIONS,pid,0,PTRACE_O_TRACESYSGOOD)</code>。这会使得<code>syscall-stop</code>导致的<code>WSTOPSIG</code>从<code>SIGTRAP</code>变为<code>SIGTRAP|0x80</code>，而普通的来自外部的<code>SIGTRAP</code>依然是<code>SIGTRAP</code>。</p>]]></content>
    
    <summary type="html">
    
      Third part of serial of tutorial: Programming with PTRACE
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="PTRACE" scheme="https://recursiveg.me/tags/PTRACE/"/>
    
  </entry>
  
  <entry>
    <title>Programming with PTRACE, Part2 - 系统调用入门</title>
    <link href="https://recursiveg.me/2014/04/programming-with-ptrace-part2/"/>
    <id>https://recursiveg.me/2014/04/programming-with-ptrace-part2/</id>
    <published>2014-04-20T12:00:19.000Z</published>
    <updated>2020-01-12T19:04:28.450Z</updated>
    
    <content type="html"><![CDATA[<p>在这部分，我会介绍如何使用ptrace监控子进程的系统调用。我先将完整代码列在开头，你现在十有八九看不懂它，但我希望你在看完这篇文章后能彻底理解这段代码。（这段代码在64位系统上有效，32位系统请参照最后<code>给32位系统的Tip</code>手动修改源代码）</p><figure class="highlight c"><figcaption><span>demo4.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/reg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Parent started"</span>);</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  pid=fork();</span><br><span class="line">  <span class="keyword">if</span> (pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"fork() failed"</span>);</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pid==<span class="number">0</span>)&#123;</span><br><span class="line">    ptrace(PTRACE_TRACEME,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Child sleeping..."</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Child exec..."</span>);</span><br><span class="line">    execlp(<span class="string">"./target"</span>,<span class="string">"target"</span>,<span class="literal">NULL</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Child PiD == %d\n"</span>,pid);</span><br><span class="line">    <span class="keyword">int</span> sta=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rusage</span> <span class="title">ru</span>;</span></span><br><span class="line">    wait4(pid,&amp;sta,<span class="number">0</span>,&amp;ru);</span><br><span class="line">    <span class="keyword">long</span> rax_rt=ptrace(PTRACE_PEEKUSER,pid,<span class="number">8</span>*RAX,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Child execve() returned with %ld\n"</span>,rax_rt);</span><br><span class="line">    ptrace(PTRACE_SYSCALL,pid,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> intocall=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      wait4(pid,&amp;sta,<span class="number">0</span>,&amp;ru);</span><br><span class="line">      <span class="keyword">if</span> (WIFEXITED(sta))&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Child Exited"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">long</span> _ORIG_RAX=ptrace(PTRACE_PEEKUSER,pid,<span class="number">8</span>*ORIG_RAX,<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">long</span> _RAX=ptrace(PTRACE_PEEKUSER,pid,<span class="number">8</span>*RAX,<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (intocall)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Entering SYSCALL %ld .... "</span>,_ORIG_RAX);</span><br><span class="line">        intocall=<span class="number">0</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Exited with %ld\n"</span>,_RAX);</span><br><span class="line">        intocall=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ptrace(PTRACE_SYSCALL,pid,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="运行我们的程序"><a href="#运行我们的程序" class="headerlink" title="运行我们的程序"></a>运行我们的程序</h2><p>当然，如果你试图直接编译并运行上面这段程序肯定是失败的，因为你缺少一个用于被执行的“target”（就是execlp里的那个）。在这里，我们的第一个target是最经典的“Hello World!”程序：</p><figure class="highlight c"><figcaption><span>target.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Hello World!"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我建议你静态方式进行链接：</p><pre><code>gcc -static target.c -o target</code></pre><p>注意到我这里使用了<code>-static</code>参数，它的作用是将c运行时库静态链接入可执行文件中。你可以比较一下用两种方式编译的文件大小（几K和几百K的区别）。虽然用动态链接也可以，但是会和我之后的输出有一点点出入（因为动态链接文件需要根据环境变量搜索动态库）。现在把<code>target</code>和<code>demo4.c</code>放在同一目录下，然后</p><pre><code>gcc demo4.c -o demo4 &amp;&amp; ./demo4</code></pre><p>如果运行正确，你应该看到类似如下的输出</p><pre><code>Parent startedChild PiD == 9702Child sleeping...Child exec...Child execve() returned with 0Entering SYSCALL 63 .... Exited with 0Entering SYSCALL 12 .... Exited with 31248384Entering SYSCALL 12 .... Exited with 31252928Entering SYSCALL 158 .... Exited with 0Entering SYSCALL 89 .... Exited with 55Entering SYSCALL 12 .... Exited with 31388096Entering SYSCALL 12 .... Exited with 31391744Entering SYSCALL 5 .... Exited with 0Entering SYSCALL 9 .... Exited with 140378408579072Hello World!Entering SYSCALL 1 .... Exited with 13Entering SYSCALL 231 .... Child Exited</code></pre><h2 id="深入这段代码"><a href="#深入这段代码" class="headerlink" title="深入这段代码"></a>深入这段代码</h2><p>我先介绍一下各个头文件的用途：</p><ul><li><code>stdio.h</code>：（如果你不知道这个文件是干嘛的请重学C语言）</li><li><code>unistd.h</code>：提供<code>fork()</code>、<code>pid_t</code>、<code>execlp()</code>、<code>sleep()</code>等</li><li><code>sys/ptrace.h</code>：提供ptrace相关函数和宏定义</li><li><code>sys/wait.h</code>：提供<code>wait4()</code>和<code>WIFEXITED</code>宏</li><li><code>sys/resource.h</code>：提供<code>rusage</code>结构定义</li><li><code>sys/reg.h</code>：提供寄存器系列宏定义（<code>ORIG_RAX</code>等）</li></ul><p>看到代码的第15行，一个巨大的<code>if...else...</code>将代码清晰地分成了父子进程两个部分，16行的<code>ptrace(PTRACE_TRACEME,0,0,0);</code>首先吸引了我们的注意力。（为什么有一种在写春游作文的感觉）这个调用使得子进程被标记为<code>TRACED</code>并且使系统内核在子进程调用exec族函数<em>之后</em>通知父进程，这也是为什么17到19行的系统调用没有被追踪到的原因。<br>再看父进程部分，由于系统调用是一个从用户态到内核态再到用户态的过程，所以每进行一次系统调用都会触发两次<code>syscall_stop</code>,分别是进入时的<code>syscall_enter_stop</code>和离开内核时的<code>syscall_exit_stop</code>。这种子进程的状态的变化可以在父进程中使用<code>wait()</code>、<code>waitpid()</code>、<code>wait4()</code>等一票函数完成（还记得part1课后阅读中的僵尸进程么？）。值得注意的是，第一次的状态变化是由<code>execve()</code>调用返回导致的<code>syscall_exit_stop</code>，所以我在25到29行单独做了处理。我喜欢使用<code>wait4()</code>的原因是它还可以获得子进程的当前资源占用情况（就是那个<code>rusage</code>结构），这对于了解进程资源使用情况非常有用，只不过现在还用不到（我应该会在之后专门开几个part来讲系统资源的限制），所以我们只要关注那个<code>sta</code>就可以了。<br>注意下面那个大的<code>while</code>循环，在每次循环的开头等待，一旦<code>wait4()</code>返回，子进程就已经进入了暂停的状态（其实是内核给子进程发送了<code>SIGTRAP</code>信号，但因为子进程处于<code>TRACED</code>状态，所以这个信号被转交给了父进程，使父进程的<code>wait4()</code>返回，但这也意味着由其他方式引起的信号(比如<code>kill</code>命令)也会引起wait4的返回）。接着在32行使用<code>WIFEXITED</code>宏加上wait4收集的状态信息<code>sta</code>判断子进程是否已经退出，如果已退出，那么父进程也从循环中退出。当然这是一个非常粗糙的处理方式，更具完整的处理流程将在之后的part里介绍。接着，我们就可以使用各种各样的命令来调戏子进程了，这里我们只是简单的取得系统调用号和返回值。最后，在45行，让子进程继续执行，并要求子进程在下一个系统调用（进入或返回）停住，然后父进程开始等待下一次的<code>syscall_stop</code>。因为一次系统调用会导致两次<code>syscall_stop</code>，所以我使用变量<code>intocall</code>来分辨，并且在38到44行打印出不同的提示信息。顺带提一下，在输出中，<code>Hello World!</code>应该输出在<code>Entering SYSCALL 1</code>和<code>Exited with 13</code>中间，但因为缓冲区刷新的问题所以被输出到了前面。</p><p>终于到最激动人心的部分了！36、37两行代码是最重要的部分，可以看出，他们做的工作是差不多的，都是从子进程的内存空间中取一些数据。为了解释好这两行，我要讲一讲系统调用的调用过程。系统调用和普通的函数调用差不多，函数调用是将参数以约定好的顺序压入栈中，而系统调用则发生了一个类似上下文切换的过程：程序将需要调用的系统调用的调用号以及参数存入寄存器中，然后将所有寄存器存入栈中，进入内核态后，内核从栈中取得调用号和调用参数，并将返回值写入栈中对应寄存器的位置，最后还原寄存器的值并返回用户态，于是返回值就这样被“还原”到了寄存器里。在x86-64平台上，负责传递系统调用号和返回值的都是<code>RAX</code>寄存器，也就是说返回值会覆盖调用号，为了在系统调用返回时也能知道调用号，<code>RAX</code>寄存器在保存时被入栈两遍，一个是用于保存返回值的<code>RAX</code>，另一个是负责保存调用号的<code>ORIG_RAX</code>。现在，我们要获得寄存器的值，只要访问栈中的对应位置就可以了。而系统内核又会在系统调用时将栈中的这些信息复制一遍到一个叫做<code>u-area</code>(USER Area)的内存区域。在<code>sys/reg.h</code>头文件中定义了各寄存器保存时在<code>u-area</code>中的顺序，乘以每个寄存器的长度（64位系统自然就是8了嘛~~）就得到了我们所要访问的字节偏移量，<code>PTRACE_PEEKUSER</code>要求ptrace从指定偏移取出一个寄存器长度的数据（也就是8字节）作为返回值，于是<code>ptrace(PTRACE_PEEKUSER,pid,8*ORIG_RAX,0)</code>就能获得系统调用号啦！</p><h2 id="给32位系统的Tip"><a href="#给32位系统的Tip" class="headerlink" title="给32位系统的Tip"></a>给32位系统的Tip</h2><p>要让程序通过编译，需要做两个改动：</p><ol><li><p>在<code>int main()</code>之前加入这两个预处理命令：</p><pre><code>#define RAX EAX#define ORIG_RAX ORIG_EAX</code></pre></li><li><p>把26、36、37行ptrace第三个参数中的8全部改成4</p></li></ol><p>这是因为32位系统的寄存器长度是4字节，而且负责传递系统调用号和返回值的是<code>EAX</code>寄存器。</p><h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><ul><li><a href="http://sourceforge.net/projects/strace/" target="_blank" rel="noopener">strace</a>是一个用于监视并输出某程序系统调用情况的工具，比如<code>strace ./target</code></li><li><a href="http://man7.org/linux/man-pages/man7/signal.7.html" target="_blank" rel="noopener">Linux信号代码</a>：也可以通过查man手册得到<code>man 7 signal</code></li><li><a href="http://www.kgdb.info/gdb/playing_with_ptrace_part_i/" target="_blank" rel="noopener">Playing with ptrace</a>：Pradeep Padala 的关于ptrace的文章。</li><li><a href="http://blog.rchapman.org/post/36801038863/linux-system-call-table-for-x86-64" target="_blank" rel="noopener">x86_64 系统调用号列表</a>：也可以在<code>asm/unistd_64.h</code>头文件中找到，<code>asm/unistd_32.h</code>就是32位的</li><li><a href="http://www.hep.wisc.edu/~pinghc/Process_Memory.htm" target="_blank" rel="noopener">Process and Process Memory</a></li><li><strong>有问题或意见请务必留言啊啊啊啊~</strong>没人留言都不知道评论系统是否工作正常</li></ul>]]></content>
    
    <summary type="html">
    
      Second part of serial of tutorial: Programming with PTRACE
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="PTRACE" scheme="https://recursiveg.me/tags/PTRACE/"/>
    
  </entry>
  
  <entry>
    <title>Programming with PTRACE, Part1 - 起步</title>
    <link href="https://recursiveg.me/2014/04/programming-with-ptrace-part1/"/>
    <id>https://recursiveg.me/2014/04/programming-with-ptrace-part1/</id>
    <published>2014-04-17T13:16:29.000Z</published>
    <updated>2020-01-12T19:20:08.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人作为一个信息学竞赛的参与者，在很久之前曾经试图自己写过一个Online Judge系统（允许用户上传源代码并在服务器上编译运行），考虑到安全因素，必须要对程序的行为进行限制，因此对ptrace进行了一番研究。网上有一份关于ptrace的很好的教程（<a href="http://www.kgdb.info/gdb/playing_with_ptrace_part_i/" target="_blank" rel="noopener">Playing with ptrace</a>）,但是时间有点久了，而且没有涉及64位操作系统。因此，我决定写这份教程，基于64位Linux，尽力介绍一些新加入的功能，同时兼顾一下32位系统。另外，由于一开始的目的是“对程序的行为进行<em>限制</em>”，所以不会涉及到诸如设置断点之类的内容，相反，可能会涉及到其他关于系统资源管理的内容。<br><code>ptrace()</code>是一个由Linux内核提供的系统调用。它允许一个用户态进程检查、修改另一个进程的内存和寄存器。这种技术被广泛用于<code>gdb</code>等调试器中。尽管这系列文章的标题叫做“Programming with PTRACE”，但在第一部分中，我将着重介绍Linux的进程和相关的几个重要函数。</p><h2 id="fork-vfork-与-clone"><a href="#fork-vfork-与-clone" class="headerlink" title="fork(), vfork() 与 clone()"></a>fork(), vfork() 与 clone()</h2><p>在Linux中，每一个进程都有一个唯一的编号，被称作<code>pid</code>(Process ID)。在Linux中，进程不能凭空产生（<code>init</code>进程是个例外），只能从一个已有进程衍生出来。原来的进程被称做父进程，衍生出来的进程叫子进程。一个系统中所有进程以父子关系相连接，形成一棵树，这棵“树”的树根就是<code>init</code>进程，它是在系统启动时被直接启动的，因此它没有父进程。并且系统中所有其他进程都直接或间接地是它的子进程。在Linux系统中，实现“把一个进程变成两个”这一功能的有三个系统调用，即<code>fork()</code>、<code>vfork()</code>和<code>clone()</code>。</p><p><code>fork()</code>的工作流程的确和叉子有几分相似之处，它将当前进程所有数据复制一份，产生一个和父进程一模一样的子进程。并在两个进程中返回不同的返回值。比如这段代码：</p><figure class="highlight c"><figcaption><span>demo1.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> return_val;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Program started."</span>);</span><br><span class="line">    return_val=fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork() returned %d\n"</span>,return_val);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将会输出</p><pre><code>Program started.fork() returned 5768fork() returned 0</code></pre><p>很明显地可以看到，<code>puts()</code>只被调用了一次而<code>printf()</code>被调用了两次，这说明在<code>fork()</code>前的一个进程变成了两个，而且<code>fork()</code>在两个进程中有不同的返回值（这就是“调用一次，返回两次”的来历）。<code>fork()</code>会返回0给子进程，返回子进程的pid给父进程，因此，我们很容易判断出<code>fork() returned 0</code>是由子进程打印的。在实际应用中，也通过<code>if</code>语句判断返回值的方法来决定执行不同的代码：</p><pre><code>int pid=fork();if (pid==0){  //子进程的工作}else{  //父进程的工作}</code></pre><p>一般来说，子进程的工作就是调用<code>exec</code>族函数，启动另一个程序(把自己替换掉)。如果子进程还在执行而父进程已结束，那么它就成为“孤儿”进程，成为<code>init</code>进程的子进程。另外，请不要纠结那个<code>if</code>判断带来的性能损失，Linux的内核开发者都不纠结，你纠结什么呢？</p><a id="more"></a><p><code>vfork()</code>的存在是一个历史遗留问题，在很久很久以前，<code>fork()</code>调用是没有<a href="http://en.wikipedia.org/wiki/Copy_on_write" target="_blank" rel="noopener">CoW</a>机制的，如果fork出的一个子进程又立即调用了<code>exec</code>族函数，那么辛辛苦苦拷贝出来的内存又立马被扔进了废纸篓里（这个比喻可能不太恰当，毕竟被从内存里抹去的数据是捡不回来的）。Linux的开发者当然不会允许效率如此低下的事情发生，于是他们创造出了<code>vfork()</code>。它和<code>fork()</code>最大的差别在于，vfork出的子进程，在执行<code>exec</code>族函数前和父进程<strong>共享同一块内存</strong>。也就是说，子进程对内存的修改也会体现在父进程上。只有当子进程执行了<code>exec</code>族函数，它才真正拥有一块属于自己的内存。这样就节省了<code>fork()</code>中那个无意义的内存拷贝。现在因为有了CoW，<code>fork()</code>和<code>vfork()</code>已经几乎没有性能差异了。</p><figure class="highlight c"><figcaption><span>demo2.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid,x=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"X=%d\n"</span>,x);</span><br><span class="line">    pid=vfork();</span><br><span class="line">    <span class="keyword">if</span> (pid==<span class="number">0</span>)&#123;</span><br><span class="line">        x+=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Child-X=%d\n"</span>,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        x+=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Parent-X=%d\n"</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码输出，而且一定输出</p><pre><code>X=1Child-X=2Parent-X=3</code></pre><p>很好地说明了内存的共享，如果换成<code>fork()</code>，那么父子进程就都输出X=2了。<br>也许有人会问，为什么不可能是父进程先输出呢？这涉及到<code>vfork()</code>的另一个特点。如果使用<code>vfork()</code>创建进程，那么在子进程使用<code>exec</code>族函数或是<code>_exit()</code>(这就是我为什么不用<code>return 0</code>的原因，但没有详细研究过原因，求大神指教)之前，父进程会始终等待vfork返回。比如以下代码：</p><figure class="highlight c"><figcaption><span>demo3.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    pid=vfork();</span><br><span class="line">    <span class="keyword">if</span> (pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Child Sleeping..."</span>);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Child Exit."</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Parent Exit."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><pre><code>Child Sleeping...//这里等了3秒Child Exit.Parent Exit.</code></pre><p>而改成<code>fork()</code>后输出</p><pre><code>Parent Exit.Child Sleeping...~$//这里等了3秒Child Exit.</code></pre><p>可以明显看出两者差别。(给Windows用户的Tip: 那个<code>~$</code>是Linux终端的提示符，类似cmd)</p><p><code>clone()</code>函数提供了更多的控制选项，可自由决定要执行哪个代码片段甚至是哪些内存共享，哪些内存要复制。但我没怎么用过，不敢乱说，有兴趣的读者可以自行实验。</p><h2 id="令人困惑的exec族函数"><a href="#令人困惑的exec族函数" class="headerlink" title="令人困惑的exec族函数"></a>令人困惑的exec族函数</h2><p>我在这篇文章之前的部分N次提到了一个叫<code>exec族函数</code>的东西，如果我们man手册里查找(<code>man 3 exec</code>)，我们会得到一大堆函数（是不是开始感到困惑了？）：</p><pre><code>int execl  (const char *path, const char *arg, ...);int execlp (const char *file, const char *arg, ...);int execle (const char *path, const char *arg, ..., char * const envp[]);int execv  (const char *path, char *const argv[]);int execve (const char *path, char *const argv[], char *const envp[]);int execvp (const char *file, char *const argv[]);int execvpe(const char *file, char *const argv[], char *const envp[]);</code></pre><p><code>exec族函数</code>就是这一“族”函数，全部以exec打头，他们都是对系统调用<code>execve()</code>的包装。他们的作用就是把某个进程（通常是fork出来的子进程）从里到外，完完整整，包括代码、堆栈，全部换成另一个程序，然后从头开始运行。它们的调用效果是一样的，区别在于调用方式。总的来说，大致的参数顺序是这样的：<code>exec*(可执行文件路径，程序参数表[,环境变量表])</code>，其中环境变量表是可选的。<br>去掉打头的exec，带<code>l</code>（代表list）的函数使用了一种比较接近人类方法来表示程序参数表，即以<code>NULL</code>作为结尾（man手册推荐使用<code>(char *)0</code>）的变参列表；而带<code>v</code>(代表vector)的则使用一个字符串数组来表示程序参数表，就像<code>int main(int argc,char *argv[])</code>里的<code>argv</code>一样。<br>如果结尾带<code>e</code>（environment），则该函数接受一个字符串数组表示的环境变量表；反之，则会默认传递所有当前环境变量。如果带有<code>p</code>，那么你就不必在第一个参数中列出完整路径，系统会自动检查当前目录和<code>PATH</code>环境变量（如果你非要手贱加个路径分割符进去，那么系统就会把它当成完整路径）。<br>值得一提的是，不管你使用那种方法表示程序参数表，第0个参数（C的数组下标从0开始，记得么？）都应当和可执行文件路径保持一致，虽然不一致依然可以正确运行，但有可能出现奇奇怪怪的问题。（博主继续偷懒，欢迎各位读者当小白鼠自行实验）。如果你已经混乱了，或是直接跳过了上面的一大堆说明直接到了这，那么我推荐你直接使用<code>execlp()</code>函数，比如说，你要运行一个叫<code>foo</code>的程序：</p><pre><code>execlp(&quot;foo&quot;,&quot;foo&quot;,NULL);</code></pre><p>或是列举出根目录下所有文件：</p><pre><code>execlp(&quot;ls&quot;,&quot;ls&quot;,&quot;/&quot;,NULL);</code></pre><h2 id="继续之前的其他一些准备"><a href="#继续之前的其他一些准备" class="headerlink" title="继续之前的其他一些准备"></a>继续之前的其他一些准备</h2><p>从本系列的下一篇开始，我将要开始讨论<code>ptraec()</code>这一强大的工具。但是，如果你有一下现象之一的，我建议你<em>不要</em>继续阅读并且从头学习有关<code>*nix</code>系列系统的知识：</p><ol><li>基本看不懂这篇文章的</li><li>不会C语言的</li><li>狂热的Windows爱好者</li><li>不会使用<a href="https://www.google.com" target="_blank" rel="noopener">Google</a>的</li><li>没有IDE就不会编译程序的</li><li>没有听说过<code>寄存器</code>，<code>堆栈</code>的</li></ol><p>另外，<code>ptrace()</code>相当接近系统底层，对内核版本，系统构架，指令长度，库头文件等有相当大的依赖性，如果你还在使用2.x系列的内核，你可能在之后遇到问题，因为一些功能在新版本内核才被加入。我在这里列出我的编程环境：</p><ul><li>系统: ArchLinux x86_64</li><li>内核: Linux 3.14.1</li><li>glibc 2.19</li><li>gcc 4.8.2</li></ul><p>另外，这里有更多关于进程的文章</p><ul><li><a href="http://www.cnblogs.com/vamei/archive/2012/09/20/2694466.html" target="_blank" rel="noopener">Linux进程基础</a> （我觉得其中关于食谱的那个比喻不太恰当，也许程序和进程的关系更像类和类的实例的关系？）</li><li><a href="http://www.ibm.com/developerworks/cn/linux/l-linux-process-management/" target="_blank" rel="noopener">Linux 进程管理剖析</a> (IBM developerWorks是我超喜欢的一个网站，有相当多高质量的文章)</li><li><a href="http://coolshell.cn/articles/656.html" target="_blank" rel="noopener">Linux 的僵尸(zombie)进程</a></li></ul>]]></content>
    
    <summary type="html">
    
      First part of serial of tutorial: Programming with PTRACE
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="PTRACE" scheme="https://recursiveg.me/tags/PTRACE/"/>
    
  </entry>
  
  <entry>
    <title>有屏幕的地方就有烂苹果</title>
    <link href="https://recursiveg.me/2014/03/bad-apple-character-player/"/>
    <id>https://recursiveg.me/2014/03/bad-apple-character-player/</id>
    <published>2014-03-19T11:55:49.000Z</published>
    <updated>2020-01-12T19:20:09.376Z</updated>
    
    <content type="html"><![CDATA[<p>如果你还不知道Bad Apple是什么东西，请移步<a href="http://zh.wikipedia.org/wiki/Bad_apple!!" target="_blank" rel="noopener">这里</a><br>播放的原理很简单，就是不停的打印清屏再打印清屏。任何一个略有编程基础的人都能做到。比较令人头大的是如何把原视频转化为一个易于解析而且又不占地方的文件。<br>其实，借助<code>FFmpeg</code>、<code>ImageMagick</code>和一点点的编程小技巧就可以轻松完成。</p><p>第一步当然是要去下一个视频文件，我已经下好了，叫做<code>BadApple.mkv</code>。</p><a id="more"></a><p>第二步要把视频变成一帧一帧的图片，请出FFmpeg来帮忙:</p><pre><code>ffmpeg -i BadApple.mkv -s 80x60 -r 15 Ba%d.png</code></pre><p>然后你就会得到<code>Ba1.png Ba2.png Ba3.png</code>等一大堆文件，这就是各帧了。注意我在这一步同时把大小缩小到了80*60和把帧速率调到了15帧每秒。</p><p>第三步用ImageMagick将图像转换成黑白图，然后再转换成<code>xpm</code>格式。XPM格式本质上是一个文本文档，可以直接被<code>#include</code>。我们这一步要用到一点点脚本技巧。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> *.png</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  convert <span class="variable">$x</span> -monochrome `basename -s .png <span class="variable">$x</span>`.xpm</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>最后写一段C语言小程序，利用游程编码进一步缩小文件体积。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;xpm.h&quot;</span><br><span class="line">void main()&#123;</span><br><span class="line">  FILE *f&#x3D;fopen(&quot;BA.dat&quot;,&quot;a&quot;);</span><br><span class="line">  char count;</span><br><span class="line">  int t&#x3D;ARR[0][6]&#x3D;&#x3D;&#39;1&#39;?1:2;</span><br><span class="line">  for(int i&#x3D;1+t;i&lt;61+t;i++)&#123;</span><br><span class="line">    count&#x3D;1;</span><br><span class="line">    for(int j&#x3D;1;j&lt;80;j++)&#123;</span><br><span class="line">      if(ARR[i][j]&#x3D;&#x3D;ARR[i][j-1])&#123;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        if(ARR[i][j]&#x3D;&#x3D;&#39;.&#39;)count&#x3D;-count;</span><br><span class="line">        fprintf(f,&quot;%c&quot;,count);</span><br><span class="line">        count&#x3D;1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ARR[i][79]&#x3D;&#x3D;&#39; &#39;)count&#x3D;-count;</span><br><span class="line">    fprintf(f,&quot;%c&quot;,count);</span><br><span class="line">    fprintf(f,&quot;%c&quot;,0);</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，离不了脚本和编译器的帮助，我这里使用了<code>tcc</code>进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (( i=1; i&lt;=3288; i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  cp Ba<span class="variable">$i</span>.xpm xpm.h</span><br><span class="line">  tcc -DARR=Ba<span class="variable">$i</span> bad_apple.c &amp;&amp; ./a.out</span><br><span class="line">  rm xpm.h</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>其中，那个3288就是总帧数。这样就得到了一个<code>BA.dat</code>文件。文件内容是一堆用二进制存储的数字，正数代表连续的白色，负数代表连续的黑色，零代表换行。一帧60行，总计3288帧。这样就把一个80多兆的视频压缩到了900多K。有了数据文件剩下的就好办了。</p><p><strong>未完待续。。。。。。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你还不知道Bad Apple是什么东西，请移步&lt;a href=&quot;http://zh.wikipedia.org/wiki/Bad_apple!!&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;&lt;br&gt;播放的原理很简单，就是不停的打印清屏再打印清屏。任何一个略有编程基础的人都能做到。比较令人头大的是如何把原视频转化为一个易于解析而且又不占地方的文件。&lt;br&gt;其实，借助&lt;code&gt;FFmpeg&lt;/code&gt;、&lt;code&gt;ImageMagick&lt;/code&gt;和一点点的编程小技巧就可以轻松完成。&lt;/p&gt;
&lt;p&gt;第一步当然是要去下一个视频文件，我已经下好了，叫做&lt;code&gt;BadApple.mkv&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="技术宅" scheme="https://recursiveg.me/tags/%E6%8A%80%E6%9C%AF%E5%AE%85/"/>
    
      <category term="东方Project" scheme="https://recursiveg.me/tags/%E4%B8%9C%E6%96%B9Project/"/>
    
  </entry>
  
  <entry>
    <title>在Linux下使用MinGW静态交叉编译带有zlib的libcurl</title>
    <link href="https://recursiveg.me/2014/02/how-to-cross-compile-libcurl-on-linux/"/>
    <id>https://recursiveg.me/2014/02/how-to-cross-compile-libcurl-on-linux/</id>
    <published>2014-02-28T13:17:41.000Z</published>
    <updated>2020-01-12T19:20:09.810Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://curl.haxx.se/" target="_blank" rel="noopener">libcurl</a>是一个跨平台的、易用的、强大的网络库。在大部分Linux发行版中都有编译好的二进制包可供使用，Mac系统更是将其作为了一个核心部件。但是在Windows平台上却需要手工编译，更不必说一些有特殊洁癖的人（比如说我）还特别讨厌多出来几个DLL,非要静态链接不可。本文作为我两个晚上折腾经历的一个小小总结，讲解如何在Linux下使用MinGW编译给Windows使用的libcurl静态库。</p><a id="more"></a><h3 id="STEP1-安装MinGW编译器"><a href="#STEP1-安装MinGW编译器" class="headerlink" title="STEP1 安装MinGW编译器"></a>STEP1 安装MinGW编译器</h3><p>这步我不打算多说，大部分Linux发行版的仓库应该都有，以我的ArchLinux为例，执行：</p><pre><code>~# pacman -S mingw-w64</code></pre><p>即可。如果你不需要交叉编译，要在Windows上直接编译，请自行去SourceForge上下载Windows版本。不要担心那个<code>w64</code>是不是64位版本，它既可以编译32位又可以编译64位程序。还是以我的版本为例:</p><pre><code>~# pacman -Ql mingw-w64-gcc| grep &apos;/usr/bin/.*gcc$&apos;mingw-w64-gcc /usr/bin/i686-w64-mingw32-gccmingw-w64-gcc /usr/bin/x86_64-w64-mingw32-gcc</code></pre><p>可以看到有两个gcc,用<code>i686-w64-mingw32-gcc</code>编译出来的程序就是32位的，而<code>x86_64-w64-mingw32-gcc</code>编译出来的就是64位的。现在，随便写个Hello World（你可以用我的<a href="/2012/12/helloworld/">Hello World代码</a> ^_^），然后编译试试：</p><pre><code>i686-w64-mingw32-gcc hello_world.c -o hello_world.exe</code></pre><p>把它拿到虚拟机或扔进Wine里，如果能正常运行，那么恭喜你，第一步完成了。</p><!--more--><h3 id="STEP2-下载源码"><a href="#STEP2-下载源码" class="headerlink" title="STEP2 下载源码"></a>STEP2 下载源码</h3><p>很简单的步骤，如果自己搞不定的建议直接右上角。</p><ul><li><a href="http://curl.haxx.se/download.html" target="_blank" rel="noopener">LibCurl</a>:最上面的Source Archives</li><li><a href="http://www.zlib.net/" target="_blank" rel="noopener">zLib</a>:请下Source Code</li><li><a href="https://www.openssl.org/source/" target="_blank" rel="noopener">OpenSSL</a>:可选，如果没有必要就不要编译，会极大地增加文件体积</li></ul><p>把<code>curl-7.35.0</code>和<code>zlib-1.2.8</code>(可能还有<code>openssl-1.0.1f</code>)这几个文件夹放在同一个目录下，然后进行下一步。</p><h3 id="STEP3-编译源码"><a href="#STEP3-编译源码" class="headerlink" title="STEP3 编译源码"></a>STEP3 编译源码</h3><p>先打开<code>zlib/win32</code>文件夹下的<code>Makefile.gcc</code>文件,把<code>PREFIX =</code>这行改成STEP1里的gcc前缀，对于我来说就是<code>PREFIX = i686-w64-mingw32-</code>。把这个文件拷贝到<code>zlib</code>文件夹下，然后在<code>zlib</code>文件夹下<code>make -f Makefile.gcc</code>，你就应该能看到<code>libz.a</code>这个文件了。</p><p>如果你要编译OpenSSL,那么就去openssl文件夹下</p><pre><code>$ ./Configure no-shared --cross-compile-prefix=i686-w64-mingw32- mingw$ make</code></pre><p>即可，记得改prefix。生成<code>libssl.a</code>和<code>libcrypto.a</code></p><p>最后去libcurl里的lib文件夹里修改<code>Makefile.m32</code>文件，在<code>CC    = $(CROSSPREFIX)gcc</code>上加一行<code>CROSSPREFIX=i686-w64-mingw32-</code>（请按需修改），然后把下面<code>CFLAGS</code>那行改成这样<code>CFLAGS    = -g -O2 -Wall -DCURL_DISABLE_LDAP</code>，最后</p><pre><code>make -f Makefile.m32 CFG=-zlib</code></pre><p>或是</p><pre><code>make -f Makefile.m32 CFG=-zlib-ssl</code></pre><p>make到最后时会报个错，是因为文件没放对地方，手动挪一下即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> vtls/openssl.o vtls/gtls.o vtls/vtls.o vtls/nss.o vtls/qssl.o vtls/polarssl.o vtls/polarssl_threadlock.o vtls/axtls.o vtls/cyassl.o vtls/curl_schannel.o vtls/curl_darwinssl.o vtls/gskit.o</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    mv `basename <span class="variable">$x</span>` vtls</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>然后再make一下，<code>libcurl.a</code>文件应该就出现了。<br>如果生成dll出错也不要紧，我们要的是<code>.a</code>文件</p><h3 id="STEP4-测试"><a href="#STEP4-测试" class="headerlink" title="STEP4 测试"></a>STEP4 测试</h3><p>现在，你可以找一段libcurl的demo来测试了。注意要加上宏定义<code>CURL_STATICLIB</code></p><pre><code>i686-w64-mingw32-gcc -I. -L. -DCURL_STATICLIB curl_demo.c -lcurl -lz -lws2_32 -o curl_demo.exe</code></pre><p>如果你因为不知道gcc<code>-I</code>和<code>-L</code>选项的用法而编译不过，请自行Google。如果你加了ssl支持，你需要链接更多的库，具体请根据错误信息自行Google。最后提醒一点:<strong>请把<code>-lcurl</code>选项放在源文件后面</strong>，我当初就是因为这个死活链接不过。最后把<code>curl_demo.exe</code>拖进虚拟机里，如果一切正常，那么恭喜你，你成功了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://curl.haxx.se/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;libcurl&lt;/a&gt;是一个跨平台的、易用的、强大的网络库。在大部分Linux发行版中都有编译好的二进制包可供使用，Mac系统更是将其作为了一个核心部件。但是在Windows平台上却需要手工编译，更不必说一些有特殊洁癖的人（比如说我）还特别讨厌多出来几个DLL,非要静态链接不可。本文作为我两个晚上折腾经历的一个小小总结，讲解如何在Linux下使用MinGW编译给Windows使用的libcurl静态库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="MinGW" scheme="https://recursiveg.me/tags/MinGW/"/>
    
      <category term="交叉编译" scheme="https://recursiveg.me/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>记一次坑爹的乱码解决过程</title>
    <link href="https://recursiveg.me/2014/02/clear-a-special-kind-of-messy-code/"/>
    <id>https://recursiveg.me/2014/02/clear-a-special-kind-of-messy-code/</id>
    <published>2014-02-08T06:12:59.000Z</published>
    <updated>2020-01-12T19:20:10.260Z</updated>
    
    <content type="html"><![CDATA[<p>某日，我在网上下载了一些音乐，然后打开，发现了乱码。Linux系统上出现乱码本不是什么好大惊小怪的事，但是，在经过N种方法来回折腾依然无法解决的情况下，我意识到，这大约是我见过的最奇葩的一种乱码了。先上图：<br><img src="/images/clear-a-special-kind-of-messy-code/1.png" alt="An Example of the Messy Code"></p><a id="more"></a><p>为了解释这个问题，我要先引入Python3中的字符串与字节序列的概念。在Python3中，一个字符串不存在‘编码类型’这种概念，每一个包含相同文字的字符串都是完全一样的(确切的讲,Python3中的字符串是以<a href="https://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">Unicode</a>编码的字节序列)。而字节序列和C中的char数组很像，它是字符串保存在文件系统上的真正形态。一个固定的字符串(即包含相同的文字)可以被编码(即Python中的<code>encode()</code>)成字节序列。如果对其使用不同的编码方式，生成的字节序列也不同。举个例子，一栋房子地面上的第一层，英国人叫它&#39;ground floor&#39;，而美国人叫它‘first floor’。这就是不同的编码方式。相反，解码(Python中的<code>decode()</code>)就是把一个字节序列变回字符串。在普通情况下，乱码是由于对一个字节序列使用了错误的编码方式进行解码，解码之后的内容自然无法阅读。就像一个英国人给一个美国人留了张便条，写着‘Meet me at first floor.’(二楼)，然后美国人去一楼转了半天都没找到。这种使用了错误的解码方式的问题一般是由于操作系统的默认设定造成的，比如Windows系统使用当地语言的编码(大陆GBK,台湾BIG5,日本SHIFT-JIS之类的)，而Linux普遍使用UTF-8编码。解决这种乱码的方法也很简单，你不是默认以UTF8方式解读么？而现在的字节序列又需要以GBK方式解读才能获得正确的内容，那么我们只要找到一个字节序列，让它被以UTF8解码时得到的内容和现在的字节序列被以GBK解码时得到的内容一样就行了。具体方法就是把当前的字节序列先以GBK解码，再以UTF-8编码，然后写回文件系统里，就搞定了。这个命令在Linux上就是<code>iconv -f GBK -t UTF-8</code>(记得加管道)。</p><p>但是，这次的乱码坑爹就坑爹在: 它的字节序列(字符串是以字节序列的形式保存在磁盘上的，还记得么？)无法以GBK方式解码，相反，它更像是一个根正苗红的UTF-8编码的字节序列。在多次尝试失败后，我开始无聊地“欣赏”乱码字符。注意到那些字符上的装饰了么？就是那些小点波浪尖角什么的？我也注意到了。然后我意识到，这是显著的西欧字符集的特征。也就是说，曾经有某个字节序列被以ISO-8859-1(一种西欧字符集)解码过一次，然后才表现出了现在的样子。那么，我们把现在的<strong>字符串</strong>用ISO-8859-1编码一次看看：<code>iconv -f UTF-8 -t ISO-8859-1</code>(因为我的系统的默认编码是UTF-8，所以需要‘-f UTF-8’)。然后得到了一坨问号，这正是GBK编码以UTF-8方式解码的结果，于是再接再厉：<code>iconv -f GBK -t UTF-8</code>。终于看到了熟悉的文字。最终，这个问题以两行命令被解决(因为是文件名乱码，所以用<code>convmv</code>命令)：</p><pre><code>convmv -f UTF-8 -t ISO-8859-1 --notest *convmv -f GBK -t UTF-8 --notest *</code></pre><p><strong>总结：</strong>这个乱码的产生原因也是对字节序列使用了错误的解码方式（对GBK字节序列使用ISO-8859-1解码），但是因为最终的字节序列是一个根正苗红的UTF-8编码，所以特别难以解决。这种问题特别容易发生在网络当中，比如，一个网站允许用户上传文件，因为一些原因，这个网站把所有的文件名都转成UTF-8存储，如果用户用西欧语言，那么这样就完全没关系，但如果一个中国用户上传了一个GBK文件名编码的文件，那么这种问题就发生了。</p><p>如果大家对排版或是图片之类的有什么意见建议请务必留言。<br><strong>做人要厚道，转载请注明出处</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;某日，我在网上下载了一些音乐，然后打开，发现了乱码。Linux系统上出现乱码本不是什么好大惊小怪的事，但是，在经过N种方法来回折腾依然无法解决的情况下，我意识到，这大约是我见过的最奇葩的一种乱码了。先上图：&lt;br&gt;&lt;img src=&quot;/images/clear-a-special-kind-of-messy-code/1.png&quot; alt=&quot;An Example of the Messy Code&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="乱码" scheme="https://recursiveg.me/tags/%E4%B9%B1%E7%A0%81/"/>
    
      <category term="Python" scheme="https://recursiveg.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>网站从Octopress迁移至Hexo</title>
    <link href="https://recursiveg.me/2013/12/site-migration-complete/"/>
    <id>https://recursiveg.me/2013/12/site-migration-complete/</id>
    <published>2013-12-24T13:26:08.000Z</published>
    <updated>2020-01-12T19:01:21.744Z</updated>
    
    <content type="html"><![CDATA[<p>经过我两个小时的折腾，总算是重新把网站弄起来了。Ruby实在是坑爹，各种gem装得目录结构乱七八糟的……（强迫性人格障碍的典型表现）而且速度还慢……<br>曾尝试用Python和Tornado模板自己写一个静态页面生成器，然后发现我想多了。我果然还是不适合写UI……<br>一通Google之后，最终决定使用Hexo。它使用node.js(也就是javascript)作为编程语言(这样说恰当么？反正就是这个意思啦),据说速度极快。最重要的是，AUR源里有Hexo打好的包，能用pacman管理就是好。<br>主题试了一圈下来还是默认的Light看着最舒心。<strong>以后千万不能再手贱自己写主题了！！</strong><br>膜拜一下Hexo的作者tommy351。自己改了一下高亮配色和Widgets，把以前Octopress的Markdown文档做了一点点修改，这样就算上线了吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经过我两个小时的折腾，总算是重新把网站弄起来了。Ruby实在是坑爹，各种gem装得目录结构乱七八糟的……（强迫性人格障碍的典型表现）而且速度还慢……&lt;br&gt;曾尝试用Python和Tornado模板自己写一个静态页面生成器，然后发现我想多了。我果然还是不适合写UI……&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Hexo" scheme="https://recursiveg.me/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>通用存储及分布式文件共享系统的设想</title>
    <link href="https://recursiveg.me/2013/03/universal-storge/"/>
    <id>https://recursiveg.me/2013/03/universal-storge/</id>
    <published>2013-03-30T12:02:00.000Z</published>
    <updated>2020-01-12T19:01:22.228Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Update: 本计划已无限期暂停，在可预见的未来没有重启计划，如有需要资料的欢迎发邮件索取</strong></p><p>众所周知，网盘这东西对大众来说不可或缺，国内的在线存储服务也欣欣向荣。但是，由于各种原因，我们仍感到这些不能完全满足我们的要求。<br>比如各种限制、各种暂停分享、还有各种必须付钱才能用的VIP服务等。各大公司想挣钱无可非议，毕竟网络存储绝对是烧钱的主，但作为一个搞技术的人，决不能整天写登陆界面，对吧？<br>动机在<a href="/2013/01/data-structure-of-vdisk/">新浪微盘数据结构解析</a>中说了，在那之后我又研究了其他的网盘，萌生了这么一个设想。<br>简要的说，这个系统可以大大方便文件的传播与获取，延长资源的存活时间。</p><a id="more"></a><p>废话不多说，以下是我的构想：</p><ol><li>人肉解析各资源站链接协议，比如下载上传链接解析什么的。</li><li>写成模块，类库什么的，方便调用。</li><li>以统一的界面管理多处资源，进行下载、上传等。</li><li>以写成的库为基础，对资源进行自动管理，比如可以分块存储于不同的位置，或是创建多个备份等。</li><li>维护一个数据库，存储用户共享信息，实现全网资源搜索。其实，不仅文件可以是分布式的，数据库也可以是分布式的，技术细节正在努力构思中。</li><li>有条件的同学可以在自己的服务器上运行一个特殊的服务端，接受来自其他用户的请求，比如一些已被停止共享的文件的下载(比如115的VIP的离线下载功能)。</li></ol><p><strong>更多可能，任君想象</strong></p><p>可能你们已经注意到了，我尽可能的避免使用<code>网盘</code>这个字眼。没错，我的目标不仅是网盘，我还希望加入一些“只读”的资源，比如通过解析视频网站的地址来下载视频文件等。正如Bilibili所做的那样(不过也许他们有合作关系？)。<br>目前，统一管理界面正在书写中，使用Python3, 应该不久可以放出Alpha版和API。不过，最后，我要给大家浇盆冷水，<em>本计划仍处于设想阶段</em>，不要期望能瞬间完成。而且，我们需要考虑遭到封杀后的应对措施，以及如何保持协议更新后库的快速升级等问题。</p><p>PS：欢迎有兴趣和有能力的同学来信交流：<code>gzh.shadow@gmail.com</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Update: 本计划已无限期暂停，在可预见的未来没有重启计划，如有需要资料的欢迎发邮件索取&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;众所周知，网盘这东西对大众来说不可或缺，国内的在线存储服务也欣欣向荣。但是，由于各种原因，我们仍感到这些不能完全满足我们的要求。&lt;br&gt;比如各种限制、各种暂停分享、还有各种必须付钱才能用的VIP服务等。各大公司想挣钱无可非议，毕竟网络存储绝对是烧钱的主，但作为一个搞技术的人，决不能整天写登陆界面，对吧？&lt;br&gt;动机在&lt;a href=&quot;/2013/01/data-structure-of-vdisk/&quot;&gt;新浪微盘数据结构解析&lt;/a&gt;中说了，在那之后我又研究了其他的网盘，萌生了这么一个设想。&lt;br&gt;简要的说，这个系统可以大大方便文件的传播与获取，延长资源的存活时间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Black Technology" scheme="https://recursiveg.me/tags/Black-Technology/"/>
    
      <category term="网盘" scheme="https://recursiveg.me/tags/%E7%BD%91%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>Pascal中鲜为人知的那些技巧</title>
    <link href="https://recursiveg.me/2013/01/cheat-with-pascal/"/>
    <id>https://recursiveg.me/2013/01/cheat-with-pascal/</id>
    <published>2013-01-31T13:46:00.000Z</published>
    <updated>2020-01-12T19:20:10.706Z</updated>
    
    <content type="html"><![CDATA[<p>做为一个搞信息学竞赛这么长时间的人，再加上估计很快就要转C++了，我觉得我有必要留下一些关于Pascal语言的资料，于是就有了这篇文章。我只负责解释用法，对基础概念不了解的请自行Google。所有这篇文章里的东西应该都能在Free Pascal自带的文档里找到，我写出来是为了众多不喜欢看英文的同学们，如果你愿意自己去看一下，一定会收益匪浅。</p><h3 id="不同进制的表示"><a href="#不同进制的表示" class="headerlink" title="不同进制的表示"></a>不同进制的表示</h3><p>平时我们写的常量都是十进制数，但我们有时需要写一个比如十六进制数怎么办呢？我们当然可以手动计算一下，但还有更优雅的方法。</p><pre><code>writeln($Ff,#32,&amp;10,#32,%100);</code></pre><p>你觉得它会输出什么呢？它输出<code>255 8 4</code>!所以以<code>$</code>开头的是16进制数，<code>&amp;</code>开头的是8进制数，<code>%</code>开头的是二进制数。顺带一提的是，以<code>#</code>开头的数会转变成对应ASCII码的字符，其实它可以和前面的三个符号共同使用，即<code>#$20</code>和<code>#%100000</code>都代表了空格。</p><a id="more"></a><h3 id="函数内联"><a href="#函数内联" class="headerlink" title="函数内联"></a>函数内联</h3><p>关于内联的解释请自己找资料，写法如下：</p><pre><code>function foo(bar:Type):ReturnType;inline;</code></pre><p>即在函数头后加<code>inline;</code>即可。测试证明确实有效，不过建议只用于诸如<code>min</code>或<code>max</code>这种函数。</p><h3 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h3><p>Pascal也是支持重载的，甚至可以重载系统函数！演示如下：</p><pre><code>procedure sort(var a:TArray;l,r:longint);begin  ...end;procedure sort(var a:TArray;r:longint);begin  sort(a,1,r)end;</code></pre><p>这样，调用<code>sort(arr,top)</code>就相当于调用<code>sort(arr,1,top)</code>.</p><h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><p>是不是对写高精度时的<code>plus(a,b)</code>感到厌倦？是不是想换一种更帅的书写方式？没问题，操作符重载能满足你的愿望！它可以让你用<code>a+b</code>的形式对高精度进行计算！</p><pre><code>operator + (a,b:Type) c:Type;operator := (a:Type1) b:Type2;operator &gt; (a,b:Type) c:boolean;</code></pre><p>需要注意的是</p><ul><li>比较操作符的返回值只能是<code>Boolean</code></li><li>二元操作符和赋值操作符如果两端类型不同不能随意交换位置</li><li>重载后优先级不变</li></ul><p>为了解决不能随意交换位置的问题，你可以这样写：</p><pre><code>operator + (a:Type1;b:Type2)c:ReturnType;begin  ...end;operator + (a:Type2;b:Type1)c:ReturnType;begin  c:=b+aend;</code></pre><h3 id="想重载str-和val-？"><a href="#想重载str-和val-？" class="headerlink" title="想重载str()和val()？"></a>想重载str()和val()？</h3><p>看完前面的函数重载，你是不是迫不及待地想要重载<code>val()</code>和<code>str()</code>这两个你看着不爽很久的函数了？但是却发现不能调用系统原来的函数了，Pascal把它当成了递归！解决方法很简单，在要用原始系统函数的地方加上<code>system.</code>即可。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">str</span><span class="params">(x:longint)</span>:</span><span class="keyword">string</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="comment">//str(x,str)&lt;--This is completely wrong!</span></span><br><span class="line">  system.str(x,str);<span class="comment">//&lt;--This is the right form</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>担心数组太大爆内存？但心数组太小存不下？动态数组解除你的忧虑！主要操作如下：</p><ol><li><code>a:array of Type;</code>：变量声明。</li><li><code>setlength(a,length)</code>：设定数组下标，范围为<code>[0..length-1]</code>，会自动清零。</li><li><code>b:=a</code>:看上去像是赋值，但其实不是赋值，只是复制地址而已，因此对<code>b</code>的修改就是对<code>a</code>的修改。</li><li><code>c:=copy(a,0,length(a))</code>：这就是真正的赋值了！还记得<code>copy()</code>和<code>length()</code>函数么？现在它们可以用于动态数组了！</li><li><code>d:array of array of Type</code>:二维动态数组声明。</li><li><code>setlength(d,length1,length2)</code>:不解释。</li><li><code>a:=d[1]</code>:<code>a</code>是一维动态数组，对<code>a[x]</code>的修改就是对<code>d[1][x]</code>的修改。</li><li><code>copy(d[x],0,length(d[x]))</code>:取出第<code>x</code>个一维动态数组。</li><li>二维动态数组可以用<code>d[x,y]</code>的方式访问，也可以用<code>d[x][y]</code>的方式访问。</li></ol><h3 id="取地址操作符"><a href="#取地址操作符" class="headerlink" title="取地址操作符"></a>取地址操作符</h3><p>想用C语言中的<code>&amp;</code>操作符？在Pascal中它是<code>@</code>!估计某年的NOIP坑了不少人。</p><h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>你还在定义<code>text</code>类型么？你还在用查找替换功能批量替换你的<code>readln()</code>么？赶快试试这个！</p><pre><code>assign(input,&apos;foo.in&apos;);reset(input);assign(output,&apos;foo.out&apos;);rewrite(output);...close(input);close(output);</code></pre><p>再也不用担心输入输出了！</p><h3 id="用动态数组实现伪变参"><a href="#用动态数组实现伪变参" class="headerlink" title="用动态数组实现伪变参"></a>用动态数组实现伪变参</h3><p>是不是很羡慕C中<code>printf</code>的变参？是不是很羡慕<code>writeln</code>可以有好多好多参数？利用动态数组可以实现类似的功能！</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">average</span><span class="params">(arr:<span class="keyword">array</span> <span class="keyword">of</span> longint)</span>:</span>real;</span><br><span class="line"><span class="keyword">var</span> i:longint;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  average:=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> high(arr) <span class="keyword">do</span></span><br><span class="line">    average:=average+arr[i];</span><br><span class="line">  average:=average/length(arr)</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>请注意其中<code>high()</code>和<code>length()</code>的区别。合法调用如下：</p><pre><code>var A:array[1..MAX]of longint;average([3]);average([1,2,3,4]);average(A);average(A[1..5]);</code></pre><h3 id="函数也是变量？！"><a href="#函数也是变量？！" class="headerlink" title="函数也是变量？！"></a>函数也是变量？！</h3><p>或许你对C++中的<code>sort()</code>已有所耳闻，或许你已经知道，它的比较函数是做为参数传进去的。配合<code>@</code>操作符，Pascal可以做到相同的效果。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TMyCompareFunc=<span class="function"><span class="keyword">Function</span><span class="params">(a,b:MyType)</span>:</span>boolean;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">largerthan</span><span class="params">(a,b:MyType)</span>:</span>boolean;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">sort</span><span class="params">(<span class="keyword">var</span> a:<span class="keyword">array</span> <span class="keyword">of</span> MyType;l,r:longint;f:TMyCompareFunc)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//Use `f(a[x],a[y])` to compare</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">compare(arr,<span class="number">1</span>,max,@largerthan);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><p>既然是变量，就能互相赋值，但是请注意：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TNoArgFunc=<span class="function"><span class="keyword">Function</span><span class="params">()</span>:</span>integer;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">  F:TNoArgFunc;</span><br><span class="line">  N:integer;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyFunc</span><span class="params">()</span>:</span>integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  MyFunc:=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">F:=MyFunc; <span class="comment">//F()成为MyFunc()的别名</span></span><br><span class="line">N:=MyFunc; <span class="comment">//N被赋值为3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//if F=MyFunc then</span></span><br><span class="line"><span class="comment">//  writeln('You will never see this');</span></span><br><span class="line"><span class="comment">//这个判断将导致`类型不匹配`编译错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> F=@MyFunc <span class="keyword">then</span></span><br><span class="line">  writeln(<span class="string">'这是同一个函数'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> F()=MyFunc <span class="keyword">then</span></span><br><span class="line">  writeln(<span class="string">'这两个函数的返回值相同'</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h3 id="C风格的操作符"><a href="#C风格的操作符" class="headerlink" title="C风格的操作符"></a>C风格的操作符</h3><p>我就不多介绍了<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>...考试时先试试能不能用。使用有风险，偷懒须谨慎。</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>知道C中的<code>(int)a</code>或是<code>int(a)</code>么？不知道没关系，Pascal中的强制类型转换是这样写的<code>TypeIdentifier(Variable)</code>。下面给几个例子：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntPtr=^integer;</span><br><span class="line">IntVal:=<span class="number">97</span>;</span><br><span class="line">RealVal:=<span class="number">3.7</span>;</span><br><span class="line">longint(IntVal);<span class="comment">//长版的IntVal</span></span><br><span class="line">real(IntVal);<span class="comment">//实数版IntVal，效果和赋值一样</span></span><br><span class="line">pointer(IntVal);<span class="comment">//一个指向内存地址97的无类型指针</span></span><br><span class="line">IntPtr(IntVal);<span class="comment">//一个指向内存地址97的Integer指针</span></span><br><span class="line">longint(@IntVal);<span class="comment">//IntVal地址的Longint版。注意，它是一个数，所以可以用writeln()输出</span></span><br><span class="line">writeln(IntPtr(@RealVal)^);<span class="comment">//你可以猜猜这句话输出什么（写程序时请绝对不要这么做）</span></span><br></pre></td></tr></table></figure><h3 id="无类型变量与无类型指针"><a href="#无类型变量与无类型指针" class="headerlink" title="无类型变量与无类型指针"></a>无类型变量与无类型指针</h3><p>标题写着<code>无类型变量</code>，其实应该叫做<code>多类型变量</code>更准确。他的主要工作原理就是在内部进行类型转换，因此效率极其低下，占用空间还特别大，连官方手册都不建议用。类型名为<code>Variant</code>。<br>无类型指针就是上一节提到的<code>Pointer</code>了。任何指针都可以赋值给它，它也可以赋值给任何指针，例子如下：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">  p:pointer;</span><br><span class="line">  r:real;</span><br><span class="line">  i:^integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  r:=<span class="number">3.7</span>;</span><br><span class="line">  p:=@r;</span><br><span class="line">  i:=p;</span><br><span class="line">  writeln(i^);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><p>看出来了么？这段文字和上一段的最后一句话等效。</p><h3 id="这玩意儿是类？！"><a href="#这玩意儿是类？！" class="headerlink" title="这玩意儿是类？！"></a>这玩意儿是类？！</h3><p>这是我最近才看到的一种写法，从来没用过。有愿意尝试的请自行研究。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span></span><br><span class="line">  TGetSum=<span class="keyword">object</span></span><br><span class="line">  a,b:longint;</span><br><span class="line">  <span class="function"><span class="keyword">procedure</span> <span class="title">Init</span><span class="params">(x,y:longint)</span>;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">GetSum</span><span class="params">()</span>:</span>longint;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">TGetSum</span>.<span class="title">Init</span><span class="params">(x,y:longint)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  a:=x;b:=y;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TGetSum</span>.<span class="title">GetSum</span><span class="params">()</span>:</span>longint;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  GetSum:=a+b;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">  sum:TGetSum;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  sum.Init(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">  writeln(sum.GetSum())</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><p>关于Object Pascal,推荐一本书:<a href="http://code-sd.com/books/startprog/" target="_blank" rel="noopener">Start Programming Using Object Pascal</a></p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>Pascal是不少OIer最开始使用的一种语言，仅以此文献给众多正在使用和曾经使用过Pascal的OIer。<br><strong>做人要厚道，转载请注明出处！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做为一个搞信息学竞赛这么长时间的人，再加上估计很快就要转C++了，我觉得我有必要留下一些关于Pascal语言的资料，于是就有了这篇文章。我只负责解释用法，对基础概念不了解的请自行Google。所有这篇文章里的东西应该都能在Free Pascal自带的文档里找到，我写出来是为了众多不喜欢看英文的同学们，如果你愿意自己去看一下，一定会收益匪浅。&lt;/p&gt;
&lt;h3 id=&quot;不同进制的表示&quot;&gt;&lt;a href=&quot;#不同进制的表示&quot; class=&quot;headerlink&quot; title=&quot;不同进制的表示&quot;&gt;&lt;/a&gt;不同进制的表示&lt;/h3&gt;&lt;p&gt;平时我们写的常量都是十进制数，但我们有时需要写一个比如十六进制数怎么办呢？我们当然可以手动计算一下，但还有更优雅的方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;writeln($Ff,#32,&amp;amp;10,#32,%100);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你觉得它会输出什么呢？它输出&lt;code&gt;255 8 4&lt;/code&gt;!所以以&lt;code&gt;$&lt;/code&gt;开头的是16进制数，&lt;code&gt;&amp;amp;&lt;/code&gt;开头的是8进制数，&lt;code&gt;%&lt;/code&gt;开头的是二进制数。顺带一提的是，以&lt;code&gt;#&lt;/code&gt;开头的数会转变成对应ASCII码的字符，其实它可以和前面的三个符号共同使用，即&lt;code&gt;#$20&lt;/code&gt;和&lt;code&gt;#%100000&lt;/code&gt;都代表了空格。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Pascal" scheme="https://recursiveg.me/tags/Pascal/"/>
    
      <category term="ACM" scheme="https://recursiveg.me/tags/ACM/"/>
    
      <category term="编程" scheme="https://recursiveg.me/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>新浪微盘数据结构解析</title>
    <link href="https://recursiveg.me/2013/01/data-structure-of-vdisk/"/>
    <id>https://recursiveg.me/2013/01/data-structure-of-vdisk/</id>
    <published>2013-01-27T14:00:00.000Z</published>
    <updated>2020-01-12T19:01:23.194Z</updated>
    
    <content type="html"><![CDATA[<p><em>注意!这个是<a href="http://vdisk.weibo.com" target="_blank" rel="noopener">微盘</a>而不是<a href="http://www.vdisk.cn" target="_blank" rel="noopener">威盘</a></em><br>研究这个问题的起因是有一次我需要从微盘上批量下载一堆文件。做为一个会写程序的人，我怎么能亲自做如此ugly的工作呢？这种事情当然要交给电脑做了！为了做到自动获取文件连接，于是就不得不研究这个问题了。</p><a id="more"></a><h3 id="用户的登录"><a href="#用户的登录" class="headerlink" title="用户的登录"></a>用户的登录</h3><p>微盘内部使用一个叫做<code>gsid</code>的值来识别用户。具体获取方法如下：</p><ol><li>URL:<code>http://vdisk.weibo.com/wap_auth</code>。</li><li>POST参数 <code>username</code>:用户名</li><li>POST参数 <code>password</code>:用户密码</li><li>返回数据：JSON字符串。Example:<code>{ &quot;message&quot;: &quot;/?gsid=...&quot;}</code>。其中<code>...</code>的部分就是<code>gsid</code></li></ol><h3 id="文件信息的获取"><a href="#文件信息的获取" class="headerlink" title="文件信息的获取"></a>文件信息的获取</h3><p>得到<code>gsid</code>后，就可以用来下载文件了。当然，要先得到下载连接。</p><ol><li>URL：<code>http://vdisk.weibo.com/share/ajaxFileinfo</code></li><li>GET参数 <code>fid</code>：文件ID</li><li>Cookie参数 <code>gsid</code>:GSID</li><li>浏览器标识(UA):需要设置为移动设备</li><li>返回数据：JSON字符串。    Example:</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"id"</span>:<span class="string">"406458665"</span>,<span class="attr">"name"</span>:<span class="string">"\u5fae\u535a\u5c01\u9762\u80cc\u666f.zip"</span>,<span class="attr">"uid"</span>:<span class="string">"60999569"</span>,<span class="attr">"dir_id"</span>:<span class="string">"0"</span>,<span class="attr">"ctime"</span>:<span class="string">"1358820088"</span>,<span class="attr">"ltime"</span>:<span class="string">"1358820088"</span>,<span class="attr">"dtime"</span>:<span class="string">"0"</span>,<span class="attr">"size"</span>:<span class="string">"1662111"</span>,<span class="attr">"is_locked"</span>:<span class="string">"0"</span>,<span class="attr">"type"</span>:<span class="string">"application\/x-zip"</span>,<span class="attr">"md5"</span>:<span class="string">"9e8eec4a5d2d3ac5be41bb9f34dc3e40"</span>,<span class="attr">"sha1"</span>:<span class="string">"6e59853b198e3eae818d5b0756f47c34d4eae6df"</span>,<span class="attr">"w"</span>:<span class="string">"0"</span>,<span class="attr">"h"</span>:<span class="string">"0"</span>,<span class="attr">"hid"</span>:<span class="string">"0"</span>,<span class="attr">"status"</span>:<span class="string">"1"</span>,<span class="attr">"app_key"</span>:<span class="string">"139204333"</span>,<span class="attr">"source"</span>:<span class="string">"2"</span>,<span class="attr">"ip"</span>:<span class="string">"0"</span>,<span class="attr">"rev_id"</span>:<span class="string">"140316098"</span>,<span class="attr">"share_status"</span>:<span class="string">"0"</span>,<span class="attr">"share"</span>:<span class="number">-1</span>,<span class="attr">"s3_url"</span>:<span class="string">"http:\/\/file.data.vdisk.me\/61099569\/6e59853b198e3eae818d5b0756f47c34d4eae6df?ip=1358945643,10.75.7.27&amp;ssig=o9x4sQ9tz6&amp;Expires=1358944443&amp;KID=sae,l30zoo1wmz&amp;fn=%E5%BE%AE%E5%8D%9A%E5%B0%81%E9%9D%A2%E8%83%8C%E6%99%AF.zip"</span>,<span class="attr">"url"</span>:<span class="string">"http:\/\/vdisk.weibo.com\/s\/oex4F"</span>,<span class="attr">"byte"</span>:<span class="string">"1662111"</span>,<span class="attr">"length"</span>:<span class="string">"1662111"</span>&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>s3_url</code>就是下载地址了。顺带一提，从<code>http://vdisk.weibo.com/file/info?fid=...</code>也可以得到文件信息，需要Cookie:<code>gsid</code>，但似乎不是所有文件都能成功得到信息。</p><h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><p>从上一步得到了URL就可以下载了。</p><ol><li>URL：<code>s3_url</code></li><li>Cookie参数 <code>gsid</code>：GSID</li></ol><p>需要注意的是，这个URL可能会有很多<code>302 Redirection</code>，可能是出于负载平衡的原因吧。</p><h3 id="fid与fid64"><a href="#fid与fid64" class="headerlink" title="fid与fid64"></a>fid与fid64</h3><p>平时我们下载都是用<code>http://vdisk.weibo.com/s/aMVfa</code>这种形式的短链接，其中<code>aMVfa</code>就是fid64,说白了就是64进制表示的fid，其0～63对应如下：</p><pre><code>0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-</code></pre><p>因此，<code>aR_8-</code>解码后就是<code>181920319</code></p><h3 id="文件列表的获取"><a href="#文件列表的获取" class="headerlink" title="文件列表的获取"></a>文件列表的获取</h3><p>研究完上文所提到的东西后，应该就可以进行文件批量下载了。但做为一个上进的好青年，我们不会止步与此。为了能够方便地管理自己的文件夹，当然要做进一步研究。</p><ol><li>URL：<code>http://vdisk.weibo.com/dir/list</code></li><li>GET参数 <code>dir_id</code>：Directionary ID</li><li>Cookie参数 <code>gsid</code>：GSID</li><li>浏览器标识(UA):需要设置为移动设备</li><li>返回数据：JSON字符串。其中<code>dirinfo</code>中的<code>dir_num</code>和<code>file_num</code>分别储存了在这个文件夹下有多少个目录和多少个文件。<code>data</code>段是一个数组，每个元素都代表了一个文件或目录，其中保存了<code>fid</code>或是<code>dir_id</code>。通过是否有<code>type</code>段来判断具体是文件还是目录。</li></ol><p>用户根文件夹的<code>dir_id</code>是<code>0</code></p><h3 id="Cookie与浏览器标识-UA"><a href="#Cookie与浏览器标识-UA" class="headerlink" title="Cookie与浏览器标识(UA)"></a>Cookie与浏览器标识(UA)</h3><p>似乎所有的链接都可以通过在Cookie中加入<code>device=mobile</code>来跳过UA检查。(就是说不用设置UA了)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;注意!这个是&lt;a href=&quot;http://vdisk.weibo.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微盘&lt;/a&gt;而不是&lt;a href=&quot;http://www.vdisk.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;威盘&lt;/a&gt;&lt;/em&gt;&lt;br&gt;研究这个问题的起因是有一次我需要从微盘上批量下载一堆文件。做为一个会写程序的人，我怎么能亲自做如此ugly的工作呢？这种事情当然要交给电脑做了！为了做到自动获取文件连接，于是就不得不研究这个问题了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Black Technology" scheme="https://recursiveg.me/tags/Black-Technology/"/>
    
      <category term="网盘" scheme="https://recursiveg.me/tags/%E7%BD%91%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>公钥加密</title>
    <link href="https://recursiveg.me/2012/12/public-key-cryptography/"/>
    <id>https://recursiveg.me/2012/12/public-key-cryptography/</id>
    <published>2012-12-31T13:02:00.000Z</published>
    <updated>2020-01-12T18:58:51.351Z</updated>
    
    <content type="html"><![CDATA[<p>各种加密方法大体可以分成两类，一类是对称加密，另一类是非对称加密。</p><p>凯撒密码是对称加密中的一种，他的加密方法是把A变成B，把B变成C，于是解密的时候只要把字母替换回来就行了。也就是说，任何知道加密方法的人就可以解密。</p><p>RSA是一种非对称加密算法，他的特点是任何人都可以加密，但只有我可以解密。做个比喻，人人都可以把锁头扣上，但只有拥有钥匙的人可以开锁。这个分发出去的用于加密的东西叫做公钥，也被称作证书。而留在自己身边的“钥匙”就是私钥，是绝对不能被第二个人拿到的。</p><p>于是乎，你可以把公钥发给别人，别人把数据用你的公钥加密后传给你，你用私钥解密后阅读。在这个过程中，任何人截取到数据都是无效的，因为它没有你的私钥。</p><p>RSA还有一个特点，就是可以用私钥加密，用公钥解密。你会问，公钥人人都能拿到，相当于人人都能解密，那这样加密有什么意义呢？意义在于，它可以作为身份验证。用私钥加密的过程叫签名，而验证签名就是用对应的公钥解密。因为为只有用对应的私钥签名的文件才能用公钥解密，既然它可以用公钥解密，就一定是由对应私钥签署的，而私钥只有你有，于是这份文件就一定是你发布的。网络上的HTTPS就是依靠着个。一般来说，用私钥加密的都是MD5、SHA1 之类的，加密原文太耗系统资源。</p><p>对付这种非对称的加密方式，有一种叫做“中间人攻击”的攻击方法，它会使双方之间的通信完全暴露。我就偷懒不写了，大家自己找资料。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;各种加密方法大体可以分成两类，一类是对称加密，另一类是非对称加密。&lt;/p&gt;
&lt;p&gt;凯撒密码是对称加密中的一种，他的加密方法是把A变成B，把B变成C，于是解密的时候只要把字母替换回来就行了。也就是说，任何知道加密方法的人就可以解密。&lt;/p&gt;
&lt;p&gt;RSA是一种非对称加密算法，
      
    
    </summary>
    
    
      <category term="Mathematics" scheme="https://recursiveg.me/categories/Mathematics/"/>
    
    
      <category term="加密" scheme="https://recursiveg.me/tags/%E5%8A%A0%E5%AF%86/"/>
    
      <category term="RSA" scheme="https://recursiveg.me/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>Sync with iDevice on Linux</title>
    <link href="https://recursiveg.me/2012/12/sync-with-idevice-on-linux/"/>
    <id>https://recursiveg.me/2012/12/sync-with-idevice-on-linux/</id>
    <published>2012-12-31T13:01:00.000Z</published>
    <updated>2020-01-12T19:01:23.694Z</updated>
    
    <content type="html"><![CDATA[<p>It&#39;s a bit hard to connect an iDevice with Linux because Apple is not so open and we have to use iTunes to sync with our iDevice for a long time. Luckily we now have a set of tool so that we can control our device on linux. The most important two library are <a href="http://www.libimobiledevice.org/" target="_blank" rel="noopener">libimobiledevice</a>(libiphone) and libgpod.</p><p>libimobiledevice, like it&#39;s name, is a library who provides the interface to access the iDevice. It provides a higher level of access such as photo, bookmark, install/uninstall softwares and even sync music. And it doesn&#39;t need jailbreak.</p><p>What I want to mention is how musics synchronized with an iDevice. Under the iTunes folder (You may never seen that before. That&#39;s ordinary.), there&#39;s a file called iTunesDB. That&#39;s the file which libgpod really works with. This file contains the name of songs, singers&#39; names, your play lists and so on. Unfortunately, because Apple don&#39;t want it be modified by any programs except iTunes, they add some hash info into the file. If iPod found the hash is incorrect, it refused to display the songs. There was once a project called iPodHash, but it seems to be die due to a DMCA notice. Apple engineers have changed the hash algorithm for several times and the latest version haven&#39;t been reverse-engineering, as a result, now we can only sync with a old version of iOS.</p><p>If your iDevice is jailbreaked, you can change a key called DBVersion(Sorry, I forgot where it is.). It tells iPod which version of hash algorithm it should use so we could use a known hash on new iOS. This process depends on libimobiledevice too. It only support to sync with iOS 4 or older. That means it&#39;s useless even if you changed DBVersion on your iOS5 device. By the way, you may will not find a iTunesDB file but a iTunesCDB instead. It&#39;s a compressed version of iTunesDB using zlib.</p><p>I feel so sad that such a project is closed and now I can only sync with my iPod on Windows.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;It&amp;#39;s a bit hard to connect an iDevice with Linux because Apple is not so open and we have to use iTunes to sync with our iDevice for 
      
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Written In English" scheme="https://recursiveg.me/tags/Written-In-English/"/>
    
      <category term="iDevice" scheme="https://recursiveg.me/tags/iDevice/"/>
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>How to solve the &quot;Connection Reset&quot; problem</title>
    <link href="https://recursiveg.me/2012/12/how-to-solve-the-connection-reset-problem/"/>
    <id>https://recursiveg.me/2012/12/how-to-solve-the-connection-reset-problem/</id>
    <published>2012-12-31T12:50:00.000Z</published>
    <updated>2020-01-12T19:01:24.174Z</updated>
    
    <content type="html"><![CDATA[<p>考虑到安全原因，这篇文章用英语写成。如果你没有足够的勇气读完它，请自觉退出。</p><p>This article is written mainly for those people in China. Be sure you are enough familiar with what you are reading and what you try to do.</p><p>================================================================</p><p>As we all known, in China mainland, we cannot visit sites like YouTube Facebook Twitter. And the Google sites are out of service frequently. It&#39;s because the Chinese government used some technical methods to prevent us from visiting them. The government has setup a system to do this. It&#39;s called the <a href="https://en.wikipedia.org/wiki/Great_Firewall" target="_blank" rel="noopener">Great Firewall of China</a> (GFW). This system keeps look on the gateway export. And if it finds something unusual. It will stop the connection.</p><p>The system usually inject a RESET into the TCP connection. To prevent this, we can use HTTPS(The S means Secure) instead of HTTP. So the system can not inject the RESET any more. It&#39;s easy to perform. You just need to replace the &quot;http://&quot; part of a URL with &quot;https://&quot;. And the URL will look like this &quot;<a href="https://www.facebook.com&quot;" target="_blank" rel="noopener">https://www.facebook.com&quot;</a>. Most of the sites support a HTTPS connection.</p><p>Unfortunately, this will not always works. Because the system also used another method called &quot;DNS Redirection&quot;. As we all known, the computers on the Internet are identified by IP address. But human can&#39;t remember them easily. So we use some meaningful phases called &quot;Domain&quot;. Some computers on the Internet provide the kind of service to translate the domains to IP address which is the only form computers can recognize. They are called the &quot;DNS Server&quot;. DNS Redirection is that the DNS servers won&#39;t return the correct IP address (usually were instructed to do so) so that we can&#39;t visit the particular sites.</p><p>Luckily, we can assign an IP to a domain manually. That&#39;s the function of a file called <a href="https://en.wikipedia.org/wiki/Hosts_(file)" target="_blank" rel="noopener">hosts</a>. There&#39;s a project called <a href="https://code.google.com/p/smarthosts/" target="_blank" rel="noopener">smarthosts</a> on Google Code. It provided a set of IP address you may use. Paste them to your local hosts file and enjoy the Internet.</p><p>I will write more about the Internet censorship and how to avoid it. Check back later.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;考虑到安全原因，这篇文章用英语写成。如果你没有足够的勇气读完它，请自觉退出。&lt;/p&gt;
&lt;p&gt;This article is written mainly for those people in China. Be sure you are enough familiar w
      
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Written In English" scheme="https://recursiveg.me/tags/Written-In-English/"/>
    
      <category term="Black Technology" scheme="https://recursiveg.me/tags/Black-Technology/"/>
    
      <category term="GFW" scheme="https://recursiveg.me/tags/GFW/"/>
    
  </entry>
  
  <entry>
    <title>Hello, World!</title>
    <link href="https://recursiveg.me/2012/12/helloworld/"/>
    <id>https://recursiveg.me/2012/12/helloworld/</id>
    <published>2012-12-22T12:32:00.000Z</published>
    <updated>2020-01-12T19:01:24.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A-standard-quot-Hello-World-quot-page"><a href="#A-standard-quot-Hello-World-quot-page" class="headerlink" title="A standard &quot;Hello World!&quot; page"></a>A standard &quot;Hello World!&quot; page</h2><h2 id="你好世界。"><a href="#你好世界。" class="headerlink" title="你好世界。"></a>你好世界。</h2><figure class="highlight delphi"><figcaption><span>hello_world.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> Hello_World;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  writeln(<span class="string">'Hello World!'</span>);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight c"><figcaption><span>hello_world.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>hello_world.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello World!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>hello_world.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"Hello World!"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>hello_world.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello_world</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;A-standard-quot-Hello-World-quot-page&quot;&gt;&lt;a href=&quot;#A-standard-quot-Hello-World-quot-page&quot; class=&quot;headerlink&quot; title=&quot;A standard &amp;quot;Hello World!&amp;quot; page&quot;&gt;&lt;/a&gt;A standard &amp;quot;Hello World!&amp;quot; page&lt;/h2&gt;&lt;h2 id=&quot;你好世界。&quot;&gt;&lt;a href=&quot;#你好世界。&quot; class=&quot;headerlink&quot; title=&quot;你好世界。&quot;&gt;&lt;/a&gt;你好世界。&lt;/h2&gt;&lt;figure class=&quot;highlight delphi&quot;&gt;&lt;figcaption&gt;&lt;span&gt;hello_world.pas&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;program&lt;/span&gt; Hello_World;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  writeln(&lt;span class=&quot;string&quot;&gt;&#39;Hello World!&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Site Management" scheme="https://recursiveg.me/tags/Site-Management/"/>
    
      <category term="Hello World!" scheme="https://recursiveg.me/tags/Hello-World/"/>
    
  </entry>
  
</feed>
