<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RECURSIVE LAND</title>
  <subtitle>A Blog of Recursive G</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://recursiveg.me/"/>
  <updated>2016-01-14T03:23:30.452Z</updated>
  <id>http://recursiveg.me/</id>
  
  <author>
    <name>RecursiveG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 环境 TCP Socket 与 Epoll 使用备忘</title>
    <link href="http://recursiveg.me/2015/12/linux-socket-epoll-demo/"/>
    <id>http://recursiveg.me/2015/12/linux-socket-epoll-demo/</id>
    <published>2015-12-25T11:15:13.000Z</published>
    <updated>2016-01-14T03:23:30.452Z</updated>
    
    <content type="html">&lt;p&gt;流水帐式地记录了 Linux 下 TCP Socket 通信的方法和基本的 Epoll 使用方法。&lt;br&gt;没有错误处理。&lt;/p&gt;&lt;h2 id=&quot;地址解析&quot;&gt;&lt;a href=&quot;# 地址解析&quot; class=&quot;headerlink&quot; title=&quot;地址解析&quot;&gt;&lt;/a&gt;地址解析 &lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; addrinfo *listen_addr; &lt;span class=&quot;comment&quot;&gt;// 存放解析结果。参见 `man getaddrinfo`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getaddrinfo(&lt;span class=&quot;string&quot;&gt;&quot;0.0.0.0&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;55553&quot;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &amp;amp;listen_addr); &lt;span class=&quot;comment&quot;&gt;// getaddrinfo([主机名],[端口],[hint],[结果])。成功返回 `0`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;freeaddrinfo(listen_addr); &lt;span class=&quot;comment&quot;&gt;// 释放资源，返回 void&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&quot;监听&quot;&gt;&lt;a href=&quot;# 监听&quot; class=&quot;headerlink&quot; title=&quot;监听&quot;&gt;&lt;/a&gt; 监听 &lt;/h2&gt;&lt;p&gt; 这种方式只能同时处理一个连接 &lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fd = socket(AF_INET, SOCK_STREAM, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// int socket(int domain, int type, int protocol); 参见 `man 3 socket` 创建文件描述符， 出错返回 -1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bind(fd, listen_addr-&amp;gt;ai_addr, listen_addr-&amp;gt;ai_addrlen);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// int bind(int socket, const struct sockaddr *address,socklen_t address_len);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 绑定地址，出错返回 -1，参见 `man 3 bind`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;listen(fd, SOMAXCONN);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// int listen(int fd, int backlog(最大队列长度))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 开始监听，出错返回 -1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; new_fd = accept(fd, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// accept([fd], [监听地址], [监听地址结构体长度]) 第 2，3 个参数同 bind()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 接受连接请求，若无请求则阻塞(也有可能是 EAGAIN, 取决于你需要什么)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 返回用于和对端通信的新的文件描述符, 出错返回 -1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ... handle(new_fd);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    close(new_fd); &lt;span class=&quot;comment&quot;&gt;// 关闭文件描述符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;h2 id=&quot;发起连接&quot;&gt;&lt;a href=&quot;# 发起连接&quot; class=&quot;headerlink&quot; title=&quot;发起连接&quot;&gt;&lt;/a&gt; 发起连接 &lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; addrinfo *server_addr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getaddrinfo(&lt;span class=&quot;string&quot;&gt;&quot;127.0.0.1&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;55553&quot;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &amp;amp;server_addr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; server_socket = socket(AF_INET, SOCK_STREAM, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;connect(server_socket, server_addr-&amp;gt;ai_addr, server_addr-&amp;gt;ai_addrlen)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 基本同 bind() 参见 man 3 connect&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 成功后可用 server_socket 与服务器通信&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ... send(...)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ... recv(...)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;close(server_socket);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;freeaddrinfo(server_addr);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&quot;传送数据&quot;&gt;&lt;a href=&quot;# 传送数据&quot; class=&quot;headerlink&quot; title=&quot;传送数据&quot;&gt;&lt;/a&gt; 传送数据 &lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *payload = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;send(new_fd, payload, &lt;span class=&quot;built_in&quot;&gt;strlen&lt;/span&gt;(payload), &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// send([fd], [buffer], [需发送消息长度], [flag]) 返回实际发送的消息长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; buf[&lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;recv(new_fd, buf, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(buf), &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// send([fd], [buffer], [最大接收消息长度], [flag]) 返回实际接收的消息长度。阻塞模式下，若无消息则阻塞&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&quot;多进程请求处理&quot;&gt;&lt;a href=&quot;# 多进程请求处理&quot; class=&quot;headerlink&quot; title=&quot;多进程请求处理&quot;&gt;&lt;/a&gt; 多进程请求处理 &lt;/h2&gt;&lt;p&gt; 对于每一个请求 fork()一个新的进程进行处理。&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; new_fd = accept(fd, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (fork() == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// fork()返回 0 说明是子进程 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ... handle(new_fd);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        close(new_fd);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 id=&quot;Epoll&quot;&gt;&lt;a href=&quot;#Epoll&quot; class=&quot;headerlink&quot; title=&quot;Epoll&quot;&gt;&lt;/a&gt;Epoll&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; epollfd = epoll_create(&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 创建 epoll 文件描述符，出错返回 -1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// int epoll_create(int size) 从 Linux2.6.8 开始，size 值被忽略，不过为保持兼容需要设定为一个正整数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; epoll_event ev; &lt;span class=&quot;comment&quot;&gt;// 记录套接字相关信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ev.events = EPOLLIN; &lt;span class=&quot;comment&quot;&gt;// 监视有数据可读事件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ev.data.fd = fd; &lt;span class=&quot;comment&quot;&gt;// 文件描述符数据，其实这里可以放任何数据。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;amp;ev);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// int epoll_ctl([Epoll FD], [Operation], [fd], [epoll_event]);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 加入监听列表，当 fd 上有对应事件产生时，epoll_wait 会将 epoll_event 填充到 events_in 数组里&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 出错返回 -1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; epoll_event events_in[&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; event_count = epoll_wait(epollfd, events_in, &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 等待事件，epoll_wait 会将事件填充至 events_in 内&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// int epoll_wait([epoll fd], struct epoll_event *events, [最大事件数量], int timeout);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 返回 获得的事件数量，若超时且没有任何事件返回 0，出错返回 -1。timeout 设置为 -1 表示无限等待。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;event_count; i++) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 遍历所有事件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (events_in[i].data.fd == fd) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 新连接请求&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; new_fd = accept(fd, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ev.events = EPOLLIN; &lt;span class=&quot;comment&quot;&gt;// 参见 man 7 epoll 如果要使用 Edge Trigger 还需将 new_fd 设为非阻塞&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ev.data.fd = new_fd;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            epoll_ctl(epollfd, EPOLL_CTL_ADD, new_fd, &amp;amp;ev); &lt;span class=&quot;comment&quot;&gt;// 将新连接加入监视列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; new_fd = events_in[i].data.fd;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// ... handle(new_fd);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            epoll_ctl(epollfd, EPOLL_CTL_DEL, new_fd, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 不再监听 fd，最后一个参数被忽略&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            close(new_fd);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&quot;拓展阅读&quot;&gt;&lt;a href=&quot;# 拓展阅读&quot; class=&quot;headerlink&quot; title=&quot;拓展阅读&quot;&gt;&lt;/a&gt; 拓展阅读&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://www.linux-mag.com/id/308/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Blocking 与 Non-Blocking I/O&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://www.ccvita.com/515.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Epoll 的 Edge-Trigger 与 Level-Trigger&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</content>
    
    <summary type="html">
    
      流水帐式地记录了 Linux 下 TCP Socket 通信的方法和基本的 Epoll 使用方法。
    
    </summary>
    
      <category term="Programming" scheme="http://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Linux" scheme="http://recursiveg.me/tags/Linux/"/>
    
      <category term="教程" scheme="http://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Epoll" scheme="http://recursiveg.me/tags/Epoll/"/>
    
      <category term="Socket" scheme="http://recursiveg.me/tags/Socket/"/>
    
      <category term="TCP" scheme="http://recursiveg.me/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下建立 GRE 隧道并获取 IPv6 地址</title>
    <link href="http://recursiveg.me/2015/09/get-ipv6-via-gre-tunnel/"/>
    <id>http://recursiveg.me/2015/09/get-ipv6-via-gre-tunnel/</id>
    <published>2015-09-19T06:35:10.000Z</published>
    <updated>2016-01-14T02:33:05.839Z</updated>
    
    <content type="html">&lt;p&gt;虽然 HE 有提供免费的 Tunnelbroker，不过那速度实在不怎么样。于是考虑在有 IPv6 地址托管主机上建立一个 GRE Tunnel。&lt;br&gt;GRE Tunnel 需要有内核模块 &lt;code&gt;ip_gre&lt;/code&gt; 支持。远程主机有一段 /64 的 IPv6，我将其中的一段 /80 分配给自己的机器。&lt;br&gt;使用 iproute2 工具。当然，你自己的机器需要有一个公网 IPv4 地址。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;服务器的公网 IPv4 是 &lt;code&gt;$server_ipv4&lt;/code&gt;&lt;/li&gt;&lt;li&gt; 自己电脑（或者路由器）的公网 IPv4 是 &lt;code&gt;$client_ipv4&lt;/code&gt;。&lt;/li&gt;&lt;li&gt; 服务器的 IPv6 段是 &lt;code&gt;a:b:c:d::/64&lt;/code&gt;&lt;/li&gt;&lt;li&gt; 要分配下去的 IPv6 段是 &lt;code&gt;a:b:c:d:e::/80&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;服务器配置&quot;&gt;&lt;a href=&quot;# 服务器配置&quot; class=&quot;headerlink&quot; title=&quot;服务器配置&quot;&gt;&lt;/a&gt; 服务器配置 &lt;/h2&gt;&lt;p&gt; 脚本如下，需要 root，建议用 &lt;code&gt;sudo -i&lt;/code&gt;：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ip tunnel add gre-tunnel mode gre remote &lt;span class=&quot;variable&quot;&gt;$client_ipv4&lt;/span&gt; ttl 64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ip link &lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt; gre-tunnel up&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ip addr add a:b:c:d:e::1/80 dev gre-tunnel&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt; 第一行建立隧道，&lt;code&gt;gre-tunnel&lt;/code&gt;是隧道名称，可以按自己喜欢的来，记得其他的也要一起改 &lt;/li&gt;&lt;li&gt; 第二行激活隧道 &lt;/li&gt;&lt;li&gt; 第三行分配 IP 地址 &lt;/li&gt;&lt;/ul&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;h2 id=&quot;本地配置&quot;&gt;&lt;a href=&quot;# 本地配置&quot; class=&quot;headerlink&quot; title=&quot;本地配置&quot;&gt;&lt;/a&gt; 本地配置 &lt;/h2&gt;&lt;p&gt; 脚本如下，和服务端配置几乎一样，同样需要 root：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ip tunnel add gre-tunnel mode gre remote &lt;span class=&quot;variable&quot;&gt;$server_ipv4&lt;/span&gt; ttl 64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ip link &lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt; gre-tunnel up&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ip addr add a:b:c:d:e::2/80 dev gre-tunnel&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ip -6 route add default dev gre-tunnel&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一行建立隧道，隧道名称不必和服务器的一样 &lt;/li&gt;&lt;li&gt; 第二行激活隧道 &lt;/li&gt;&lt;li&gt; 第三行分配 IP 地址，注意不要和服务器的冲突，这个 IP 也是将要暴露在网络上的 IP&lt;/li&gt;&lt;li&gt;第四行设定路由，让 IPv6 流量都走隧道 &lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;访问网络&quot;&gt;&lt;a href=&quot;# 访问网络&quot; class=&quot;headerlink&quot; title=&quot;访问网络&quot;&gt;&lt;/a&gt; 访问网络 &lt;/h2&gt;&lt;p&gt; 现在，两台机器应该可以互 ping 了。有的比较奇葩的情况可能需要手动 &lt;code&gt;ip link set gre0 up&lt;/code&gt; 一下，gre0 似乎是内核模块自动加入的玩意儿，具体怎么回事我也不清楚–_–|&lt;br&gt;但是现在还不能访问外网，还需要在服务器执行以下命令：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sysctl net.ipv6.conf.all.forwarding=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sysctl net.ipv6.conf.all.proxy_ndp=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ip -6 neigh add proxy a:b:c:d:e::2 dev eth0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第一行开启 forward&lt;br&gt;二三行和 IPv6 的 NDP(邻居发现)有关，又是个没搞明白的东西真是残念……&lt;br&gt;eth0 是服务器实际连接网络的接口。&lt;/p&gt;&lt;h2 id=&quot;删除 -amp- 修改&quot;&gt;&lt;a href=&quot;# 删除 -amp- 修改&quot; class=&quot;headerlink&quot; title=&quot;删除 &amp;amp; 修改&quot;&gt;&lt;/a&gt;删除 &amp;amp; 修改 &lt;/h2&gt;&lt;p&gt; 要删除 Tunnel，在两端均执行:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ip link set gre-tunnel down
ip tunnel del gre-tunnel
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果客户端 IP 变化:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ip tunnel change gre-tunnel remote $new_client_ipv4
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;注意事项&quot;&gt;&lt;a href=&quot;# 注意事项&quot; class=&quot;headerlink&quot; title=&quot;注意事项&quot;&gt;&lt;/a&gt;注意事项 &lt;/h2&gt;&lt;p&gt; 虽然叫做“隧道”，但是内容依然是 &lt;em&gt; 明文 &lt;/em&gt;，对保密要求高的同学们要注意了。&lt;br&gt; 另外直接用命令建立的隧道在重启后会没有，所以可以考虑用 networkd 之类的东西来管理。&lt;br&gt;Linux 在访问有 IPv6 地址的域名时会优先使用 IPv6，所以要当心服务器流量爆炸。当然配置成 IPv4 优先也是可以的。&lt;br&gt;如果你的本地 IPv4 经常变动的话，你可能需要些脚本之类的东西自动更新服务器的 Remote IP。&lt;br&gt;对于每一个新的 IP(新的设备)，都需要在服务端执行&lt;code&gt;ip -6 neigh add&lt;/code&gt;，有知道怎么解决这个问题的请务必留言…&lt;/p&gt;</content>
    
    <summary type="html">
    
      如何在Linux服务器上建立隧道并获得IPv6地址
    
    </summary>
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="Linux" scheme="http://recursiveg.me/tags/Linux/"/>
    
      <category term="GRE Tunnel" scheme="http://recursiveg.me/tags/GRE-Tunnel/"/>
    
      <category term="IPv6" scheme="http://recursiveg.me/tags/IPv6/"/>
    
  </entry>
  
  <entry>
    <title>IDEA 下建立 Forge 开发环境的正确姿势</title>
    <link href="http://recursiveg.me/2014/12/setup-forge-workspace-with-idea/"/>
    <id>http://recursiveg.me/2014/12/setup-forge-workspace-with-idea/</id>
    <published>2014-12-11T06:17:48.000Z</published>
    <updated>2016-01-14T02:33:05.839Z</updated>
    
    <content type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;# 前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言 &lt;/h1&gt;&lt;p&gt; 见过不少教程都是基于 Eclipse 的，而基于 IDEA 的文章少得可怜，遂决定写此文。&lt;br&gt;本文通篇基于 Linux/IntellijIDEA 进行讲解，Windows/MAC/Eclipse 用户请自行依葫芦画瓢。&lt;/p&gt;&lt;h1 id=&quot;设置 Forge 工作区&quot;&gt;&lt;a href=&quot;# 设置 Forge 工作区&quot; class=&quot;headerlink&quot; title=&quot;设置 Forge 工作区&quot;&gt;&lt;/a&gt;设置 Forge 工作区 &lt;/h1&gt;&lt;p&gt; 当然，你得首先去 &lt;a href=&quot;http://files.minecraftforge.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MinecraftForge&lt;/a&gt; 下载一份源代码。我这里用的是最新的 &lt;code&gt;forge-1.7.10-10.13.2.1258-src.zip&lt;/code&gt;&lt;br&gt; 接着，找个地方建立一个文件夹，这将是你的工程目录，我的叫做 &lt;code&gt;Forge1.7.10-1258&lt;/code&gt;。然后再在里面建立一个目录，比方说就叫&lt;code&gt;forge-1.7.10-10.13.2.1258-src&lt;/code&gt;，把你的 Forge 源码解压进去。&lt;br&gt; 现在，你的文件夹层次应该看起来是这样的：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Forge1.7.10-1258
└── forge-1.7.10-10.13.2.1258-src
     ├── build.gradle
     ├── CREDITS-fml.txt
     ├── eclipse
     ├── forge-1.7.10-10.13.2.1258-changelog.txt
     ├── gradle
     ├── gradlew
     ├── gradlew.bat
     ├── LICENSE-fml.txt
     ├── MinecraftForge-Credits.txt
     ├── MinecraftForge-License.txt
     ├── README.txt
     └── src
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你可以先按自己喜好改动一下 &lt;code&gt;build.gradle&lt;/code&gt;。比如，我喜欢手动指定一下 mappings 的版本：&lt;/p&gt;&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;minecraft &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    version = &lt;span class=&quot;string&quot;&gt;&quot;1.7.10-10.13.2.1258&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    runDir = &lt;span class=&quot;string&quot;&gt;&quot;eclipse&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mappings = &lt;span class=&quot;string&quot;&gt;&quot;stable_12&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt; 接着，cd 到 forge-1.7.10-10.13.2.1258-src 目录下，执行如下两条命令：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;gradle -i setupDecompWorkspace
gradle -i ideaModule
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后请耐心等待指令完成，可以去喝杯牛奶睡个觉什么的。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h1 id=&quot;导入到 IDEA&quot;&gt;&lt;a href=&quot;# 导入到 IDEA&quot; class=&quot;headerlink&quot; title=&quot;导入到 IDEA&quot;&gt;&lt;/a&gt;导入到 IDEA&lt;/h1&gt;&lt;p&gt;等以上操作完成后，就可以打开 IDEA，选“Create New Project”，注意要建立一个 &lt;strong&gt; 空工程 &lt;/strong&gt;（Empty Project）&lt;br&gt;&lt;img src=&quot;http://0f4529-files.oss-cn-hangzhou.aliyuncs.com/blog/setup-forge-idea/1.png&quot; alt=&quot;Create New Project&quot;&gt;&lt;br&gt;“Project Name”自然可以随意填写，”Project Location”则是之前创建的目录，下方的”Project Format”推荐选”Directory Based”&lt;br&gt; 点”Finish”之后应该会自动打开”Project Structure”窗口，如果没有的话可以按 Ctrl+Alt+Shift+S 或是从菜单栏”File –&amp;gt; Project Structure”&lt;br&gt;打开窗口之后我们首先要选择 SDK 版本：先点左边的”Project”，然后在右边”Project SDK”里选一个，我是选了 Java8，你当然可以选择任何版本（不要低于 Java6）&lt;br&gt;&lt;img src=&quot;http://0f4529-files.oss-cn-hangzhou.aliyuncs.com/blog/setup-forge-idea/2.png&quot; alt=&quot;Select Project SDK&quot;&gt;&lt;br&gt;接着点左边的”Modules”, 再点那个绿色的“+”号，接着选”Import Module”&lt;br&gt;&lt;img src=&quot;http://0f4529-files.oss-cn-hangzhou.aliyuncs.com/blog/setup-forge-idea/3.png&quot; alt=&quot;Location of &amp;quot;Import Module&amp;quot;&quot;&gt;&lt;br&gt;然后选 forge-1.7.10-10.13.2.1258-src 目录下的 &lt;code&gt;forge-1.7.10-10.13.2.1258-src.iml&lt;/code&gt; 文件就好。&lt;br&gt;Import 完了之后检查下有没有报错，如果没问题就可以点右下角 OK。&lt;/p&gt;&lt;p&gt;重新 cd 到 forge-1.7.10-10.13.2.1258-src 目录下，执行如下三条命令让 gradle 自动建立运行配置。&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ln &lt;span class=&quot;_&quot;&gt;-s&lt;/span&gt; ../.idea .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gradle -i genIntellijRun&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rm .idea&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;回到 IDEA，然后有必要的话重新加载一下 Project。继续选菜单栏”Run –&amp;gt; Edit Configurations”, 点左侧的”Minecraft Client”，修改”Working Directory”到 &lt;code&gt;forge-1.7.10-10.13.2.1258-src/eclipse&lt;/code&gt;。&lt;br&gt;&lt;img src=&quot;http://0f4529-files.oss-cn-hangzhou.aliyuncs.com/blog/setup-forge-idea/4.png&quot; alt=&quot;Edit Configuration&quot;&gt;&lt;br&gt; 你也可以像我一样指定一个 username。接着对”Minecraft Server”也如法炮制。然后右下角”OK”退出。&lt;/p&gt;&lt;p&gt;现在 Forge 应该就可以运行了，在 IDEA 的主界面右上角有这么一片区域，选”Minecraft Client”然后点右侧那个绿色的三角箭头即可 &lt;br&gt;&lt;img src=&quot;http://0f4529-files.oss-cn-hangzhou.aliyuncs.com/blog/setup-forge-idea/5.png&quot; alt=&quot;Execution Control Bar&quot;&gt;&lt;/p&gt;&lt;h1 id=&quot;一个 Mod！&quot;&gt;&lt;a href=&quot;# 一个 Mod！&quot; class=&quot;headerlink&quot; title=&quot;一个 Mod！&quot;&gt;&lt;/a&gt; 一个 Mod！&lt;/h1&gt;&lt;p&gt;如果之前的步骤都没有问题，你就可以继续了 &lt;br&gt; 为了更好地演示运行配置以及发布流程，我决定写一个 Mod，添加一种矿石：“Xp Ore”, 顾名思义，挖掉后能得到大量经验。&lt;/p&gt;&lt;p&gt;我们需要新建一个 Module 来写我们的代码：菜单栏”File –&amp;gt; New Module”&lt;br&gt;我就叫 XpOre 好了，然后继续打开”Project Structure”，将 &lt;code&gt;forge-1.7.10-10.13.2.1258-src&lt;/code&gt; 添加成为它的依赖。&lt;br&gt;&lt;img src=&quot;http://0f4529-files.oss-cn-hangzhou.aliyuncs.com/blog/setup-forge-idea/6.png&quot; alt=&quot;Add to Dependencies&quot;&gt;&lt;br&gt;那个菜单同样是点右边的绿色加号出来，点”Module Dependency”后在弹出来的窗口里选”forge-1.7.10-10.13.2.1258-src”然后”OK”即可。&lt;/p&gt;&lt;p&gt;之后就可以写 Mod 了！至于具体 Mod 怎么写我就不在这里提了，请各位参考其他文章。&lt;br&gt;这是我的代码和目录层次结构，请自行调整，我就不把每一步的细节都写出来了。&lt;br&gt;请记得把 &lt;code&gt;java&lt;/code&gt; 和&lt;code&gt;resources&lt;/code&gt;两个目录设置成代码根目录和资源根目录，具体方法是在文件夹上右键然后”Mark Directory As”&lt;br&gt;&lt;img src=&quot;http://0f4529-files.oss-cn-hangzhou.aliyuncs.com/blog/setup-forge-idea/7.png&quot; alt=&quot;The Module Tree&quot;&gt;&lt;br&gt;（xp_ore.png 是矿石的材质，其实就是拿金矿石的材质把几个像素涂成绿色让它看起来比较像附魔瓶的颜色）&lt;br&gt;为了防止图挂，我再拿文本形式列一下目录&lt;/p&gt;&lt;pre&gt;&lt;code&gt;XpOre
├── src
│   └── main
│       ├── java (Sources Root)
│       │   └── org
│       │       └── devinprogress
│       │           └── xpore
│       │               └── XpOre.java
│       └── resources (Resources Root)
│           ├── assets
│           │   └── xpore
│           │       ├── lang
│           │       │   └── en_US.lang
│           │       └── textures
│           │           └── blocks
│           │               └── xp_ore.png
│           └── mcmod.info
└── XpOre.iml
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要想让这个 Mod 在 IDEA 里运行起来，有两种方式。第一种比较简单，直接菜单栏”Run –&amp;gt; Edit Configurations –&amp;gt; ‘Minecraft Client’ –&amp;gt; Use classpath of mod …”下拉列表里选”XpOre”，保存退出运行即可。这种方式比较适合只开发一个 Mod 的情况。&lt;br&gt;当有 N 个 Module 互相依赖的时候，我推荐创建另一个 Module，比方说，叫”Run”。然后令其依赖 &lt;code&gt;forge-1.7.10-10.13.2.1258-src&lt;/code&gt; 和你需要加载的其他 Module，然后”Use classpath of mod”选择”Run”即可。&lt;/p&gt;&lt;h1 id=&quot;发布&quot;&gt;&lt;a href=&quot;# 发布&quot; class=&quot;headerlink&quot; title=&quot;发布&quot;&gt;&lt;/a&gt;发布 &lt;/h1&gt;&lt;p&gt; 发布其实相当方便，把 forge-1.7.10-10.13.2.1258-src 文件夹里的 &lt;code&gt;build.gradle&lt;/code&gt; 复制到 &lt;code&gt;XpOre&lt;/code&gt; 文件夹下面 &lt;br&gt; 按自己喜好修改其中的 &lt;code&gt;version&lt;/code&gt;,&lt;code&gt;group&lt;/code&gt; 和&lt;code&gt;archivesBaseName&lt;/code&gt;即可。比方说我的是：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;version = &amp;quot;v0.1&amp;quot;
group= &amp;quot;org.devinprogress.xpore&amp;quot;
archivesBaseName = &amp;quot;XpOre-1.7.10&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在 XpOre 文件夹下 &lt;code&gt;gradle build&lt;/code&gt; 即可。运行完成后，就能在 &lt;code&gt;XpOre/build/libs/&lt;/code&gt; 文件夹下找到编译好的 jar 了。&lt;/p&gt;&lt;p&gt;最后来一张 Mod 的效果图&lt;br&gt;&lt;img src=&quot;http://0f4529-files.oss-cn-hangzhou.aliyuncs.com/blog/setup-forge-idea/8.png&quot; alt=&quot;XpOre Mod&quot;&gt;&lt;/p&gt;</content>
    
    <summary type="html">
    
      Minecraft mod developing in seperated folders under linux with IDEA.
    
    </summary>
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="教程" scheme="http://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Minecraft" scheme="http://recursiveg.me/tags/Minecraft/"/>
    
      <category term="Java" scheme="http://recursiveg.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Minecraft Coremod 开发杂事记</title>
    <link href="http://recursiveg.me/2014/11/minecraft-modding-with-asm/"/>
    <id>http://recursiveg.me/2014/11/minecraft-modding-with-asm/</id>
    <published>2014-11-04T13:48:53.000Z</published>
    <updated>2016-01-14T02:33:05.839Z</updated>
    
    <content type="html">&lt;p&gt;表示最近时间荒废得厉害，主要都是耗在了 &lt;a href=&quot;http://www.minecraft.net&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Minecraft&lt;/a&gt; 这款游戏上。&lt;br&gt;Minecraft 的一大魅力在于其几乎无穷的 MODs，于是我也小试了一下 Mod 开发，顺便学习一下 Java。&lt;del&gt;于是掉入了万劫不复的深坑 &lt;/del&gt;&lt;br&gt; 当然，我要做点和加个方块、改个合成表之类的不一样的事。&lt;br&gt;（教程中不少内容都参考了 szszss 的 &lt;a href=&quot;http://www.hakugyokurou.net/wordpress/?page_id=126&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; 博客 &lt;/a&gt;，在此表示深深的感谢）&lt;/p&gt;&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;# 基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt; 基础知识 &lt;/h1&gt;&lt;p&gt; 关于这篇文章，不适合特别特别新的新人，我假设各位读者都有一些基础的编程经验。如果你是入门级别的，在 MCBBS 论坛的 &lt;a href=&quot;http://www.mcbbs.net/thread-54579-1-1.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; 编程开发板块 &lt;/a&gt; 有不少不错的入门教程。&lt;br&gt;我假设各位读者都具备以下能力:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;会安装软件 &lt;/li&gt;&lt;li&gt; 了解基本的程序流程控制，比如判断、循环等 &lt;/li&gt;&lt;li&gt; 了解基本的 OOP 概念，比如类，继承等 （其实这条不是那么重要，Java 看多了就自然会了 &lt;del&gt;一个原 C 程序员如是说 &lt;/del&gt;）&lt;/li&gt;&lt;li&gt; 了解命令行、终端的基本使用方法 &lt;/li&gt;&lt;li&gt; 有方法正常访问国际互联网，如 Facebook 等 &lt;/li&gt;&lt;li&gt; 了解基本英语单词（这条似乎也不是那么重要，主要是希望大家能够在遇到问题时不要怕阅读英文资料）&lt;/li&gt;&lt;li&gt;（本教程面向 Linux 用户，Mac 用户大同小异，Windows 用户自己看着办）&lt;/li&gt;&lt;/ul&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;p&gt;然后再来介绍一下要用到的工具:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://mcp.ocean-labs.de/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MCP&lt;/a&gt;(Minecraft Coders’ Pack)主要负责反混淆 Minecraft 的代码，同时向 Forge 提供对应的文档 &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://files.minecraftforge.net/fml/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FML&lt;/a&gt;(Forge Mod Loader) 提供了一些底层功能，如 Mod 加载，ASM 等。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://www.minecraftforge.net&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forge&lt;/a&gt;提供了更高级的接口，如增加方块，修改合成表等。&lt;/li&gt;&lt;li&gt;ForgeGradle 帮助建立开发环境和发布 &lt;/li&gt;&lt;/ul&gt;&lt;p&gt; 一般来说，FML 都会附带在 Forge 里，在某些情况下，比如现在（2014 年 11 月 5 日）1.8 的 Forge 还未完成，但 FML 已放出，就可以单独只安装 FML，先开始 Coremod 的开发。&lt;/p&gt;&lt;h1 id=&quot;Intellij-IDEA 配置教程&quot;&gt;&lt;a href=&quot;#Intellij-IDEA 配置教程&quot; class=&quot;headerlink&quot; title=&quot;Intellij IDEA 配置教程&quot;&gt;&lt;/a&gt;Intellij IDEA 配置教程 &lt;/h1&gt;&lt;p&gt; 网上大部分教程都是讲 Eclipse 的，但是个人偏好 IDEA，所以讲一下 IDEA 的配置流程。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;安装 IDEA，没有必要找破解版，免费的 Community Edition 足够 &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://files.minecraftforge.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; 下载 &lt;/a&gt;Forge 代码，就是 Src 那个链接。请选择自己需要的版本，我以&lt;code&gt;1.7.10-Recommended&lt;/code&gt; 为例 &lt;/li&gt;&lt;li&gt;&lt;p&gt; 解压到一个你看着顺眼的地方，然后依次执行以下命令&lt;/p&gt;&lt;pre&gt;&lt;code&gt;gradle setupDecompWorkspace
gradle idea
gradle genIntellijRun
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;没有装 gradle 也不想装的，可以用 &lt;code&gt;./gradlew&lt;/code&gt;&lt;br&gt; 强烈建议挂着代理或 VPN 做这事，否则将是极端痛苦的过程。&lt;br&gt;你也可以加上 &lt;code&gt;-i&lt;/code&gt; 选项看滚滚的数据输出以不至于那么无聊。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;打开 IDEA，直接 Open Project，选择目录下的.ipr 文件应该就好了，你可以试着 Run 一下看看有没有什么问题。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;注：直接 &lt;code&gt;gradle idea&lt;/code&gt; 现在是不被推荐的，可以尝试用 &lt;code&gt;gradle ideaModule&lt;/code&gt; 代替，具体方法在 &lt;a href=&quot;http://www.devinprogress.org/2014/12/setup-forge-workspace-with-idea/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; 我的另一篇日志 &lt;/a&gt; 里有讲。&lt;br&gt;如果需要 Socks 代理的，可以这么来 &lt;code&gt;gradle -DsocksProxyHost={代理服务器地址} -DsocksProxyPort={代理端口}&lt;/code&gt;&lt;/p&gt;&lt;h1 id=&quot;代码管理与开发&quot;&gt;&lt;a href=&quot;# 代码管理与开发&quot; class=&quot;headerlink&quot; title=&quot;代码管理与开发&quot;&gt;&lt;/a&gt; 代码管理与开发 &lt;/h1&gt;&lt;p&gt;&lt;del&gt; 源代码和资源文件都是放在 &lt;code&gt;src&lt;/code&gt; 文件夹里的，有时要在多个不同的 Mod 间切换开发，我目前的解决方法是将代码统一放在别处，将 src 文件夹做软链接进来。同时我也非常推荐也用这种方法处理 &lt;code&gt;build.gradle&lt;/code&gt; 文件。将代码放在别处还有个好处，就是可以用 &lt;code&gt;git&lt;/code&gt; 来管理版本，而且可以用分支方便地管理对不同 Minecraft 版本做的修改。不管什么方式，自己习惯就好。&lt;/del&gt;&lt;/p&gt;&lt;p&gt;用了 &lt;code&gt;gradle ideaModule&lt;/code&gt; 后，代码本身就分开放置了，不再需要这种方法了。&lt;/p&gt;&lt;p&gt;对于开发这一部分，自己深感无力 (其实就是懒)，请参阅 szszss 的系列教程。&lt;br&gt; 另外，现在已经没有 Coremod 文件夹了，所以所有 Mod 都放在 Mods 文件夹下，不同之处只在于 &lt;code&gt;MANIFEST.MF&lt;/code&gt; 文件。&lt;/p&gt;&lt;h1 id=&quot;发布&quot;&gt;&lt;a href=&quot;# 发布&quot; class=&quot;headerlink&quot; title=&quot;发布&quot;&gt;&lt;/a&gt;发布 &lt;/h1&gt;&lt;p&gt; 感谢 ForgeGradle，打包发布不再需要手动拷贝压缩一大堆文件了。首先，你需要修改下 &lt;code&gt;build.gradle&lt;/code&gt; 文件，这也是我为什么推荐用软链接来管理它的原因。&lt;br&gt;以原始的文件为例：&lt;/p&gt;&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;version = &lt;span class=&quot;string&quot;&gt;&quot;1.0&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;group= &lt;span class=&quot;string&quot;&gt;&quot;com.yourname.modid&quot;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// http://maven.apache.org/guides/mini/guide-naming-conventions.html&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;archivesBaseName = &lt;span class=&quot;string&quot;&gt;&quot;modid&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minecraft &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    version = &lt;span class=&quot;string&quot;&gt;&quot;1.7.10-10.13.2.1230&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    runDir = &lt;span class=&quot;string&quot;&gt;&quot;eclipse&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;code&gt;archivesBaseName&lt;/code&gt;和第一行 &lt;code&gt;version&lt;/code&gt; 都可以自由修改，只会影响输出的 jar 文件的名字，关于 &lt;code&gt;group&lt;/code&gt; 用途不明，有了解的求留言告知。&lt;br&gt;如果你打算把 Mod 升级到一个新的 Forge 版本，请务必修改 &lt;code&gt;minecraft.version&lt;/code&gt; 和你的开发环境一致，否则会出现奇奇怪怪的问题。&lt;br&gt;修改好后，就可以用 &lt;code&gt;gradle build&lt;/code&gt; 来编译了，同样建议开代理。编译好的 jar 在 &lt;code&gt;build/libs&lt;/code&gt; 下。&lt;/p&gt;&lt;p&gt;如果是需要对 MANIFEST 进行修改的，比如 Coremod，需要在 &lt;code&gt;build.gradle&lt;/code&gt; 中 minecraft 块之后添加 jar 块:&lt;/p&gt;&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jar &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    manifest &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        attributes &lt;span class=&quot;string&quot;&gt;&#39;FMLCorePlugin&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;org.devinprogress.uniskinmod.SkinCore&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;如果你的一个 jar 包里既有普通 Mod（以 &lt;code&gt;@Mod&lt;/code&gt; 作 Annotation 的）又有 Coremod，你还需要&lt;/p&gt;&lt;pre&gt;&lt;code&gt;attributes &amp;apos;FMLCorePluginContainsFMLMod&amp;apos;: true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;否则普通 Mod 不会被载入。&lt;/p&gt;&lt;h1 id=&quot;ASMTransformer&quot;&gt;&lt;a href=&quot;#ASMTransformer&quot; class=&quot;headerlink&quot; title=&quot;ASMTransformer&quot;&gt;&lt;/a&gt;ASMTransformer&lt;/h1&gt;&lt;p&gt;因为 MCP 坑爹的反混淆机制，开发者在处理 Method 或 Field 时需要对付三种不同的名字：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;形似 &lt;code&gt;a&lt;/code&gt; 这样的混淆名，&lt;code&gt;obfName&lt;/code&gt;&lt;/li&gt;&lt;li&gt;形似 &lt;code&gt;func_xxxx_a&lt;/code&gt; 这样的半混淆名，有时也称作 &lt;code&gt;srgName&lt;/code&gt;&lt;/li&gt;&lt;li&gt; 形似 &lt;code&gt;doTick&lt;/code&gt; 这样的反混淆名，或称 &lt;code&gt;mcpName&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt; 关于为什么要有 srgName，MCP 是这么解释的：因为 mcpName 是任何人都可以贡献的（这是真的），所以会出现这么一种情况，有时为了更好地描述某个函数的功能，在次要版本升级时（比如 1.7.1 升级 1.7.2），mcpName 会发生变化，如果直接以 mcpName 进行编译，那么为 1.7.1 编译的 Mod 就无法在 1.7.2 上使用，即使其他方面都没有问题。于是为了解决这个问题，引入了相对固定的 srgName。FML 是这么处理名称的，在 &lt;code&gt;gradle build&lt;/code&gt; 时，代码中所有的 mcpName 均会被混淆成 srgName。然后在玩家运行游戏时，所有的 obfName 均被反混淆成 srgName，即 &lt;code&gt;RuntimeDeobfuscation&lt;/code&gt;，运行时反混淆。&lt;/p&gt;&lt;p&gt; 在你修改某个方法之前，首先必须定位它（废话）。定位一个方法需要四个信息：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;方法所在的类的完全限定名（这里这里指的是反混淆了的类名）&lt;/li&gt;&lt;li&gt;方法的 srgName&lt;/li&gt;&lt;li&gt;方法的 mcpName(用于在开发时确定方法，有时和 srgName 相同)&lt;/li&gt;&lt;li&gt;方法的 Description，或者说，参数列表。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;类很好确定，每当一个新的类被加载时，都会调用 &lt;code&gt;IClassTransformer&lt;/code&gt; 接口的 &lt;code&gt;transform&lt;/code&gt; 方法：&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;IClassTransformer&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] transform(String obfuscatedClassName, String transformedClassName, &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] bytes);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;第二个参数就是反混淆了的类名，并且是点分割，大小写正确的，可以直接用 &lt;code&gt;equals()&lt;/code&gt; 来判断。&lt;br&gt;但是方法名的判断就比较复杂，因为在 ASM 转换时，运行时反混淆还没有被执行，所以方法名全部都是 obfName。更要命的是，如果方法的参数里有 Minecraft 的类，那么这个类名也是被混淆了的类名。&lt;/p&gt;&lt;p&gt;不过谢天谢地，我们有 &lt;code&gt;FMLDeobfuscatingRemapper&lt;/code&gt;，你可以用&lt;code&gt;FMLDeobfuscatingRemapper.INSTANCE&lt;/code&gt; 来取得实例。这个类提供了几个重要的方法：&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;String &lt;span class=&quot;title&quot;&gt;mapMethodName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String obfedClassName, String obfedMethodName, String obfedMethodDescription)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String &lt;span class=&quot;title&quot;&gt;mapFieldName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String obfedClassName, String obfedFieldName, String obfedFieldDescription)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String &lt;span class=&quot;title&quot;&gt;mapMethodDesc&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String obfedMethodDescription)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;其中 &lt;code&gt;mapMethodName&lt;/code&gt; 和&lt;code&gt;mapFieldName&lt;/code&gt;返回对应方法和字段的 srgName，&lt;code&gt;mapMethodDesc&lt;/code&gt;返回反混淆了的 Description，也就是将 &lt;code&gt;(Lbee;F)V&lt;/code&gt; 这种变为 &lt;code&gt;(Lnet/minecraft/client/gui/GuiMainMenu;F)V&lt;/code&gt;。&lt;/p&gt;&lt;p&gt; 如果你需要在某个方法中添加大段的代码，我极度不推荐写长长的代码将所有这些操作码全部加到目标方法里去，这种方法枯燥至极，又不直观，还难于调试。我一般的方法是，使用 &lt;code&gt;INVOKESTATIC&lt;/code&gt; 调用自己写好的函数，并将需要修改的变量作为参数传递，这样需要的代码不多，也易于调试和维护。&lt;/p&gt;&lt;p&gt;在向代码中添加操作，尤其是费时的操作时（比如网络 IO）请务必谨慎选择插入的位置。因为大部分代码会在主线程中执行，一旦卡住轻则界面冻结，重则直接被服务器超时踢出。&lt;/p&gt;&lt;p&gt;我不是非常推荐让 ASM 自动计算栈大小和本地变量区大小，因为碰到一些比较复杂的类时会悲剧，比如 &lt;code&gt;AbstractClientPlayer&lt;/code&gt;&lt;/p&gt;&lt;p&gt; 如果你想清空一个方法让它什么都不做，请还是不要忘记加上 RETURN&lt;/p&gt;&lt;p&gt;有时，开发环境下编译出的 class 和原始的 class 会有区别，所以还是建议用 javap 之类的工具看一下原始的字节码。&lt;/p&gt;&lt;h1 id=&quot;AccessTransformer&quot;&gt;&lt;a href=&quot;#AccessTransformer&quot; class=&quot;headerlink&quot; title=&quot;AccessTransformer&quot;&gt;&lt;/a&gt;AccessTransformer&lt;/h1&gt;&lt;p&gt;有时，我们需要频繁调用某个 private 的 Method 或是 Field，使用反射会有性能损失，而 ASMTransformer 也无效 (因为无法通过编译)，这就到了 AccessTransformer 大显身手的时候了。&lt;br&gt;AccessTransformer 用于将 private 或是 protected 的 Method 和 Field 变为 public，这样在代码中就可以直接使用了。&lt;br&gt; 你需要首先创建一个 &lt;code&gt;*_at.cfg&lt;/code&gt; 的配置文件放在 resources 目录（就是放 &lt;code&gt;mcmod.info&lt;/code&gt; 的目录）下，然后将其软链接到根目录下（和 &lt;code&gt;build.gradle&lt;/code&gt; 同目录）。&lt;br&gt;配置文件的语法类似这样（这是 &lt;code&gt;fml_at.cfg&lt;/code&gt; 的一部分）&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; net.minecraft.entity.&lt;span class=&quot;function&quot;&gt;EntityList &lt;span class=&quot;title&quot;&gt;func_75618_a&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Ljava/lang/Class;Ljava/lang/String;I)&lt;/span&gt;V&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; net.minecraft.entity.EntityList field_75625_b #nameToClassMap&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; net.minecraft.item.crafting.CraftingManager &lt;span class=&quot;title&quot;&gt;func_92103_a&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Lnet.minecraft.item.ItemStack;[Ljava/lang/Object;)&lt;/span&gt;Lnet.minecraft.item.crafting.ShapedRecipes&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;接着重建工作区：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;gradle clean setupDecompWorkspace idea --refresh-dependencies
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同样建议挂代理，用 eclipse 的同学把 &lt;code&gt;idea&lt;/code&gt; 换成 &lt;code&gt;eclipse&lt;/code&gt;，有强迫症的同学可以加上&lt;code&gt;-i&lt;/code&gt; 选项。这样，开发环境下代码的改动就完成了。我在挂着代理的情况下大约需要 8 分钟。&lt;/p&gt;&lt;p&gt;为了让其在混淆环境下也能正常工作，你需要创建一个新的类，继承 &lt;code&gt;AccessTransformer&lt;/code&gt;:&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyATransformer&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AccessTransformer&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyATransformer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;mymod_at.cfg&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt; 其中的字符串就是配置文件名，然后在实现了 &lt;code&gt;IFMLLoadingPlugin&lt;/code&gt; 的类里：&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;getAccessTransformerClass&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; MyATransformer.class.getName();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;另外需要注意的是，AccessTransformer 不会自动转换衍生类，所以在转换基类时请务必当心，否则会编译不通过。&lt;/p&gt;&lt;p&gt;在 1.7.10 及以上的版本中，可以在 build.gradle 文件的中加入以下内容，这样就不必再写 IFMLLoadingPlugin 了。其中的 &lt;code&gt;mymod_at.cfg&lt;/code&gt; 文件要放在 META-INF 文件夹下。&lt;/p&gt;&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jar &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    manifest &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        attributes &lt;span class=&quot;string&quot;&gt;&#39;FMLAT&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;mymod_at.cfg&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h1 id=&quot;其他杂七杂八的东西&quot;&gt;&lt;a href=&quot;# 其他杂七杂八的东西&quot; class=&quot;headerlink&quot; title=&quot;其他杂七杂八的东西&quot;&gt;&lt;/a&gt;其他杂七杂八的东西 &lt;/h1&gt;&lt;ul&gt;&lt;li&gt; 如果你想给 MCP 贡献 mcpName，可以去 IRC esper#mcp 找 MCPBot_Reborn&lt;/li&gt;&lt;li&gt;最新的反混淆名对应表可以在 &lt;a href=&quot;http://export.mcpbot.bspk.rs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MCPBot Export&lt;/a&gt; 找到 &lt;/li&gt;&lt;li&gt; 如果你厌倦了用文本编辑器搜索字符串来找 srgName 的话，可以试试 &lt;a href=&quot;https://github.com/bspkrs/MCPMappingViewer/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MCPMappingViewer&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://bitbucket.org/mstrobel/procyon&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Procyon&lt;/a&gt; 是个极好的 Java 反编译器&lt;/li&gt;&lt;/ul&gt;</content>
    
    <summary type="html">
    
      Some notes on developing coremods for Minecraft, mainly about ASM &amp; AccessTransformer
    
    </summary>
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="教程" scheme="http://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Minecraft" scheme="http://recursiveg.me/tags/Minecraft/"/>
    
      <category term="Java" scheme="http://recursiveg.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>域名注册商更换</title>
    <link href="http://recursiveg.me/2014/07/domain-name-registrar-switched/"/>
    <id>http://recursiveg.me/2014/07/domain-name-registrar-switched/</id>
    <published>2014-07-16T05:43:25.000Z</published>
    <updated>2016-01-14T02:33:05.839Z</updated>
    
    <content type="html">&lt;p&gt;昨天折腾了一天，把域名从 Godaddy 转移到了 Name.com&lt;br&gt;表示基本没遇到什么麻烦，信用卡借用了家长的，付款也很方便。&lt;br&gt;关键是便宜啊。转入 9 美刀，续期 11 美刀, 比 Godaddy 坑爹的 18 刀便宜太多了啊~~&lt;br&gt;而且还有免费的 WHOIS 保护啊~~~~ 优惠码 &lt;code&gt;PRIVACYPLEASE&lt;/code&gt; 超好记有木有！&lt;br&gt;虽然不是最便宜的但是 Name.com 的控制台相当美观呐~&lt;br&gt;结尾吐槽一句：在万网注册的都是真的勇士。&lt;/p&gt;</content>
    
    <summary type="html">
    
      A note to the switch of domain name registrar
    
    </summary>
    
      <category term="Site Management" scheme="http://recursiveg.me/categories/Site-Management/"/>
    
    
      <category term="Site Management" scheme="http://recursiveg.me/tags/Site-Management/"/>
    
  </entry>
  
  <entry>
    <title>Programming with PTRACE, Part6 - 时间控制</title>
    <link href="http://recursiveg.me/2014/07/programming-with-ptrace-part6/"/>
    <id>http://recursiveg.me/2014/07/programming-with-ptrace-part6/</id>
    <published>2014-07-07T08:51:03.000Z</published>
    <updated>2016-01-14T02:33:05.839Z</updated>
    
    <content type="html">&lt;h1 id=&quot;不同的时间计算方法&quot;&gt;&lt;a href=&quot;# 不同的时间计算方法&quot; class=&quot;headerlink&quot; title=&quot;不同的时间计算方法&quot;&gt;&lt;/a&gt;不同的时间计算方法 &lt;/h1&gt;&lt;p&gt; 程序运行会占用一小段时间（废话），事实上，我们有不止一种方法来表示一个程序运行了多长时间。最直观的应该是“墙上时间”，也就是说，你掐个秒表，看看程序从开始到结束用了多长时间。除此之外，还有“用户态时间”和“内核态时间”，这两个时间都是以 CPU 实际运算的时间，也就是 CPU 周期，来计数的。“用户态时间”就是程序在用户态执行的时间，包括程序所引用的库中的代码（比如 STL），“内核态时间”就是指程序在内核态执行的时间，一般是各种系统调用（比如各种 IO 操作）。这两种时间和墙上时间的区别在于，因为 CPU 其实是在多个程序中快速切换的，所以在运行某个程序的时间里，CPU 也处理了属于其他进程的任务，而且 CPU 切换任务也需要一定的时间（真的很短）。如果处于被调试状态，tracer 的运行时间也会被计算在内，这些不属于这个进程的时间片也会被计算在这个进程的“墙上时间”里。所以一般以用户态时间和内核态时间的总和作为进程的运行时间。&lt;/p&gt;&lt;p&gt;在 Linux 系统里有一个叫 &lt;code&gt;time&lt;/code&gt; 的命令可以查看一个命令执行了多长时间。这个命令有两个版本，一个是 shell 内置的，另一个是独立的可执行文件，可以用 &lt;code&gt;type time&lt;/code&gt; 命令查看。虽然可执行版本功能更强一点，但内置的功能足够，这一点区别可以不管。用法是： &lt;code&gt;time [命令] &amp;lt; 参数 &amp;gt;&lt;/code&gt;。给个例子：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;time ffmpeg -i sample.mp4 target.mp3
...
5.42s user
0.10s system
100% cpu
5.520 total
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;h1 id=&quot;动手写个带时限的 time&quot;&gt;&lt;a href=&quot;# 动手写个带时限的 time&quot; class=&quot;headerlink&quot; title=&quot;动手写个带时限的 time&quot;&gt;&lt;/a&gt;动手写个带时限的 time&lt;/h1&gt;&lt;p&gt;还在对上个 PART 的 &lt;code&gt;setrlimit&lt;/code&gt; 耿耿于怀么？我们现在就来用它！相关的定义位于 &lt;code&gt;sys/resource.h&lt;/code&gt; 头文件里。我们这次要用到 &lt;code&gt;RLIMIT_CPU&lt;/code&gt;, 这个选项限制进程所能占用的 CPU 时间，以秒为单位，可以把它理解为用户态时间和内核态时间的和。我们首先要使用&lt;code&gt;getrlimit&lt;/code&gt; 获得当前的限制：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;struct rlimit TimeL;
getrlimit(RLIMIT_CPU,&amp;amp;TimeL);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;rlimit&lt;/code&gt;结构有两个成员:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;rlim_cur&lt;/code&gt; 软限制 &lt;/li&gt;&lt;li&gt;&lt;code&gt;rlim_max&lt;/code&gt; 硬限制&lt;/li&gt;&lt;/ul&gt;&lt;p&gt; 系统一般会用比较平和的方式对待那些达到软限制的进程，比如发个 SIGSEGV 什么的。而那些达到硬限制的进程会被直接 SIGKILL。我们接下来要修改软限制，注意单位是秒。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;TimeL.rlim_cur=Timeout;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上工作都要在 &lt;code&gt;fork()&lt;/code&gt; 之前完成，之后要在 &lt;em&gt; 子进程 &lt;/em&gt; 里应用这个限制（没错就是 exec 那里）&lt;/p&gt;&lt;pre&gt;&lt;code&gt;setrlimit(RLIMIT_CPU,&amp;amp;TimeL);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样，如果子进程超过软限制，系统就会发送 &lt;code&gt;SIGXCPU&lt;/code&gt; 信号给子进程。当然，因为 ptrace 的原因，信号会被先发送给父进程，这样就可以用 part3 里介绍的方法进行处理。这样子进程是要清蒸还是油炸就都由父进程决定了。&lt;br&gt;当然，我们还有别的方法获取时间信息。一是用 &lt;code&gt;gettimeofday()&lt;/code&gt; 函数配合 &lt;code&gt;timeval&lt;/code&gt; 结构，可以获得当前时间，精确到微秒（百万分之一秒）。在程序开始时调用下，结束时调用下，相减即可得到墙上时间。另一种方法是利用 &lt;code&gt;wait4&lt;/code&gt; 里的 &lt;code&gt;ru&lt;/code&gt; 参数，它其实是个 &lt;code&gt;rusage&lt;/code&gt; 结构, 成员 &lt;a href=&quot;http://man7.org/linux/man-pages/man2/getrusage.2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; 见此 &lt;/a&gt;。其中的&lt;code&gt;ru_utime&lt;/code&gt; 和&lt;code&gt;ru_stime&lt;/code&gt;成员是 &lt;code&gt;timeval&lt;/code&gt; 结构，分别记录了用户态时间和内核态时间，同样精确到微秒。&lt;/p&gt;&lt;h1 id=&quot;程序睡着了&quot;&gt;&lt;a href=&quot;# 程序睡着了&quot; class=&quot;headerlink&quot; title=&quot;程序睡着了&quot;&gt;&lt;/a&gt;程序睡着了 &lt;/h1&gt;&lt;p&gt;&lt;code&gt;RLIMIT_CPU&lt;/code&gt; 大多数情况下都能正常工作，配合 &lt;code&gt;timeval&lt;/code&gt; 结构甚至能进一步提高精度。但是有两个例外（如果有更多请务必告诉我）：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;程序主动调用 &lt;code&gt;sleep()&lt;/code&gt;&lt;/li&gt;&lt;li&gt; 交互状态下 &lt;code&gt;scanf()&lt;/code&gt; 一类的函数等待键盘输入 &lt;/li&gt;&lt;/ol&gt;&lt;p&gt; 在这两种情况下：进程不占用 CPU 时间，&lt;code&gt;RLIMIT_CPU&lt;/code&gt;管不着；没有系统调用，&lt;code&gt;wait4()&lt;/code&gt;不返回。为了能够在这种情况下依然能够限制时间，我想出了两种方法。一是限制和 &lt;code&gt;sleep()&lt;/code&gt; 相关的系统调用，二是父进程设置 ALARM。我在这里讲一下第二种方法。&lt;br&gt;Linux 提供了一个 &lt;code&gt;alarm()&lt;/code&gt; 函数，可以在指定的秒数 &lt;strong&gt;(墙上时间)&lt;/strong&gt; 后给这个进程本身发送 &lt;code&gt;SIGALRM&lt;/code&gt; 信号。而且，我们可以给信号绑定一个处理函数（就是当信号到达时调用的函数），在这个处理函数里，可以用 &lt;code&gt;kill&lt;/code&gt; 命令给子进程发送信号（比如 &lt;code&gt;SIGUSR1&lt;/code&gt;），这样就能使父进程里的&lt;code&gt;wait4()&lt;/code&gt; 返回，就可以控制子进程了。以下是一个简要指导：&lt;br&gt;首先我们需要一个信号处理函数, 记得把 pid 改成全局变量：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;void AlarmIn(int sig){if(sig==SIGALRM)
    kill(pid,SIGUSR1);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在子程序开始执行的时候绑定信号并设置 Alarm，我在这设置超时一秒:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;signal(SIGALRM,AlarmIn);
alarm(1);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后请根据 part3 所讲的内容在 while 循环里正确处理&lt;code&gt;SIGUSR1&lt;/code&gt;。最后记得取消 Alarm，如果没超时的话：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;alarm(0);
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;完整代码？&quot;&gt;&lt;a href=&quot;# 完整代码？&quot; class=&quot;headerlink&quot; title=&quot;完整代码？&quot;&gt;&lt;/a&gt;完整代码？&lt;/h1&gt;&lt;p&gt;表示完整代码太长了，放这儿太不美观，&lt;del&gt;我会稍后贴到 gist 上去。&lt;/del&gt;代码被幽幽子吃掉了大家自己写把。&lt;/p&gt;&lt;h1 id=&quot;拓展阅读&quot;&gt;&lt;a href=&quot;# 拓展阅读&quot; class=&quot;headerlink&quot; title=&quot;拓展阅读&quot;&gt;&lt;/a&gt;拓展阅读 &lt;/h1&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E6%95%B0%E9%87%8F%E7%BA%A7_%28%E6%97%B6%E9%97%B4%29&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Wikipedia - 数量级 (时间)&lt;/a&gt; 我把这个链接放这儿是因为老有人把微秒缩写成&lt;code&gt;ms&lt;/code&gt; 然后和毫秒搞混 &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/xwdok/article/details/542109&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; 协同式多任务与抢占式多任务 &lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/iceocean/articles/1650929.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux 时间管理&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://russelltao.iteye.com/blog/1405353&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; 浅谈时间函数 gettimeofday 的成本&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</content>
    
    <summary type="html">
    
      Sixth part of serial of tutorial: Programming with PTRACE
    
    </summary>
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="Linux" scheme="http://recursiveg.me/tags/Linux/"/>
    
      <category term="PTRACE" scheme="http://recursiveg.me/tags/PTRACE/"/>
    
      <category term="教程" scheme="http://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Programming with PTRACE, Part5 - 内存管理</title>
    <link href="http://recursiveg.me/2014/05/programming-with-ptrace-part5/"/>
    <id>http://recursiveg.me/2014/05/programming-with-ptrace-part5/</id>
    <published>2014-05-26T02:00:32.000Z</published>
    <updated>2016-01-14T02:33:05.839Z</updated>
    
    <content type="html">&lt;p&gt;这个 part 主要讲解 Linux 的内存管理机制，以及如何查看并限制子进程的内存使用。&lt;/p&gt;&lt;h1 id=&quot;内存的划分&quot;&gt;&lt;a href=&quot;# 内存的划分&quot; class=&quot;headerlink&quot; title=&quot;内存的划分&quot;&gt;&lt;/a&gt;内存的划分 &lt;/h1&gt;&lt;p&gt;（嘛。。。这一部分也算是现学现卖的，如果大家觉得有什么讲的不到位的请翻下方的拓展阅读部分）&lt;br&gt; 大家都知道，32 位系统最大可以寻址 4GB 的地址空间（不考虑 &lt;a href=&quot;http://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E6%89%A9%E5%B1%95&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; 物理地址扩展 &lt;/a&gt;），那么这个“地址”究竟指的是哪儿的地址呢？你可以写一个小程序，malloc 一点内存，然后把地址打印出来，重复几次，你会发现，分配的内存几乎都在同一个位置。这是因为，对于程序来说，这些地址都是虚拟地址，虚拟地址空间对于每个进程都是独立的，也就是说，对于不同的进程，同样虚拟地址上的数据是不同的。&lt;br&gt; 当然，数据肯定是存放在内存条上的，我们把可以直接读写内存条的地址叫做物理地址。物理地址以一定的方式映射到虚拟地址上，所以当程序试图访问虚拟地址时，系统要以一定方式把虚拟地址变成物理地址，这项工作通常是由 &lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MMU(内存管理单元)&lt;/a&gt; 来完成的。内存的映射不是大块大块的，而是一小片一小片分别映射的，所以在虚拟地址上连续的地址可能在物理地址上相差十万八千里，这些一小片一小片的内存被称为“页”。&lt;br&gt;页的存在给内存分配带来了极大的灵活性，页可以存储在内存里，也可以存储在交换分区里，可以将同一块物理内存映射到不同进程的虚拟空间里（动态库经常这么干），甚至可以映射到磁盘上的某个文件。光说可能有点抽象，于是给幅图 (来自 Wikipedia)&lt;br&gt;&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/commons/3/32/Virtual_address_space_and_physical_address_space_relationship.svg&quot; alt=&quot;内存页映射是不连续的&quot;&gt;&lt;br&gt; 虚拟地址被分成多个段，数据有序存放于其中。这是 32 位 Linux 的新内存布局 (Linux 2.6.7 之后):&lt;br&gt;&lt;img src=&quot;http://static.duartes.org/img/blogPosts/linuxFlexibleAddressSpaceLayout.png&quot; alt=&quot;Linux 新内存布局&quot;&gt;&lt;br&gt; 如果你研究过可执行文件的结构，你就会发现，虚拟地址的段就是按可执行文件的段来填充的。另外，由于代码段的起点地址是固定的 (0x08048000)，所以编译器就可以预先算出函数的地址了。顺带一提，因为动态库加载时的虚拟地址是不固定的，不能预先计算出函数地址，所以要在编译时使用&lt;code&gt;-fPIC&lt;/code&gt; 选项生成位置无关代码，否则每次被一个新进程使用时都要进行重定位 (可以理解为重新计算函数地址)，并生成该动态库的一个副本，这样压根没有起到节约内存的作用。&lt;br&gt; 扯远了，回来。尽管每个进程的虚拟地址空间时互相独立的，但并不意味着进程想访问哪儿就能访问的，比如 3GB 以上的区域，那儿是内核的领地。即使是堆段，也只能访问已申请的内存部分，非法的内存访问将会引发段错误 (Segmentation Fault)。回到&lt;code&gt;malloc()&lt;/code&gt; 函数上，malloc 最终会调用 &lt;code&gt;brk&lt;/code&gt; 或&lt;code&gt;mmap&lt;/code&gt;系统调用，brk 用于在堆中分配小块内存，mmap 则用于在 Memory Mapping Segment 中分配大块内存。但是并不是每次 malloc 都会调用 brk，这是因为分配的内存实在是太小了，而 brk 只能分配大一点的内存，所以 C 运行库 (比如 glibc) 在收到一个 malloc 时会先用 brk 向系统“批发”一块大一点的内存，而收到后续分配请求时则把这块大内存“零售”给程序，直到售完再次 brk。&lt;br&gt;如果有一个程序死循环单纯 malloc 内存，内存会不会被吃光呢？答案是不会 (我不清楚是不是真的有如此单纯的系统真的会挂掉)，因为系统发现，你只是分配了内存，却没有使用，于是它很机智地将那片内存设置为“可访问”，却没有把它映射到任何一个实际的内存页上！&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h1 id=&quot;你用了多少内存？&quot;&gt;&lt;a href=&quot;# 你用了多少内存？&quot; class=&quot;headerlink&quot; title=&quot;你用了多少内存？&quot;&gt;&lt;/a&gt; 你用了多少内存？&lt;/h1&gt;&lt;p&gt;还记得之前的 &lt;code&gt;rusage&lt;/code&gt; 结构么？其成员可在 &lt;a href=&quot;http://man7.org/linux/man-pages/man2/getrusage.2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; 这里 &lt;/a&gt; 找到。事实上，这是一种非常简陋的内存使用信息获取方式，我们只关心其中的 &lt;code&gt;ru_maxrss&lt;/code&gt; 一项，RSS 即”Resident Set Size”，表示该进程在物理内存中的占用大小，不包括交换分区中的内存大小，也不包含分配了却未使用而没有物理内存页的内存。为了获得更详细的内存信息，我们需要访问 &lt;code&gt;/proc&lt;/code&gt; 目录。该目录下各文件的用途在 &lt;code&gt;man 5 proc&lt;/code&gt; 里描述得很清楚，&lt;a href=&quot;http://man7.org/linux/man-pages/man5/proc.5.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里 &lt;/a&gt; 是网页版本。关于这个目录的作用，我就偷懒，将 man 手册中的描述翻译如下：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;proc&lt;/code&gt;文件系统是一个伪文件系统，提供了访问内核数据结构的接口。它通常被挂载在 &lt;code&gt;/proc&lt;/code&gt; 上并且大部分是只读的，除了少数文件被允许用来改变内核参数。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;code&gt;/proc&lt;/code&gt;下有 N 多文件夹，大部分是按进程的 pid 来命名的，我们关心的是这些文件夹中的 &lt;code&gt;status&lt;/code&gt; 文件。来看一个例子：&lt;code&gt;cat /proc/1/status|grep Vm&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;VmPeak:      173616 kB
VmSize:      107968 kB
VmLck:           0 kB
VmPin:           0 kB
VmHWM:        3816 kB
VmRSS:        3744 kB
VmData:       83744 kB
VmStk:         136 kB
VmExe:        1140 kB
VmLib:        2268 kB
VmPTE:          72 kB
VmSwap:           0 kB
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们看到了两个令人感兴趣的东西：&lt;code&gt;VmData&lt;/code&gt;和 &lt;code&gt;VmStk&lt;/code&gt;。分别代表了数据区和栈的大小，而且这两个数据是真正的可访问的虚拟内存大小，即不会像 RSS 那样，漏掉那些分配了而未访问的内存。当然，其他数据也都是很有趣的，有兴趣的人可以自己去翻 man 手册。这段代码计算给定进程的数据段和堆栈段内存使用总和。&lt;/p&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getMemory&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;pid_t&lt;/span&gt; pid)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; stat_loc[&lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; VmData,VmStk;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;sprintf&lt;/span&gt;(stat_loc,&lt;span class=&quot;string&quot;&gt;&quot;/proc/%d/status&quot;&lt;/span&gt;,pid);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    FILE *stat=fopen(stat_loc,&lt;span class=&quot;string&quot;&gt;&quot;r&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; line[&lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(EOF!=&lt;span class=&quot;built_in&quot;&gt;fscanf&lt;/span&gt;(stat,&lt;span class=&quot;string&quot;&gt;&quot;%[^\n]&quot;&lt;/span&gt;,line))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;sscanf&lt;/span&gt;(line,&lt;span class=&quot;string&quot;&gt;&quot;VmData: %ld&quot;&lt;/span&gt;,&amp;amp;VmData);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;sscanf&lt;/span&gt;(line,&lt;span class=&quot;string&quot;&gt;&quot;VmStk: %ld&quot;&lt;/span&gt;,&amp;amp;VmStk);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fgetc(stat);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; VmData+VmStk;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h1 id=&quot;限制内存&quot;&gt;&lt;a href=&quot;# 限制内存&quot; class=&quot;headerlink&quot; title=&quot;限制内存&quot;&gt;&lt;/a&gt; 限制内存 &lt;/h1&gt;&lt;p&gt; 也许你们已经知道，有一个叫做 &lt;code&gt;setrlimit&lt;/code&gt; 的函数可以用来限制资源使用，你们也许已经翻过了它的 man 手册，看到了 &lt;code&gt;RLIMIT_AS&lt;/code&gt; &lt;code&gt;RLIMIT_DATA&lt;/code&gt; &lt;code&gt;RLIMIT_RSS&lt;/code&gt; 等一票似乎很有用的参数。现在，请你立刻忘掉他们！既然我们之前讲了 &lt;code&gt;/proc&lt;/code&gt; 当然要用起来啦。我们不用 &lt;code&gt;setrlimit&lt;/code&gt; 是因为，这种限制策略会导致 malloc 失败（确切的讲是 brk 和 mmap 失败），而大部分 OIer 都没有检查 malloc 返回值的的习惯，最终导致本应是 MLE(Memory Limit Exceeded)的情况变成了由访问无效内存导致的 RE(Runtime Error)。更糟糕的是，如果是系统栈增长被限制了，进程会被直接 &lt;code&gt;SIGSEGV&lt;/code&gt;，连 errno 都没有，这种情况下就更难分辨了。那么，有什么好的方法来限制内存呢？答案就是在每次分配内存的系统调用（不限于 brk 和 mmap）时通过 proc 来检查内存使用，注意要在返回时检查哦。一旦超过，就由父进程直接杀死子进程，方法多种多样，你可以使用&lt;code&gt;ptrace(PTRACE_KILL,pid,0,0)&lt;/code&gt;，或是用 Part3 所讲的方法发送信号，或是直接用&lt;a href=&quot;http://man7.org/linux/man-pages/man2/kill.2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;kill 函数&lt;/a&gt;。这种方法看上去很不优雅，但确实很有效。至于那些对&lt;code&gt;setrlimit&lt;/code&gt; 耿耿于怀的同学，不要担心，下个 part 时间限制，将会大量用到。&lt;/p&gt;&lt;h1 id=&quot;拓展阅读 -amp- 参考资料&quot;&gt;&lt;a href=&quot;# 拓展阅读 -amp- 参考资料&quot; class=&quot;headerlink&quot; title=&quot;拓展阅读 &amp;amp; 参考资料&quot;&gt;&lt;/a&gt;拓展阅读 &amp;amp; 参考资料&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://xixinfei.iteye.com/blog/1949123&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux 内存管理详解&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://www.itvane.net/?p=1240&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux 进程地址空间详解&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/clover-toeic/p/3754433.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux 虚拟地址空间布局&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://acm.tongji.edu.cn/cnfaqs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OJ 系统各状态含义&lt;/a&gt;(见 Question #6；应该还有一个 RF:Restricted Function)&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Anatomy of a Program in Memory&lt;/a&gt;&lt;/li&gt;&lt;li&gt;man 手册&lt;/li&gt;&lt;/ul&gt;</content>
    
    <summary type="html">
    
      Fifth part of serial of tutorial: Programming with PTRACE
    
    </summary>
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="Linux" scheme="http://recursiveg.me/tags/Linux/"/>
    
      <category term="PTRACE" scheme="http://recursiveg.me/tags/PTRACE/"/>
    
      <category term="教程" scheme="http://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Programming with PTRACE, Part4 - 系统调用进阶</title>
    <link href="http://recursiveg.me/2014/05/programming-with-ptrace-part4/"/>
    <id>http://recursiveg.me/2014/05/programming-with-ptrace-part4/</id>
    <published>2014-05-26T02:00:31.000Z</published>
    <updated>2016-01-14T02:33:05.839Z</updated>
    
    <content type="html">&lt;p&gt;这个 part 是 &lt;a href=&quot;/2014/04/programming-with-ptrace-part2/&quot;&gt;Part2&lt;/a&gt; 的延续，所以我强烈建议你弄明白 Part2 中的内容后再来看本 part。那么进入正题，我将在这个部分讲解系统调用的参数传递顺序以及如何利用 ptrace 系统调用获得用户空间的数据。&lt;/p&gt;&lt;h2 id=&quot;参数与寄存器&quot;&gt;&lt;a href=&quot;# 参数与寄存器&quot; class=&quot;headerlink&quot; title=&quot;参数与寄存器&quot;&gt;&lt;/a&gt;参数与寄存器 &lt;/h2&gt;&lt;p&gt; 我在 Part2 中提到过，系统调用的参数是以一定顺序保存在寄存器里的，那么这个顺序是什么呢？在 &lt;code&gt;man 2 syscall&lt;/code&gt; 中有两张表格解释了这个问题，你也可以在 &lt;a href=&quot;http://man7.org/linux/man-pages/man2/syscall.2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; 这里 &lt;/a&gt; 看到，就在”Architecture calling conventions”下面。我知道很多人很懒，所以我就把这两张表格复制过来了。&lt;/p&gt;&lt;center&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th style=&quot;text-align:left&quot;&gt;arch/ABI&lt;/th&gt;&lt;th style=&quot;text-align:left&quot;&gt;instruction&lt;/th&gt;&lt;th style=&quot;text-align:left&quot;&gt;syscall #&lt;/th&gt;&lt;th style=&quot;text-align:left&quot;&gt;retval&lt;/th&gt;&lt;th style=&quot;text-align:left&quot;&gt;Notes&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;arm/OABI&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;swi NR&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;-&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;a1&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;NR is syscall #&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;arm/EABI&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;swi 0x0&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r7&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r0&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;blackfin&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;excpt 0x0&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;P0&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;R0&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;i386&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;int $0x80&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;eax&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;eax&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;ia64&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;break 0x100000&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r15&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r10/r8&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;bool error/errno value&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;parisc&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;ble 0x100(%sr2, %r0)&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r20&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r28&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;s390&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;svc 0&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r1&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r2&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;See below&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;s390x&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;svc 0&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r1&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r2&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;See below&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;sparc/32&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;t 0x10&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;g1&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;o0&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;sparc/64&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;t 0x6d&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;g1&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;o0&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;x86_64&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;syscall&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;rax&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;rax&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th style=&quot;text-align:left&quot;&gt;arch/ABI&lt;/th&gt;&lt;th style=&quot;text-align:left&quot;&gt;arg1&lt;/th&gt;&lt;th style=&quot;text-align:left&quot;&gt;arg2&lt;/th&gt;&lt;th style=&quot;text-align:left&quot;&gt;arg3&lt;/th&gt;&lt;th style=&quot;text-align:left&quot;&gt;arg4&lt;/th&gt;&lt;th style=&quot;text-align:left&quot;&gt;arg5&lt;/th&gt;&lt;th style=&quot;text-align:left&quot;&gt;arg6&lt;/th&gt;&lt;th style=&quot;text-align:left&quot;&gt;arg7&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;arm/OABI&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;a1&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;a2&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;a3&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;a4&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;v1&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;v2&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;v3&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;arm/EABI&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r0&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r1&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r2&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r3&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r4&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r5&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r6&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;blackfin&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;R0&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;R1&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;R2&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;R3&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;R4&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;R5&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;i386&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;ebx&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;ecx&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;edx&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;esi&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;edi&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;ebp&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;ia64&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;out0&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;out1&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;out2&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;out3&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;out4&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;out5&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;parisc&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r26&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r25&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r24&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r23&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r22&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r21&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;s390&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r2&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r3&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r4&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r5&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r6&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r7&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;s390x&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r2&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r3&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r4&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r5&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r6&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r7&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;sparc/32&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;o0&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;o1&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;o2&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;o3&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;o4&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;o5&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;sparc/64&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;o0&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;o1&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;o2&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;o3&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;o4&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;o5&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;x86_64&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;rdi&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;rsi&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;rdx&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r10&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r8&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;r9&lt;/td&gt;&lt;td style=&quot;text-align:left&quot;&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;/center&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;表格内容虽多，但其实我们关心的只有 i386 和 x86_64（32 位和 64 位）一共 4 行（因为有两张表格嘛）。精简提炼下，一共就两句话 &lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; 对于 32 位系统，系统调用号存放在 EAX 寄存器，参数依次放入 EBX、ECX、EDX、ESI … 返回值位于 EAX 寄存器 &lt;br&gt; 对于 64 位系统，系统调用号存放在 RAX 寄存器，参数依次放入 RDI、RSI、RDX、R10 … 返回值位于 RAX 寄存器 &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt; 以 64 位系统下的 &lt;code&gt;write()&lt;/code&gt; 调用为例:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ssize_t write(int fd, const void *buf, size_t count);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么 RAX 是 1(write 的调用号)，RDI 一般为 1(stdout),RSI 存储着指向用户空间中将要被输出的字符串的地址，RDX 自然就是字符串长度啦。&lt;/p&gt;&lt;h2 id=&quot;获取那个字符串&quot;&gt;&lt;a href=&quot;# 获取那个字符串&quot; class=&quot;headerlink&quot; title=&quot;获取那个字符串&quot;&gt;&lt;/a&gt;获取那个字符串 &lt;/h2&gt;&lt;p&gt; 理论讲完了，进入实战。这次我们拿 &lt;code&gt;open()&lt;/code&gt; 系统调用开刀，一是因为监视程序打开了什么文件比得知输出了什么更常用，二是因为传递给 &lt;code&gt;open()&lt;/code&gt; 的字符串没有长度信息，只能自己通过 &lt;code&gt;\0&lt;/code&gt; 判断，更有挑战性。我们这次要使用 ptrace 的一个新功能 &lt;code&gt;PTRACE_PEEKTEXT&lt;/code&gt;, 其实还有另外一个叫做&lt;code&gt;PTRACE_PEEKDATA&lt;/code&gt; 的，不过根据 man 手册的描述，这两个的功能是一样的。它的用法是这样的&lt;/p&gt;&lt;pre&gt;&lt;code&gt;data = ptrace(PTRACE_PEEKTEXT,pid,addr,0);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即从子进程（由 pid 标识）的 addr 内存地址处取出对应字长 (64 位为 8 字节，32 位 4 字节) 的数据，做为返回值。也就是说，读取一次能得到八个字符。现在如果我们要取得从 &lt;code&gt;base_addr&lt;/code&gt; 地址开始的一个字符串，那么我们只要 8 个字节 8 个字节读取，直到碰到 &lt;code&gt;\0&lt;/code&gt; 为止。把这个功能写成函数就是这样：（32 位系统不要忘记改那个 define）&lt;/p&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; WORD_LEN 8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;peek_str&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;pid_t&lt;/span&gt; pid,&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; base_addr,&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; target[])&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;union&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; word;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; str[WORD_LEN];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; data;&lt;span class=&quot;comment&quot;&gt;/* 利用 union 把 WORD_LEN 字节的整数变为字符数组 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; offset=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; done=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  target[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]=&lt;span class=&quot;string&quot;&gt;&#39;\0&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!done)&amp;#123;&lt;span class=&quot;comment&quot;&gt;/* 循环读取 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    data.word=ptrace(PTRACE_PEEKTEXT,pid,base_addr+offset,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;strncat&lt;/span&gt;(target,data.str,WORD_LEN);&lt;span class=&quot;comment&quot;&gt;/* 追加至多 WORD_LEN 个字符 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;WORD_LEN;i++)&lt;span class=&quot;comment&quot;&gt;/* 检查是否有 &#39;\0&#39;*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(data.str[i]==&lt;span class=&quot;string&quot;&gt;&#39;\0&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        done=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    offset+=WORD_LEN;&lt;span class=&quot;comment&quot;&gt;/* 准备读取下一个 WORD_LEN 字节 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;主程序的大 &lt;code&gt;while()&lt;/code&gt; 循环里的代码是这样的（我已经设置了 &lt;code&gt;PTRACE_O_TRACESYSGOOD&lt;/code&gt; 标记）：&lt;/p&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;wait4(pid,&amp;amp;sta,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&amp;amp;ru);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(WIFEXITED(sta))&amp;#123;&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Exited with code %d&quot;&lt;/span&gt;,WEXITSTATUS(sta));&lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(WIFSIGNALED(sta))&amp;#123;&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Terminated by signal: %s&quot;&lt;/span&gt;,strsignal(WTERMSIG(sta)));&lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sig_no;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(WIFSTOPPED(sta))sig_no=WSTOPSIG(sta);&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Unknown Status&quot;&lt;/span&gt;);&lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(sig_no!=(SIGTRAP|&lt;span class=&quot;number&quot;&gt;0x80&lt;/span&gt;))&amp;#123;ptrace(PTRACE_SYSCALL,pid,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,sig_no);&lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (intocall)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; user_regs_struct reg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ptrace(PTRACE_GETREGS,pid,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&amp;amp;reg);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (reg.orig_rax==SYS_open)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; file[&lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    peek_str(pid,reg.rdi,file);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;open() opened: %s\n&quot;&lt;/span&gt;,file);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;intocall^=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ptrace(PTRACE_SYSCALL,pid,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;在这里我使用的 &lt;code&gt;PTRACE_GETREGS&lt;/code&gt; 和&lt;code&gt;user_regs_struct&lt;/code&gt;结构来一次性获得所有寄存器的值，该结构定义于 &lt;code&gt;sys/user.h&lt;/code&gt; 头文件中。另外，我还使用了 &lt;code&gt;SYS_open&lt;/code&gt; 来判断系统调用号，避免了 Magic Number。&lt;code&gt;SYS_*&lt;/code&gt;宏定义于 &lt;code&gt;sys/syscall.h&lt;/code&gt; 头文件中。传递 RDI 寄存器也很容易理解，查询 &lt;code&gt;man 2 open&lt;/code&gt; 可知 open 系统调用的路径是第一个参数。现在，重新编译你的&lt;code&gt;target&lt;/code&gt;，不要加&lt;code&gt;-static&lt;/code&gt;, 然后运行，你应该能看到类似这样的输出。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Parent started
Child PiD == 4717
Child exec...
Child execve() returned with 0
open() opened: /usr/lib/tls/x86_64/libc.so.6
open() opened: /usr/lib/tls/libc.so.6
open() opened: /usr/lib/x86_64/libc.so.6
open() opened: /usr/lib/libc.so.6
Hello World!
Exited with code 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以很明显的看到程序搜索动态链接库的过程。&lt;br&gt;如果你觉得这还不够过瘾，那么你可以看 &lt;a href=&quot;http://www.kgdb.info/gdb/playing_with_ptrace_part_i/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Playing with ptrace, part1&lt;/a&gt;, 后面提供了一个配合使用&lt;code&gt;PTRACE_PEEKTEXT&lt;/code&gt; 和&lt;code&gt;PTRACE_POKETEXT&lt;/code&gt;来将 &lt;code&gt;write&lt;/code&gt; 输出的字符串反转的例子 &lt;/p&gt;&lt;h2 id=&quot;其他资料&quot;&gt;&lt;a href=&quot;# 其他资料&quot; class=&quot;headerlink&quot; title=&quot;其他资料&quot;&gt;&lt;/a&gt; 其他资料 &lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://godorz.info/2011/02/how-debuggers-work-part-1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; 调试器是怎样工作的 &lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://linuxgazette.net/issue81/sandeep.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Process Tracing Using Ptrace&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;不是后记的后记&quot;&gt;&lt;a href=&quot;# 不是后记的后记&quot; class=&quot;headerlink&quot; title=&quot;不是后记的后记&quot;&gt;&lt;/a&gt; 不是后记的后记 &lt;/h2&gt;&lt;p&gt; 不知不觉已经写到 Part4 了，期间一边查资料一边写代码做验证一边写这篇文章，又发现了好多好多之前遗漏的信息和好文章。同时深深感觉自己真是个蒟蒻，好多东西觉得很重要，想讲却心有余而力不足，而且越来越像是在翻译 man 手册了……我是不是一开始就应该去翻译手册而不是写这系列文章呢？（笑）&lt;br&gt;下个 part 开始，估计就要暂时和 ptrce 说再见，然后和内存管理开始较劲了。&lt;/p&gt;</content>
    
    <summary type="html">
    
      Fourth part of serial of tutorial: Programming with PTRACE
    
    </summary>
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="Linux" scheme="http://recursiveg.me/tags/Linux/"/>
    
      <category term="PTRACE" scheme="http://recursiveg.me/tags/PTRACE/"/>
    
      <category term="教程" scheme="http://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Programming with PTRACE, Part3 - 进程的终止与信号</title>
    <link href="http://recursiveg.me/2014/05/programming-with-ptrace-part3/"/>
    <id>http://recursiveg.me/2014/05/programming-with-ptrace-part3/</id>
    <published>2014-05-25T10:26:20.000Z</published>
    <updated>2016-01-14T02:33:05.839Z</updated>
    
    <content type="html">&lt;p&gt;在 Part2 中，我们粗略了解了如何使用 &lt;code&gt;ptrace&lt;/code&gt; 获得系统调用信息，即在一个大循环里不断获取程序信息，如果程序退出则停止循环。当然，那个判断异常简陋，几乎无法处理任何特殊情况。我将在本 Part 中详细解说各种异常情况的处理，同时讲解各种信号相关的问题。&lt;/p&gt;&lt;h2 id=&quot;一些重要的宏&quot;&gt;&lt;a href=&quot;# 一些重要的宏&quot; class=&quot;headerlink&quot; title=&quot;一些重要的宏&quot;&gt;&lt;/a&gt;一些重要的宏 &lt;/h2&gt;&lt;p&gt; 在使用 &lt;code&gt;wait4&lt;/code&gt; 后，程序的信息被存储在 &lt;code&gt;sta&lt;/code&gt; 变量中，这些信息被存储在这个整数的不同二进制位上，这儿有一系列宏用于帮我们提取这些信息。以下信息是我对 &lt;code&gt;man 3 wait&lt;/code&gt; 中相关部分的翻译, 同时参考了 &lt;a href=&quot;http://www.manualpages.de/OpenBSD/OpenBSD-5.0/man2/WIFEXITED.2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; 这个 &lt;/a&gt; 页面&lt;/p&gt;&lt;pre&gt;&lt;code&gt;WIFEXITED   如果进程正常退出，返回一个非 0 值(通常是进程调用了 `exit()` 或是 `_exit()`)
WIFSIGNALED 如果进程由于一个未被捕获的信号而被终止，返回一个非 0 值
WIFSTOPPED  当进程被停止 (非终止) 时，返回一个非 0 值(通常发生在当进程处于 `traced` 状态时)

WEXITSTATUS 当 `WIFEXITED` 为非 0 值，获得进程 `main()` 函数的返回值
WTERMSIG    如果 `WIFSIGNALED` 为非 0 值，获得引起进程终止的信号代码
WSTOPSIG    如果 `WIFSTOPPED` 为非 0 值，获得引起进程停止的信号代码
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;除了这六个，还有 &lt;code&gt;WIFCONTINUED&lt;/code&gt; 和&lt;code&gt;WCOREDUMP&lt;/code&gt;两个宏，不过我们用不到，我也没仔细研究，就不说了。&lt;br&gt;当进程自行终止时，&lt;code&gt;WIFEXITED&lt;/code&gt;即为 &lt;code&gt;true&lt;/code&gt;，配套使用&lt;code&gt;WEXITSTATUS&lt;/code&gt; 获得返回值，不做过多解释。当子进程进行系统调用时，&lt;code&gt;WIFSTOPPED&lt;/code&gt;为 &lt;code&gt;true&lt;/code&gt;, 同时&lt;code&gt;WSTOPSIG&lt;/code&gt; 等于 &lt;code&gt;SIGTRAP&lt;/code&gt;(信号代码为 7), 我们可以用这种方法区分&lt;code&gt;syscall-stop&lt;/code&gt; 和&lt;code&gt;signal-delivery-stop&lt;/code&gt;。当有一个外部信号要发送给子进程，这个信号会先到达父进程，使 &lt;code&gt;WIFSTOPPED&lt;/code&gt; 为&lt;code&gt;true&lt;/code&gt;，同时 &lt;code&gt;WSTOPSIG&lt;/code&gt; 等于该信号的信号代码。父进程可以选择将这个信号继续传递或是不传递，甚至传递另一个信号给子进程。一旦信号真正到达子进程，就进入子进程自己的处理流程或是系统默认动作，可能触发 &lt;code&gt;WIFSIGNALED&lt;/code&gt;，比如&lt;code&gt;SIGINT&lt;/code&gt;。&lt;br&gt; 在所有信号中，&lt;code&gt;SIGKILL&lt;/code&gt;是一个例外，它不会经过父进程引发 &lt;code&gt;WIFSTOPPED&lt;/code&gt;，而是直接传递到子进程，引发&lt;code&gt;WIFSIGNALED&lt;/code&gt;。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;信号的传递与修改&quot;&gt;&lt;a href=&quot;# 信号的传递与修改&quot; class=&quot;headerlink&quot; title=&quot;信号的传递与修改&quot;&gt;&lt;/a&gt; 信号的传递与修改 &lt;/h2&gt;&lt;p&gt; 之前提到，父进程需要将信号传递给子进程，这是由 &lt;code&gt;ptrace(PTRACE_SYSCALL,pid,0,0)&lt;/code&gt; 的第四个参数决定的。如果为 0, 就不传递信号，否则传递对应代码的信号，比如 &lt;code&gt;ptrace(PTRACE_SYSCALL,pid,0,9)&lt;/code&gt; 就将信号 9(SIGKILL)传递给了子进程。&lt;br&gt;修改信号简直信手拈来，传一个你想要传的信号即可。&lt;/p&gt;&lt;h2 id=&quot;strsignal- 和代码&quot;&gt;&lt;a href=&quot;#strsignal- 和代码&quot; class=&quot;headerlink&quot; title=&quot;strsignal()和代码&quot;&gt;&lt;/a&gt;strsignal()和代码 &lt;/h2&gt;&lt;p&gt;&lt;code&gt;strsignal()&lt;/code&gt; 接受一个整数参数，返回 &lt;code&gt;const char*&lt;/code&gt;，用于把信号代码变为对应的、人类可读的字符串描述，定义于&lt;code&gt;string.h&lt;/code&gt;。下面给出判断程序退出的代码：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;wait4(pid,&amp;amp;sta,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&amp;amp;ru);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(WIFEXITED(sta))&amp;#123;&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Exited with code %d&quot;&lt;/span&gt;,WEXITSTATUS(sta));&lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(WIFSIGNALED(sta))&amp;#123;&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Terminated by signal: %s&quot;&lt;/span&gt;,strsignal(WTERMSIG(sta)));&lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sig_no;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(WIFSTOPPED(sta))sig_no=WSTOPSIG(sta);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(sig_no==SIGTRAP)sig_no=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ptrace(PTRACE_SYSCALL,pid,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,sig_no);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 id=&quot;来自 ptrace 的高级选项&quot;&gt;&lt;a href=&quot;# 来自 ptrace 的高级选项&quot; class=&quot;headerlink&quot; title=&quot;来自 ptrace 的高级选项&quot;&gt;&lt;/a&gt; 来自 ptrace 的高级选项 &lt;/h2&gt;&lt;p&gt; 你也许会纠结，如果外部传递了一个 &lt;code&gt;SIGTRAP&lt;/code&gt; 信号，那么如何分辨呢？答案是使用 &lt;code&gt;PTRACE_SETOPTIONS&lt;/code&gt; 设置 &lt;code&gt;PTRACE_O_TRACESYSGOOD&lt;/code&gt; 标记，即在 while 之前，第一个 wait 之后，第一个 &lt;code&gt;PTRACE_SYSCALL&lt;/code&gt; 之前，使用 &lt;code&gt;ptrace(PTRACE_SETOPTIONS,pid,0,PTRACE_O_TRACESYSGOOD)&lt;/code&gt;。这会使得&lt;code&gt;syscall-stop&lt;/code&gt; 导致的 &lt;code&gt;WSTOPSIG&lt;/code&gt; 从&lt;code&gt;SIGTRAP&lt;/code&gt;变为 &lt;code&gt;SIGTRAP|0x80&lt;/code&gt;，而普通的来自外部的&lt;code&gt;SIGTRAP&lt;/code&gt; 依然是&lt;code&gt;SIGTRAP&lt;/code&gt;。&lt;/p&gt;</content>
    
    <summary type="html">
    
      Third part of serial of tutorial: Programming with PTRACE
    
    </summary>
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="Linux" scheme="http://recursiveg.me/tags/Linux/"/>
    
      <category term="PTRACE" scheme="http://recursiveg.me/tags/PTRACE/"/>
    
      <category term="教程" scheme="http://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Programming with PTRACE, Part2 - 系统调用入门</title>
    <link href="http://recursiveg.me/2014/04/programming-with-ptrace-part2/"/>
    <id>http://recursiveg.me/2014/04/programming-with-ptrace-part2/</id>
    <published>2014-04-20T12:00:19.000Z</published>
    <updated>2016-01-14T02:33:05.839Z</updated>
    
    <content type="html">&lt;p&gt;在这部分，我会介绍如何使用 ptrace 监控子进程的系统调用。我先将完整代码列在开头，你现在十有八九看不懂它，但我希望你在看完这篇文章后能彻底理解这段代码。（这段代码在 64 位系统上有效，32 位系统请参照最后 &lt;code&gt; 给 32 位系统的 Tip&lt;/code&gt;手动修改源代码）&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;figcaption&gt;&lt;span&gt;demo4.c&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/ptrace.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/resource.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/reg.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Parent started&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;pid_t&lt;/span&gt; pid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  pid=fork();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (pid&amp;lt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;fork() failed&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (pid==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ptrace(PTRACE_TRACEME,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Child sleeping...&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sleep(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Child exec...&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    execlp(&lt;span class=&quot;string&quot;&gt;&quot;./target&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;target&quot;&lt;/span&gt;,&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Child PiD == %d\n&quot;&lt;/span&gt;,pid);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sta=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; rusage ru;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait4(pid,&amp;amp;sta,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&amp;amp;ru);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; rax_rt=ptrace(PTRACE_PEEKUSER,pid,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;*RAX,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Child execve() returned with %ld\n&quot;&lt;/span&gt;,rax_rt);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ptrace(PTRACE_SYSCALL,pid,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; intocall=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      wait4(pid,&amp;amp;sta,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&amp;amp;ru);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (WIFEXITED(sta))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Child Exited&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; _ORIG_RAX=ptrace(PTRACE_PEEKUSER,pid,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;*ORIG_RAX,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; _RAX=ptrace(PTRACE_PEEKUSER,pid,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;*RAX,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (intocall)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Entering SYSCALL %ld ....&quot;&lt;/span&gt;,_ORIG_RAX);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        intocall=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Exited with %ld\n&quot;&lt;/span&gt;,_RAX);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        intocall=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      ptrace(PTRACE_SYSCALL,pid,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;h2 id=&quot;运行我们的程序&quot;&gt;&lt;a href=&quot;# 运行我们的程序&quot; class=&quot;headerlink&quot; title=&quot;运行我们的程序&quot;&gt;&lt;/a&gt;运行我们的程序 &lt;/h2&gt;&lt;p&gt; 当然，如果你试图直接编译并运行上面这段程序肯定是失败的，因为你缺少一个用于被执行的“target”（就是 execlp 里的那个）。在这里，我们的第一个 target 是最经典的“Hello World!”程序：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;figcaption&gt;&lt;span&gt;target.c&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;然后，我建议你静态方式进行链接：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;gcc -static target.c -o target
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意到我这里使用了 &lt;code&gt;-static&lt;/code&gt; 参数，它的作用是将 c 运行时库静态链接入可执行文件中。你可以比较一下用两种方式编译的文件大小（几 K 和几百 K 的区别）。虽然用动态链接也可以，但是会和我之后的输出有一点点出入（因为动态链接文件需要根据环境变量搜索动态库）。现在把 &lt;code&gt;target&lt;/code&gt; 和&lt;code&gt;demo4.c&lt;/code&gt;放在同一目录下，然后&lt;/p&gt;&lt;pre&gt;&lt;code&gt;gcc demo4.c -o demo4 &amp;amp;&amp;amp; ./demo4
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果运行正确，你应该看到类似如下的输出&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Parent started
Child PiD == 9702
Child sleeping...
Child exec...
Child execve() returned with 0
Entering SYSCALL 63 .... Exited with 0
Entering SYSCALL 12 .... Exited with 31248384
Entering SYSCALL 12 .... Exited with 31252928
Entering SYSCALL 158 .... Exited with 0
Entering SYSCALL 89 .... Exited with 55
Entering SYSCALL 12 .... Exited with 31388096
Entering SYSCALL 12 .... Exited with 31391744
Entering SYSCALL 5 .... Exited with 0
Entering SYSCALL 9 .... Exited with 140378408579072
Hello World!
Entering SYSCALL 1 .... Exited with 13
Entering SYSCALL 231 .... Child Exited
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;深入这段代码&quot;&gt;&lt;a href=&quot;# 深入这段代码&quot; class=&quot;headerlink&quot; title=&quot;深入这段代码&quot;&gt;&lt;/a&gt;深入这段代码 &lt;/h2&gt;&lt;p&gt; 我先介绍一下各个头文件的用途：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;stdio.h&lt;/code&gt;：（如果你不知道这个文件是干嘛的请重学 C 语言）&lt;/li&gt;&lt;li&gt;&lt;code&gt;unistd.h&lt;/code&gt;：提供 &lt;code&gt;fork()&lt;/code&gt;、&lt;code&gt;pid_t&lt;/code&gt;、&lt;code&gt;execlp()&lt;/code&gt;、&lt;code&gt;sleep()&lt;/code&gt; 等&lt;/li&gt;&lt;li&gt;&lt;code&gt;sys/ptrace.h&lt;/code&gt;：提供 ptrace 相关函数和宏定义 &lt;/li&gt;&lt;li&gt;&lt;code&gt;sys/wait.h&lt;/code&gt;：提供&lt;code&gt;wait4()&lt;/code&gt; 和&lt;code&gt;WIFEXITED&lt;/code&gt;宏 &lt;/li&gt;&lt;li&gt;&lt;code&gt;sys/resource.h&lt;/code&gt;：提供&lt;code&gt;rusage&lt;/code&gt; 结构定义 &lt;/li&gt;&lt;li&gt;&lt;code&gt;sys/reg.h&lt;/code&gt;：提供寄存器系列宏定义（&lt;code&gt;ORIG_RAX&lt;/code&gt; 等）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;看到代码的第 15 行，一个巨大的 &lt;code&gt;if...else...&lt;/code&gt; 将代码清晰地分成了父子进程两个部分，16 行的 &lt;code&gt;ptrace(PTRACE_TRACEME,0,0,0);&lt;/code&gt; 首先吸引了我们的注意力。（为什么有一种在写春游作文的感觉）这个调用使得子进程被标记为 &lt;code&gt;TRACED&lt;/code&gt; 并且使系统内核在子进程调用 exec 族函数 &lt;em&gt; 之后 &lt;/em&gt; 通知父进程，这也是为什么 17 到 19 行的系统调用没有被追踪到的原因。&lt;br&gt;再看父进程部分，由于系统调用是一个从用户态到内核态再到用户态的过程，所以每进行一次系统调用都会触发两次 &lt;code&gt;syscall_stop&lt;/code&gt;, 分别是进入时的&lt;code&gt;syscall_enter_stop&lt;/code&gt; 和离开内核时的 &lt;code&gt;syscall_exit_stop&lt;/code&gt;。这种子进程的状态的变化可以在父进程中使用&lt;code&gt;wait()&lt;/code&gt;、&lt;code&gt;waitpid()&lt;/code&gt;、&lt;code&gt;wait4()&lt;/code&gt; 等一票函数完成（还记得 part1 课后阅读中的僵尸进程么？）。值得注意的是，第一次的状态变化是由 &lt;code&gt;execve()&lt;/code&gt; 调用返回导致的 &lt;code&gt;syscall_exit_stop&lt;/code&gt;，所以我在 25 到 29 行单独做了处理。我喜欢使用&lt;code&gt;wait4()&lt;/code&gt; 的原因是它还可以获得子进程的当前资源占用情况（就是那个 &lt;code&gt;rusage&lt;/code&gt; 结构），这对于了解进程资源使用情况非常有用，只不过现在还用不到（我应该会在之后专门开几个 part 来讲系统资源的限制），所以我们只要关注那个 &lt;code&gt;sta&lt;/code&gt; 就可以了。&lt;br&gt;注意下面那个大的 &lt;code&gt;while&lt;/code&gt; 循环，在每次循环的开头等待，一旦 &lt;code&gt;wait4()&lt;/code&gt; 返回，子进程就已经进入了暂停的状态（其实是内核给子进程发送了 &lt;code&gt;SIGTRAP&lt;/code&gt; 信号，但因为子进程处于 &lt;code&gt;TRACED&lt;/code&gt; 状态，所以这个信号被转交给了父进程，使父进程的 &lt;code&gt;wait4()&lt;/code&gt; 返回，但这也意味着由其他方式引起的信号 (比如&lt;code&gt;kill&lt;/code&gt; 命令)也会引起 wait4 的返回）。接着在 32 行使用 &lt;code&gt;WIFEXITED&lt;/code&gt; 宏加上 wait4 收集的状态信息 &lt;code&gt;sta&lt;/code&gt; 判断子进程是否已经退出，如果已退出，那么父进程也从循环中退出。当然这是一个非常粗糙的处理方式，更具完整的处理流程将在之后的 part 里介绍。接着，我们就可以使用各种各样的命令来调戏子进程了，这里我们只是简单的取得系统调用号和返回值。最后，在 45 行，让子进程继续执行，并要求子进程在下一个系统调用（进入或返回）停住，然后父进程开始等待下一次的 &lt;code&gt;syscall_stop&lt;/code&gt;。因为一次系统调用会导致两次&lt;code&gt;syscall_stop&lt;/code&gt;，所以我使用变量&lt;code&gt;intocall&lt;/code&gt; 来分辨，并且在 38 到 44 行打印出不同的提示信息。顺带提一下，在输出中，&lt;code&gt;Hello World!&lt;/code&gt;应该输出在 &lt;code&gt;Entering SYSCALL 1&lt;/code&gt; 和&lt;code&gt;Exited with 13&lt;/code&gt;中间，但因为缓冲区刷新的问题所以被输出到了前面。&lt;/p&gt;&lt;p&gt;终于到最激动人心的部分了！36、37 两行代码是最重要的部分，可以看出，他们做的工作是差不多的，都是从子进程的内存空间中取一些数据。为了解释好这两行，我要讲一讲系统调用的调用过程。系统调用和普通的函数调用差不多，函数调用是将参数以约定好的顺序压入栈中，而系统调用则发生了一个类似上下文切换的过程：程序将需要调用的系统调用的调用号以及参数存入寄存器中，然后将所有寄存器存入栈中，进入内核态后，内核从栈中取得调用号和调用参数，并将返回值写入栈中对应寄存器的位置，最后还原寄存器的值并返回用户态，于是返回值就这样被“还原”到了寄存器里。在 x86-64 平台上，负责传递系统调用号和返回值的都是 &lt;code&gt;RAX&lt;/code&gt; 寄存器，也就是说返回值会覆盖调用号，为了在系统调用返回时也能知道调用号，&lt;code&gt;RAX&lt;/code&gt;寄存器在保存时被入栈两遍，一个是用于保存返回值的 &lt;code&gt;RAX&lt;/code&gt;，另一个是负责保存调用号的&lt;code&gt;ORIG_RAX&lt;/code&gt;。现在，我们要获得寄存器的值，只要访问栈中的对应位置就可以了。而系统内核又会在系统调用时将栈中的这些信息复制一遍到一个叫做&lt;code&gt;u-area&lt;/code&gt;(USER Area) 的内存区域。在 &lt;code&gt;sys/reg.h&lt;/code&gt; 头文件中定义了各寄存器保存时在 &lt;code&gt;u-area&lt;/code&gt; 中的顺序，乘以每个寄存器的长度（64 位系统自然就是 8 了嘛~~）就得到了我们所要访问的字节偏移量，&lt;code&gt;PTRACE_PEEKUSER&lt;/code&gt;要求 ptrace 从指定偏移取出一个寄存器长度的数据（也就是 8 字节）作为返回值，于是 &lt;code&gt;ptrace(PTRACE_PEEKUSER,pid,8*ORIG_RAX,0)&lt;/code&gt; 就能获得系统调用号啦！&lt;/p&gt;&lt;h2 id=&quot;给 32 位系统的 Tip&quot;&gt;&lt;a href=&quot;# 给 32 位系统的 Tip&quot; class=&quot;headerlink&quot; title=&quot;给 32 位系统的 Tip&quot;&gt;&lt;/a&gt;给 32 位系统的 Tip&lt;/h2&gt;&lt;p&gt;要让程序通过编译，需要做两个改动：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;在 &lt;code&gt;int main()&lt;/code&gt; 之前加入这两个预处理命令：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#define RAX EAX
#define ORIG_RAX ORIG_EAX
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&lt;li&gt;把 26、36、37 行 ptrace 第三个参数中的 8 全部改成 4&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这是因为 32 位系统的寄存器长度是 4 字节，而且负责传递系统调用号和返回值的是 &lt;code&gt;EAX&lt;/code&gt; 寄存器。&lt;/p&gt;&lt;h2 id=&quot;其他资料&quot;&gt;&lt;a href=&quot;# 其他资料&quot; class=&quot;headerlink&quot; title=&quot;其他资料&quot;&gt;&lt;/a&gt;其他资料 &lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://sourceforge.net/projects/strace/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;strace&lt;/a&gt; 是一个用于监视并输出某程序系统调用情况的工具，比如 &lt;code&gt;strace ./target&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://man7.org/linux/man-pages/man7/signal.7.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux 信号代码&lt;/a&gt;：也可以通过查 man 手册得到&lt;code&gt;man 7 signal&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://www.kgdb.info/gdb/playing_with_ptrace_part_i/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Playing with ptrace&lt;/a&gt;：Pradeep Padala 的关于 ptrace 的文章。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://blog.rchapman.org/post/36801038863/linux-system-call-table-for-x86-64&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;x86_64 系统调用号列表&lt;/a&gt;：也可以在&lt;code&gt;asm/unistd_64.h&lt;/code&gt; 头文件中找到，&lt;code&gt;asm/unistd_32.h&lt;/code&gt;就是 32 位的 &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://www.hep.wisc.edu/~pinghc/Process_Memory.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Process and Process Memory&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt; 有问题或意见请务必留言啊啊啊啊~&lt;/strong&gt;没人留言都不知道评论系统是否工作正常&lt;/li&gt;&lt;/ul&gt;</content>
    
    <summary type="html">
    
      Second part of serial of tutorial: Programming with PTRACE
    
    </summary>
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="Linux" scheme="http://recursiveg.me/tags/Linux/"/>
    
      <category term="PTRACE" scheme="http://recursiveg.me/tags/PTRACE/"/>
    
      <category term="教程" scheme="http://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Programming with PTRACE, Part1 - 起步</title>
    <link href="http://recursiveg.me/2014/04/programming-with-ptrace-part1/"/>
    <id>http://recursiveg.me/2014/04/programming-with-ptrace-part1/</id>
    <published>2014-04-17T13:16:29.000Z</published>
    <updated>2016-01-14T02:33:05.839Z</updated>
    
    <content type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;# 前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言 &lt;/h2&gt;&lt;p&gt; 本人作为一个信息学竞赛的参与者，在很久之前曾经试图自己写过一个 Online Judge 系统（允许用户上传源代码并在服务器上编译运行），考虑到安全因素，必须要对程序的行为进行限制，因此对 ptrace 进行了一番研究。网上有一份关于 ptrace 的很好的教程（&lt;a href=&quot;http://www.kgdb.info/gdb/playing_with_ptrace_part_i/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Playing with ptrace&lt;/a&gt;）, 但是时间有点久了，而且没有涉及 64 位操作系统。因此，我决定写这份教程，基于 64 位 Linux，尽力介绍一些新加入的功能，同时兼顾一下 32 位系统。另外，由于一开始的目的是“对程序的行为进行 &lt;em&gt; 限制 &lt;/em&gt;”，所以不会涉及到诸如设置断点之类的内容，相反，可能会涉及到其他关于系统资源管理的内容。&lt;br&gt;&lt;code&gt;ptrace()&lt;/code&gt; 是一个由 Linux 内核提供的系统调用。它允许一个用户态进程检查、修改另一个进程的内存和寄存器。这种技术被广泛用于 &lt;code&gt;gdb&lt;/code&gt; 等调试器中。尽管这系列文章的标题叫做“Programming with PTRACE”，但在第一部分中，我将着重介绍 Linux 的进程和相关的几个重要函数。&lt;/p&gt;&lt;h2 id=&quot;fork-vfork- 与 -clone&quot;&gt;&lt;a href=&quot;#fork-vfork- 与 -clone&quot; class=&quot;headerlink&quot; title=&quot;fork(), vfork() 与 clone()&quot;&gt;&lt;/a&gt;fork(), vfork() 与 clone()&lt;/h2&gt;&lt;p&gt;在 Linux 中，每一个进程都有一个唯一的编号，被称作 &lt;code&gt;pid&lt;/code&gt;(Process ID)。在 Linux 中，进程不能凭空产生（&lt;code&gt;init&lt;/code&gt; 进程是个例外），只能从一个已有进程衍生出来。原来的进程被称做父进程，衍生出来的进程叫子进程。一个系统中所有进程以父子关系相连接，形成一棵树，这棵“树”的树根就是 &lt;code&gt;init&lt;/code&gt; 进程，它是在系统启动时被直接启动的，因此它没有父进程。并且系统中所有其他进程都直接或间接地是它的子进程。在 Linux 系统中，实现“把一个进程变成两个”这一功能的有三个系统调用，即 &lt;code&gt;fork()&lt;/code&gt;、&lt;code&gt;vfork()&lt;/code&gt; 和&lt;code&gt;clone()&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;code&gt;fork()&lt;/code&gt;的工作流程的确和叉子有几分相似之处，它将当前进程所有数据复制一份，产生一个和父进程一模一样的子进程。并在两个进程中返回不同的返回值。比如这段代码：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;figcaption&gt;&lt;span&gt;demo1.c&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc,&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; return_val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Program started.&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return_val=fork();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;fork() returned %d\n&quot;&lt;/span&gt;,return_val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;将会输出&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Program started.
fork() returned 5768
fork() returned 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很明显地可以看到，&lt;code&gt;puts()&lt;/code&gt;只被调用了一次而 &lt;code&gt;printf()&lt;/code&gt; 被调用了两次，这说明在 &lt;code&gt;fork()&lt;/code&gt; 前的一个进程变成了两个，而且 &lt;code&gt;fork()&lt;/code&gt; 在两个进程中有不同的返回值（这就是“调用一次，返回两次”的来历）。&lt;code&gt;fork()&lt;/code&gt;会返回 0 给子进程，返回子进程的 pid 给父进程，因此，我们很容易判断出 &lt;code&gt;fork() returned 0&lt;/code&gt; 是由子进程打印的。在实际应用中，也通过 &lt;code&gt;if&lt;/code&gt; 语句判断返回值的方法来决定执行不同的代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;int pid=fork();
if (pid==0){// 子进程的工作}else{// 父进程的工作}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一般来说，子进程的工作就是调用 &lt;code&gt;exec&lt;/code&gt; 族函数，启动另一个程序 (把自己替换掉)。如果子进程还在执行而父进程已结束，那么它就成为“孤儿”进程，成为&lt;code&gt;init&lt;/code&gt; 进程的子进程。另外，请不要纠结那个 &lt;code&gt;if&lt;/code&gt; 判断带来的性能损失，Linux 的内核开发者都不纠结，你纠结什么呢？&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;vfork()&lt;/code&gt;的存在是一个历史遗留问题，在很久很久以前，&lt;code&gt;fork()&lt;/code&gt;调用是没有 &lt;a href=&quot;http://en.wikipedia.org/wiki/Copy_on_write&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CoW&lt;/a&gt; 机制的，如果 fork 出的一个子进程又立即调用了 &lt;code&gt;exec&lt;/code&gt; 族函数，那么辛辛苦苦拷贝出来的内存又立马被扔进了废纸篓里（这个比喻可能不太恰当，毕竟被从内存里抹去的数据是捡不回来的）。Linux 的开发者当然不会允许效率如此低下的事情发生，于是他们创造出了 &lt;code&gt;vfork()&lt;/code&gt;。它和&lt;code&gt;fork()&lt;/code&gt; 最大的差别在于，vfork 出的子进程，在执行 &lt;code&gt;exec&lt;/code&gt; 族函数前和父进程 &lt;strong&gt; 共享同一块内存 &lt;/strong&gt;。也就是说，子进程对内存的修改也会体现在父进程上。只有当子进程执行了&lt;code&gt;exec&lt;/code&gt; 族函数，它才真正拥有一块属于自己的内存。这样就节省了 &lt;code&gt;fork()&lt;/code&gt; 中那个无意义的内存拷贝。现在因为有了 CoW，&lt;code&gt;fork()&lt;/code&gt;和 &lt;code&gt;vfork()&lt;/code&gt; 已经几乎没有性能差异了。&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;figcaption&gt;&lt;span&gt;demo2.c&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc,&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; pid,x=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;X=%d\n&quot;&lt;/span&gt;,x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pid=vfork();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (pid==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        x+=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Child-X=%d\n&quot;&lt;/span&gt;,x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        x+=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Parent-X=%d\n&quot;&lt;/span&gt;,x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _exit(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这段代码输出，而且一定输出&lt;/p&gt;&lt;pre&gt;&lt;code&gt;X=1
Child-X=2
Parent-X=3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很好地说明了内存的共享，如果换成 &lt;code&gt;fork()&lt;/code&gt;，那么父子进程就都输出 X=2 了。&lt;br&gt; 也许有人会问，为什么不可能是父进程先输出呢？这涉及到 &lt;code&gt;vfork()&lt;/code&gt; 的另一个特点。如果使用 &lt;code&gt;vfork()&lt;/code&gt; 创建进程，那么在子进程使用 &lt;code&gt;exec&lt;/code&gt; 族函数或是 &lt;code&gt;_exit()&lt;/code&gt;(这就是我为什么不用&lt;code&gt;return 0&lt;/code&gt; 的原因，但没有详细研究过原因，求大神指教)之前，父进程会始终等待 vfork 返回。比如以下代码：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;figcaption&gt;&lt;span&gt;demo3.c&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc,&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; pid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pid=vfork();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (pid==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Child Sleeping...&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sleep(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Child Exit.&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Parent Exit.&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _exit(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;输出&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Child Sleeping...
// 这里等了 3 秒
Child Exit.
Parent Exit.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而改成 &lt;code&gt;fork()&lt;/code&gt; 后输出&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Parent Exit.
Child Sleeping...
~$
// 这里等了 3 秒
Child Exit.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以明显看出两者差别。(给 Windows 用户的 Tip: 那个 &lt;code&gt;~$&lt;/code&gt; 是 Linux 终端的提示符，类似 cmd)&lt;/p&gt;&lt;p&gt;&lt;code&gt;clone()&lt;/code&gt;函数提供了更多的控制选项，可自由决定要执行哪个代码片段甚至是哪些内存共享，哪些内存要复制。但我没怎么用过，不敢乱说，有兴趣的读者可以自行实验。&lt;/p&gt;&lt;h2 id=&quot;令人困惑的 exec 族函数&quot;&gt;&lt;a href=&quot;# 令人困惑的 exec 族函数&quot; class=&quot;headerlink&quot; title=&quot;令人困惑的 exec 族函数&quot;&gt;&lt;/a&gt;令人困惑的 exec 族函数 &lt;/h2&gt;&lt;p&gt; 我在这篇文章之前的部分 N 次提到了一个叫 &lt;code&gt;exec 族函数&lt;/code&gt; 的东西，如果我们 man 手册里查找(&lt;code&gt;man 3 exec&lt;/code&gt;)，我们会得到一大堆函数（是不是开始感到困惑了？）：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;int execl  (const char *path, const char *arg, ...);
int execlp (const char *file, const char *arg, ...);
int execle (const char *path, const char *arg, ..., char * const envp[]);
int execv  (const char *path, char *const argv[]);
int execve (const char *path, char *const argv[], char *const envp[]);
int execvp (const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[], char *const envp[]);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;exec 族函数 &lt;/code&gt; 就是这一“族”函数，全部以 exec 打头，他们都是对系统调用 &lt;code&gt;execve()&lt;/code&gt; 的包装。他们的作用就是把某个进程（通常是 fork 出来的子进程）从里到外，完完整整，包括代码、堆栈，全部换成另一个程序，然后从头开始运行。它们的调用效果是一样的，区别在于调用方式。总的来说，大致的参数顺序是这样的：&lt;code&gt;exec*(可执行文件路径，程序参数表 [, 环境变量表])&lt;/code&gt;，其中环境变量表是可选的。&lt;br&gt; 去掉打头的 exec，带 &lt;code&gt;l&lt;/code&gt;（代表 list）的函数使用了一种比较接近人类方法来表示程序参数表，即以&lt;code&gt;NULL&lt;/code&gt; 作为结尾（man 手册推荐使用 &lt;code&gt;(char *)0&lt;/code&gt;）的变参列表；而带&lt;code&gt;v&lt;/code&gt;(代表 vector) 的则使用一个字符串数组来表示程序参数表，就像 &lt;code&gt;int main(int argc,char *argv[])&lt;/code&gt; 里的 &lt;code&gt;argv&lt;/code&gt; 一样。&lt;br&gt;如果结尾带 &lt;code&gt;e&lt;/code&gt;（environment），则该函数接受一个字符串数组表示的环境变量表；反之，则会默认传递所有当前环境变量。如果带有&lt;code&gt;p&lt;/code&gt;，那么你就不必在第一个参数中列出完整路径，系统会自动检查当前目录和&lt;code&gt;PATH&lt;/code&gt; 环境变量（如果你非要手贱加个路径分割符进去，那么系统就会把它当成完整路径）。&lt;br&gt;值得一提的是，不管你使用那种方法表示程序参数表，第 0 个参数（C 的数组下标从 0 开始，记得么？）都应当和可执行文件路径保持一致，虽然不一致依然可以正确运行，但有可能出现奇奇怪怪的问题。（博主继续偷懒，欢迎各位读者当小白鼠自行实验）。如果你已经混乱了，或是直接跳过了上面的一大堆说明直接到了这，那么我推荐你直接使用 &lt;code&gt;execlp()&lt;/code&gt; 函数，比如说，你要运行一个叫 &lt;code&gt;foo&lt;/code&gt; 的程序：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;execlp(&amp;quot;foo&amp;quot;,&amp;quot;foo&amp;quot;,NULL);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或是列举出根目录下所有文件：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;execlp(&amp;quot;ls&amp;quot;,&amp;quot;ls&amp;quot;,&amp;quot;/&amp;quot;,NULL);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;继续之前的其他一些准备&quot;&gt;&lt;a href=&quot;# 继续之前的其他一些准备&quot; class=&quot;headerlink&quot; title=&quot;继续之前的其他一些准备&quot;&gt;&lt;/a&gt;继续之前的其他一些准备 &lt;/h2&gt;&lt;p&gt; 从本系列的下一篇开始，我将要开始讨论 &lt;code&gt;ptraec()&lt;/code&gt; 这一强大的工具。但是，如果你有一下现象之一的，我建议你 &lt;em&gt; 不要 &lt;/em&gt; 继续阅读并且从头学习有关 &lt;code&gt;*nix&lt;/code&gt; 系列系统的知识：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;基本看不懂这篇文章的 &lt;/li&gt;&lt;li&gt; 不会 C 语言的 &lt;/li&gt;&lt;li&gt; 狂热的 Windows 爱好者 &lt;/li&gt;&lt;li&gt; 不会使用 &lt;a href=&quot;https://www.google.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Google&lt;/a&gt; 的&lt;/li&gt;&lt;li&gt;没有 IDE 就不会编译程序的 &lt;/li&gt;&lt;li&gt; 没有听说过 &lt;code&gt; 寄存器 &lt;/code&gt;，&lt;code&gt; 堆栈 &lt;/code&gt; 的&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;另外，&lt;code&gt;ptrace()&lt;/code&gt;相当接近系统底层，对内核版本，系统构架，指令长度，库头文件等有相当大的依赖性，如果你还在使用 2.x 系列的内核，你可能在之后遇到问题，因为一些功能在新版本内核才被加入。我在这里列出我的编程环境：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;系统: ArchLinux x86_64&lt;/li&gt;&lt;li&gt;内核: Linux 3.14.1&lt;/li&gt;&lt;li&gt;glibc 2.19&lt;/li&gt;&lt;li&gt;gcc 4.8.2&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;另外，这里有更多关于进程的文章 &lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/vamei/archive/2012/09/20/2694466.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux 进程基础&lt;/a&gt; （我觉得其中关于食谱的那个比喻不太恰当，也许程序和进程的关系更像类和类的实例的关系？）&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/linux/l-linux-process-management/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux 进程管理剖析&lt;/a&gt; (IBM developerWorks 是我超喜欢的一个网站，有相当多高质量的文章)&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://coolshell.cn/articles/656.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux 的僵尸(zombie) 进程&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</content>
    
    <summary type="html">
    
      First part of serial of tutorial: Programming with PTRACE
    
    </summary>
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="Linux" scheme="http://recursiveg.me/tags/Linux/"/>
    
      <category term="PTRACE" scheme="http://recursiveg.me/tags/PTRACE/"/>
    
      <category term="教程" scheme="http://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>有屏幕的地方就有烂苹果</title>
    <link href="http://recursiveg.me/2014/03/bad-apple-character-player/"/>
    <id>http://recursiveg.me/2014/03/bad-apple-character-player/</id>
    <published>2014-03-19T11:55:49.000Z</published>
    <updated>2016-01-14T02:33:05.839Z</updated>
    
    <content type="html">&lt;p&gt;如果你还不知道 Bad Apple 是什么东西，请移步 &lt;a href=&quot;http://zh.wikipedia.org/wiki/Bad_apple!!&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; 这里 &lt;/a&gt;&lt;br&gt; 播放的原理很简单，就是不停的打印清屏再打印清屏。任何一个略有编程基础的人都能做到。比较令人头大的是如何把原视频转化为一个易于解析而且又不占地方的文件。&lt;br&gt;其实，借助 &lt;code&gt;FFmpeg&lt;/code&gt;、&lt;code&gt;ImageMagick&lt;/code&gt; 和一点点的编程小技巧就可以轻松完成。&lt;/p&gt;&lt;p&gt;第一步当然是要去下一个视频文件，我已经下好了，叫做 &lt;code&gt;BadApple.mkv&lt;/code&gt;。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt; 第二步要把视频变成一帧一帧的图片，请出 FFmpeg 来帮忙:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ffmpeg -i BadApple.mkv -s 80x60 -r 15 Ba%d.png
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后你就会得到 &lt;code&gt;Ba1.png Ba2.png Ba3.png&lt;/code&gt; 等一大堆文件，这就是各帧了。注意我在这一步同时把大小缩小到了 80*60 和把帧速率调到了 15 帧每秒。&lt;/p&gt;&lt;p&gt;第三步用 ImageMagick 将图像转换成黑白图，然后再转换成 &lt;code&gt;xpm&lt;/code&gt; 格式。XPM 格式本质上是一个文本文档，可以直接被 &lt;code&gt;#include&lt;/code&gt;。我们这一步要用到一点点脚本技巧。&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; *.png&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  convert &lt;span class=&quot;variable&quot;&gt;$x&lt;/span&gt; -monochrome `basename &lt;span class=&quot;_&quot;&gt;-s&lt;/span&gt; .png &lt;span class=&quot;variable&quot;&gt;$x&lt;/span&gt;`.xpm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;done&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt; 最后写一段 C 语言小程序，利用游程编码进一步缩小文件体积。&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;xpm.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  FILE *f=fopen(&amp;quot;BA.dat&amp;quot;,&amp;quot;a&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  char count;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  int t=ARR[0][6]==&amp;apos;1&amp;apos;?1:2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  for(int i=1+t;i&amp;lt;61+t;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    count=1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for(int j=1;j&amp;lt;80;j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      if(ARR[i][j]==ARR[i][j-1])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        count++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(ARR[i][j]==&amp;apos;.&amp;apos;)count=-count;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fprintf(f,&amp;quot;%c&amp;quot;,count);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        count=1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(ARR[i][79]==&amp;apos; &amp;apos;)count=-count;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fprintf(f,&amp;quot;%c&amp;quot;,count);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fprintf(f,&amp;quot;%c&amp;quot;,0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  fclose(f);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;当然，离不了脚本和编译器的帮助，我这里使用了 &lt;code&gt;tcc&lt;/code&gt; 进行编译 &lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ((i=1; i&amp;lt;=3288; i++))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cp Ba&lt;span class=&quot;variable&quot;&gt;$i&lt;/span&gt;.xpm xpm.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  tcc -DARR=Ba&lt;span class=&quot;variable&quot;&gt;$i&lt;/span&gt; bad_apple.c &amp;amp;&amp;amp; ./a.out&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  rm xpm.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;done&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt; 其中，那个 3288 就是总帧数。这样就得到了一个 &lt;code&gt;BA.dat&lt;/code&gt; 文件。文件内容是一堆用二进制存储的数字，正数代表连续的白色，负数代表连续的黑色，零代表换行。一帧 60 行，总计 3288 帧。这样就把一个 80 多兆的视频压缩到了 900 多 K。有了数据文件剩下的就好办了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;未完待续。。。。。。&lt;/strong&gt;&lt;/p&gt;</content>
    
    <summary type="html">
    
      A short tutorial on creating a character-base animation
    
    </summary>
    
      <category term="ACG" scheme="http://recursiveg.me/categories/ACG/"/>
    
    
      <category term="技术宅" scheme="http://recursiveg.me/tags/%E6%8A%80%E6%9C%AF%E5%AE%85/"/>
    
      <category term="东方Project" scheme="http://recursiveg.me/tags/%E4%B8%9C%E6%96%B9Project/"/>
    
  </entry>
  
  <entry>
    <title>在 Linux 下使用 MinGW 静态交叉编译带有 zlib 的 libcurl</title>
    <link href="http://recursiveg.me/2014/02/how-to-cross-compile-libcurl-on-linux/"/>
    <id>http://recursiveg.me/2014/02/how-to-cross-compile-libcurl-on-linux/</id>
    <published>2014-02-28T13:17:41.000Z</published>
    <updated>2016-01-14T02:33:05.839Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;http://curl.haxx.se/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;libcurl&lt;/a&gt;是一个跨平台的、易用的、强大的网络库。在大部分 Linux 发行版中都有编译好的二进制包可供使用，Mac 系统更是将其作为了一个核心部件。但是在 Windows 平台上却需要手工编译，更不必说一些有特殊洁癖的人（比如说我）还特别讨厌多出来几个 DLL, 非要静态链接不可。本文作为我两个晚上折腾经历的一个小小总结，讲解如何在 Linux 下使用 MinGW 编译给 Windows 使用的 libcurl 静态库。&lt;/p&gt;&lt;h3 id=&quot;STEP1- 安装 MinGW 编译器&quot;&gt;&lt;a href=&quot;#STEP1- 安装 MinGW 编译器&quot; class=&quot;headerlink&quot; title=&quot;STEP1 安装 MinGW 编译器&quot;&gt;&lt;/a&gt;STEP1 安装 MinGW 编译器 &lt;/h3&gt;&lt;p&gt; 这步我不打算多说，大部分 Linux 发行版的仓库应该都有，以我的 ArchLinux 为例，执行：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;~# pacman -S mingw-w64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即可。如果你不需要交叉编译，要在 Windows 上直接编译，请自行去 SourceForge 上下载 Windows 版本。不要担心那个 &lt;code&gt;w64&lt;/code&gt; 是不是 64 位版本，它既可以编译 32 位又可以编译 64 位程序。还是以我的版本为例:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;~# pacman -Ql mingw-w64-gcc| grep &amp;apos;/usr/bin/.*gcc$&amp;apos;
mingw-w64-gcc /usr/bin/i686-w64-mingw32-gcc
mingw-w64-gcc /usr/bin/x86_64-w64-mingw32-gcc
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到有两个 gcc, 用 &lt;code&gt;i686-w64-mingw32-gcc&lt;/code&gt; 编译出来的程序就是 32 位的，而 &lt;code&gt;x86_64-w64-mingw32-gcc&lt;/code&gt; 编译出来的就是 64 位的。现在，随便写个 Hello World（你可以用我的&lt;a href=&quot;http://www.devinprogress.org/2012/12/helloworld/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hello World 代码&lt;/a&gt; ^_^），然后编译试试：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;i686-w64-mingw32-gcc hello_world.c -o hello_world.exe
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;把它拿到虚拟机或扔进 Wine 里，如果能正常运行，那么恭喜你，第一步完成了。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h3 id=&quot;STEP2- 下载源码&quot;&gt;&lt;a href=&quot;#STEP2- 下载源码&quot; class=&quot;headerlink&quot; title=&quot;STEP2 下载源码&quot;&gt;&lt;/a&gt;STEP2 下载源码 &lt;/h3&gt;&lt;p&gt; 很简单的步骤，如果自己搞不定的建议直接右上角。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://curl.haxx.se/download.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LibCurl&lt;/a&gt;: 最上面的 Source Archives&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://www.zlib.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;zLib&lt;/a&gt;: 请下 Source Code&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.openssl.org/source/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OpenSSL&lt;/a&gt;: 可选，如果没有必要就不要编译，会极大地增加文件体积 &lt;/li&gt;&lt;/ul&gt;&lt;p&gt; 把&lt;code&gt;curl-7.35.0&lt;/code&gt;和 &lt;code&gt;zlib-1.2.8&lt;/code&gt;(可能还有&lt;code&gt;openssl-1.0.1f&lt;/code&gt;) 这几个文件夹放在同一个目录下，然后进行下一步。&lt;/p&gt;&lt;h3 id=&quot;STEP3- 编译源码&quot;&gt;&lt;a href=&quot;#STEP3- 编译源码&quot; class=&quot;headerlink&quot; title=&quot;STEP3 编译源码&quot;&gt;&lt;/a&gt;STEP3 编译源码 &lt;/h3&gt;&lt;p&gt; 先打开 &lt;code&gt;zlib/win32&lt;/code&gt; 文件夹下的 &lt;code&gt;Makefile.gcc&lt;/code&gt; 文件, 把 &lt;code&gt;PREFIX =&lt;/code&gt; 这行改成 STEP1 里的 gcc 前缀，对于我来说就是 &lt;code&gt;PREFIX = i686-w64-mingw32-&lt;/code&gt;。把这个文件拷贝到&lt;code&gt;zlib&lt;/code&gt; 文件夹下，然后在 &lt;code&gt;zlib&lt;/code&gt; 文件夹下 &lt;code&gt;make -f Makefile.gcc&lt;/code&gt;，你就应该能看到&lt;code&gt;libz.a&lt;/code&gt; 这个文件了。&lt;/p&gt;&lt;p&gt;如果你要编译 OpenSSL, 那么就去 openssl 文件夹下&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ ./Configure no-shared --cross-compile-prefix=i686-w64-mingw32- mingw
$ make
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即可，记得改 prefix。生成 &lt;code&gt;libssl.a&lt;/code&gt; 和&lt;code&gt;libcrypto.a&lt;/code&gt;&lt;/p&gt;&lt;p&gt;最后去 libcurl 里的 lib 文件夹里修改 &lt;code&gt;Makefile.m32&lt;/code&gt; 文件，在 &lt;code&gt;CC = $(CROSSPREFIX)gcc&lt;/code&gt; 上加一行 &lt;code&gt;CROSSPREFIX=i686-w64-mingw32-&lt;/code&gt;（请按需修改），然后把下面&lt;code&gt;CFLAGS&lt;/code&gt; 那行改成这样&lt;code&gt;CFLAGS = -g -O2 -Wall -DCURL_DISABLE_LDAP&lt;/code&gt;，最后&lt;/p&gt;&lt;pre&gt;&lt;code&gt;make -f Makefile.m32 CFG=-zlib
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或是&lt;/p&gt;&lt;pre&gt;&lt;code&gt;make -f Makefile.m32 CFG=-zlib-ssl
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;make 到最后时会报个错，是因为文件没放对地方，手动挪一下即可 &lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; vtls/openssl.o vtls/gtls.o vtls/vtls.o vtls/nss.o vtls/qssl.o vtls/polarssl.o vtls/polarssl_threadlock.o vtls/axtls.o vtls/cyassl.o vtls/curl_schannel.o vtls/curl_darwinssl.o vtls/gskit.o&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mv `basename &lt;span class=&quot;variable&quot;&gt;$x&lt;/span&gt;` vtls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;done&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt; 然后再 make 一下，&lt;code&gt;libcurl.a&lt;/code&gt;文件应该就出现了。&lt;br&gt;如果生成 dll 出错也不要紧，我们要的是 &lt;code&gt;.a&lt;/code&gt; 文件 &lt;/p&gt;&lt;h3 id=&quot;STEP4- 测试&quot;&gt;&lt;a href=&quot;#STEP4- 测试&quot; class=&quot;headerlink&quot; title=&quot;STEP4 测试&quot;&gt;&lt;/a&gt;STEP4 测试&lt;/h3&gt;&lt;p&gt; 现在，你可以找一段 libcurl 的 demo 来测试了。注意要加上宏定义&lt;code&gt;CURL_STATICLIB&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;i686-w64-mingw32-gcc -I. -L. -DCURL_STATICLIB curl_demo.c -lcurl -lz -lws2_32 -o curl_demo.exe
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你因为不知道 gcc&lt;code&gt;-I&lt;/code&gt;和 &lt;code&gt;-L&lt;/code&gt; 选项的用法而编译不过，请自行 Google。如果你加了 ssl 支持，你需要链接更多的库，具体请根据错误信息自行 Google。最后提醒一点:&lt;strong&gt;请把 &lt;code&gt;-lcurl&lt;/code&gt; 选项放在源文件后面 &lt;/strong&gt;，我当初就是因为这个死活链接不过。最后把&lt;code&gt;curl_demo.exe&lt;/code&gt; 拖进虚拟机里，如果一切正常，那么恭喜你，你成功了。&lt;/p&gt;</content>
    
    <summary type="html">
    
      A short memo on how to cross-compile libcurl statically on linux.
    
    </summary>
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="Linux" scheme="http://recursiveg.me/tags/Linux/"/>
    
      <category term="MinGW" scheme="http://recursiveg.me/tags/MinGW/"/>
    
      <category term="交叉编译" scheme="http://recursiveg.me/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>记一次坑爹的乱码解决过程</title>
    <link href="http://recursiveg.me/2014/02/clear-a-special-kind-of-messy-code/"/>
    <id>http://recursiveg.me/2014/02/clear-a-special-kind-of-messy-code/</id>
    <published>2014-02-08T06:12:59.000Z</published>
    <updated>2016-01-14T02:33:05.839Z</updated>
    
    <content type="html">&lt;p&gt;某日，我在网上下载了一些音乐，然后打开，发现了乱码。Linux 系统上出现乱码本不是什么好大惊小怪的事，但是，在经过 N 种方法来回折腾依然无法解决的情况下，我意识到，这大约是我见过的最奇葩的一种乱码了。先上图：&lt;br&gt;&lt;img src=&quot;http://0f4529-files.oss-cn-hangzhou.aliyuncs.com/messy-code.png&quot; alt=&quot;An Example of the Messy Code&quot;&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;为了解释这个问题，我要先引入 Python3 中的字符串与字节序列的概念。在 Python3 中，一个字符串不存在‘编码类型’这种概念，每一个包含相同文字的字符串都是完全一样的 (确切的讲,Python3 中的字符串是以&lt;a href=&quot;https://zh.wikipedia.org/wiki/Unicode&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Unicode&lt;/a&gt; 编码的字节序列)。而字节序列和 C 中的 char 数组很像，它是字符串保存在文件系统上的真正形态。一个固定的字符串 (即包含相同的文字) 可以被编码 (即 Python 中的&lt;code&gt;encode()&lt;/code&gt;) 成字节序列。如果对其使用不同的编码方式，生成的字节序列也不同。举个例子，一栋房子地面上的第一层，英国人叫它’ground floor’，而美国人叫它‘first floor’。这就是不同的编码方式。相反，解码 (Python 中的&lt;code&gt;decode()&lt;/code&gt;) 就是把一个字节序列变回字符串。在普通情况下，乱码是由于对一个字节序列使用了错误的编码方式进行解码，解码之后的内容自然无法阅读。就像一个英国人给一个美国人留了张便条，写着‘Meet me at first floor.’(二楼)，然后美国人去一楼转了半天都没找到。这种使用了错误的解码方式的问题一般是由于操作系统的默认设定造成的，比如 Windows 系统使用当地语言的编码 (大陆 GBK, 台湾 BIG5, 日本 SHIFT-JIS 之类的)，而 Linux 普遍使用 UTF-8 编码。解决这种乱码的方法也很简单，你不是默认以 UTF8 方式解读么？而现在的字节序列又需要以 GBK 方式解读才能获得正确的内容，那么我们只要找到一个字节序列，让它被以 UTF8 解码时得到的内容和现在的字节序列被以 GBK 解码时得到的内容一样就行了。具体方法就是把当前的字节序列先以 GBK 解码，再以 UTF-8 编码，然后写回文件系统里，就搞定了。这个命令在 Linux 上就是&lt;code&gt;iconv -f GBK -t UTF-8&lt;/code&gt;(记得加管道)。&lt;/p&gt;&lt;p&gt; 但是，这次的乱码坑爹就坑爹在: 它的字节序列 (字符串是以字节序列的形式保存在磁盘上的，还记得么？) 无法以 GBK 方式解码，相反，它更像是一个根正苗红的 UTF-8 编码的字节序列。在多次尝试失败后，我开始无聊地“欣赏”乱码字符。注意到那些字符上的装饰了么？就是那些小点波浪尖角什么的？我也注意到了。然后我意识到，这是显著的西欧字符集的特征。也就是说，曾经有某个字节序列被以 ISO-8859-1(一种西欧字符集)解码过一次，然后才表现出了现在的样子。那么，我们把现在的 &lt;strong&gt; 字符串 &lt;/strong&gt; 用 ISO-8859-1 编码一次看看：&lt;code&gt;iconv -f UTF-8 -t ISO-8859-1&lt;/code&gt;(因为我的系统的默认编码是 UTF-8，所以需要‘-f UTF-8’)。然后得到了一坨问号，这正是 GBK 编码以 UTF-8 方式解码的结果，于是再接再厉：&lt;code&gt;iconv -f GBK -t UTF-8&lt;/code&gt;。终于看到了熟悉的文字。最终，这个问题以两行命令被解决 (因为是文件名乱码，所以用&lt;code&gt;convmv&lt;/code&gt; 命令)：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;convmv -f UTF-8 -t ISO-8859-1 --notest *
convmv -f GBK -t UTF-8 --notest *
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;这个乱码的产生原因也是对字节序列使用了错误的解码方式（对 GBK 字节序列使用 ISO-8859-1 解码），但是因为最终的字节序列是一个根正苗红的 UTF-8 编码，所以特别难以解决。这种问题特别容易发生在网络当中，比如，一个网站允许用户上传文件，因为一些原因，这个网站把所有的文件名都转成 UTF-8 存储，如果用户用西欧语言，那么这样就完全没关系，但如果一个中国用户上传了一个 GBK 文件名编码的文件，那么这种问题就发生了。&lt;/p&gt;&lt;p&gt;如果大家对排版或是图片之类的有什么意见建议请务必留言。&lt;br&gt;&lt;strong&gt;做人要厚道，转载请注明出处&lt;/strong&gt;&lt;/p&gt;</content>
    
    <summary type="html">
    
      Linux系统下一种特殊乱码的形成原因以及解决方案
    
    </summary>
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="Linux" scheme="http://recursiveg.me/tags/Linux/"/>
    
      <category term="乱码" scheme="http://recursiveg.me/tags/%E4%B9%B1%E7%A0%81/"/>
    
      <category term="Python" scheme="http://recursiveg.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>网站从 Octopress 迁移至 Hexo</title>
    <link href="http://recursiveg.me/2013/12/site-migration-complete/"/>
    <id>http://recursiveg.me/2013/12/site-migration-complete/</id>
    <published>2013-12-24T13:26:08.000Z</published>
    <updated>2016-01-14T02:33:05.839Z</updated>
    
    <content type="html">&lt;p&gt;经过我两个小时的折腾，总算是重新把网站弄起来了。Ruby 实在是坑爹，各种 gem 装得目录结构乱七八糟的……（强迫性人格障碍的典型表现）而且速度还慢……&lt;br&gt;曾尝试用 Python 和 Tornado 模板自己写一个静态页面生成器，然后发现我想多了。我果然还是不适合写 UI……&lt;br&gt;一通 Google 之后，最终决定使用 Hexo。它使用 node.js(也就是 javascript)作为编程语言 (这样说恰当么？反正就是这个意思啦), 据说速度极快。最重要的是，AUR 源里有 Hexo 打好的包，能用 pacman 管理就是好。&lt;br&gt; 主题试了一圈下来还是默认的 Light 看着最舒心。&lt;strong&gt;以后千万不能再手贱自己写主题了！！&lt;/strong&gt;&lt;br&gt;膜拜一下 Hexo 的作者 tommy351。自己改了一下高亮配色和 Widgets，把以前 Octopress 的 Markdown 文档做了一点点修改，这样就算上线了吧。&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;经过我两个小时的折腾，总算是重新把网站弄起来了。Ruby 实在是坑爹，各种 gem 装得目录结构乱七八糟的……（强迫性人格障碍的典型表现）而且速度还慢……&lt;br&gt;曾尝试用 Python 和 Tornado 模板自己写一个静态页面生成器，然后发现我想多了。我果然还是不适合写 
    
    </summary>
    
      <category term="Site Management" scheme="http://recursiveg.me/categories/Site-Management/"/>
    
    
      <category term="Hexo" scheme="http://recursiveg.me/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>通用存储及分布式文件共享系统的设想</title>
    <link href="http://recursiveg.me/2013/03/universal-storge/"/>
    <id>http://recursiveg.me/2013/03/universal-storge/</id>
    <published>2013-03-30T12:02:00.000Z</published>
    <updated>2016-01-14T02:33:05.839Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;Update: 本计划已无限期暂停，在可预见的未来没有重启计划，如有需要资料的欢迎发邮件索取 &lt;/strong&gt;&lt;/p&gt;&lt;p&gt; 众所周知，网盘这东西对大众来说不可或缺，国内的在线存储服务也欣欣向荣。但是，由于各种原因，我们仍感到这些不能完全满足我们的要求。&lt;br&gt;比如各种限制、各种暂停分享、还有各种必须付钱才能用的 VIP 服务等。各大公司想挣钱无可非议，毕竟网络存储绝对是烧钱的主，但作为一个搞技术的人，决不能整天写登陆界面，对吧？&lt;br&gt;动机在 &lt;a href=&quot;/2013/01/data-structure-of-vdisk/&quot;&gt; 新浪微盘数据结构解析 &lt;/a&gt; 中说了，在那之后我又研究了其他的网盘，萌生了这么一个设想。&lt;br&gt;简要的说，这个系统可以大大方便文件的传播与获取，延长资源的存活时间。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;废话不多说，以下是我的构想：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;人肉解析各资源站链接协议，比如下载上传链接解析什么的。&lt;/li&gt;&lt;li&gt;写成模块，类库什么的，方便调用。&lt;/li&gt;&lt;li&gt;以统一的界面管理多处资源，进行下载、上传等。&lt;/li&gt;&lt;li&gt;以写成的库为基础，对资源进行自动管理，比如可以分块存储于不同的位置，或是创建多个备份等。&lt;/li&gt;&lt;li&gt;维护一个数据库，存储用户共享信息，实现全网资源搜索。其实，不仅文件可以是分布式的，数据库也可以是分布式的，技术细节正在努力构思中。&lt;/li&gt;&lt;li&gt;有条件的同学可以在自己的服务器上运行一个特殊的服务端，接受来自其他用户的请求，比如一些已被停止共享的文件的下载 (比如 115 的 VIP 的离线下载功能)。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt; 更多可能，任君想象 &lt;/strong&gt;&lt;/p&gt;&lt;p&gt; 可能你们已经注意到了，我尽可能的避免使用 &lt;code&gt; 网盘 &lt;/code&gt; 这个字眼。没错，我的目标不仅是网盘，我还希望加入一些“只读”的资源，比如通过解析视频网站的地址来下载视频文件等。正如 Bilibili 所做的那样 (不过也许他们有合作关系？)。&lt;br&gt; 目前，统一管理界面正在书写中，使用 Python3, 应该不久可以放出 Alpha 版和 API。不过，最后，我要给大家浇盆冷水，&lt;em&gt;本计划仍处于设想阶段&lt;/em&gt;，不要期望能瞬间完成。而且，我们需要考虑遭到封杀后的应对措施，以及如何保持协议更新后库的快速升级等问题。&lt;/p&gt;&lt;p&gt;PS：欢迎有兴趣和有能力的同学来信交流：&lt;code&gt;gzh.shadow@gmail.com&lt;/code&gt;&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Update: 本计划已无限期暂停，在可预见的未来没有重启计划，如有需要资料的欢迎发邮件索取&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;众所周知，网盘这东西对大众来说不可或缺，国内的在线存储服务也欣欣向荣。但是，由于各种原因，我们仍感到这些不能完全满足我们的要求。&lt;br&gt;比如各种限制、各种暂停分享、还有各种必须付钱才能用的VIP服务等。各大公司想挣钱无可非议，毕竟网络存储绝对是烧钱的主，但作为一个搞技术的人，决不能整天写登陆界面，对吧？&lt;br&gt;动机在&lt;a href=&quot;/2013/01/data-structure-of-vdisk/&quot;&gt;新浪微盘数据结构解析&lt;/a&gt;中说了，在那之后我又研究了其他的网盘，萌生了这么一个设想。&lt;br&gt;简要的说，这个系统可以大大方便文件的传播与获取，延长资源的存活时间。&lt;br&gt;
    
    </summary>
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="Black Technology" scheme="http://recursiveg.me/tags/Black-Technology/"/>
    
      <category term="网盘" scheme="http://recursiveg.me/tags/%E7%BD%91%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>Pascal 中鲜为人知的那些技巧</title>
    <link href="http://recursiveg.me/2013/01/cheat-with-pascal/"/>
    <id>http://recursiveg.me/2013/01/cheat-with-pascal/</id>
    <published>2013-01-31T13:46:00.000Z</published>
    <updated>2016-01-14T02:33:05.839Z</updated>
    
    <content type="html">&lt;p&gt;做为一个搞信息学竞赛这么长时间的人，再加上估计很快就要转 C++ 了，我觉得我有必要留下一些关于 Pascal 语言的资料，于是就有了这篇文章。我只负责解释用法，对基础概念不了解的请自行 Google。所有这篇文章里的东西应该都能在 Free Pascal 自带的文档里找到，我写出来是为了众多不喜欢看英文的同学们，如果你愿意自己去看一下，一定会收益匪浅。&lt;/p&gt;&lt;h3 id=&quot;不同进制的表示&quot;&gt;&lt;a href=&quot;# 不同进制的表示&quot; class=&quot;headerlink&quot; title=&quot;不同进制的表示&quot;&gt;&lt;/a&gt;不同进制的表示 &lt;/h3&gt;&lt;p&gt; 平时我们写的常量都是十进制数，但我们有时需要写一个比如十六进制数怎么办呢？我们当然可以手动计算一下，但还有更优雅的方法。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;writeln($Ff,#32,&amp;amp;10,#32,%100);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你觉得它会输出什么呢？它输出 &lt;code&gt;255 8 4&lt;/code&gt;! 所以以&lt;code&gt;$&lt;/code&gt; 开头的是 16 进制数，&lt;code&gt;&amp;amp;&lt;/code&gt;开头的是 8 进制数，&lt;code&gt;%&lt;/code&gt;开头的是二进制数。顺带一提的是，以 &lt;code&gt;#&lt;/code&gt; 开头的数会转变成对应 ASCII 码的字符，其实它可以和前面的三个符号共同使用，即 &lt;code&gt;#$20&lt;/code&gt; 和&lt;code&gt;#%100000&lt;/code&gt;都代表了空格。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h3 id=&quot;函数内联&quot;&gt;&lt;a href=&quot;# 函数内联&quot; class=&quot;headerlink&quot; title=&quot;函数内联&quot;&gt;&lt;/a&gt;函数内联 &lt;/h3&gt;&lt;p&gt; 关于内联的解释请自己找资料，写法如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;function foo(bar:Type):ReturnType;inline;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即在函数头后加 &lt;code&gt;inline;&lt;/code&gt; 即可。测试证明确实有效，不过建议只用于诸如 &lt;code&gt;min&lt;/code&gt; 或&lt;code&gt;max&lt;/code&gt;这种函数。&lt;/p&gt;&lt;h3 id=&quot;函数的重载&quot;&gt;&lt;a href=&quot;# 函数的重载&quot; class=&quot;headerlink&quot; title=&quot;函数的重载&quot;&gt;&lt;/a&gt;函数的重载&lt;/h3&gt;&lt;p&gt;Pascal 也是支持重载的，甚至可以重载系统函数！演示如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;procedure sort(var a:TArray;l,r:longint);
begin
  ...
end;
procedure sort(var a:TArray;r:longint);
begin
  sort(a,1,r)
end;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样，调用 &lt;code&gt;sort(arr,top)&lt;/code&gt; 就相当于调用 &lt;code&gt;sort(arr,1,top)&lt;/code&gt;.&lt;/p&gt;&lt;h3 id=&quot;操作符重载&quot;&gt;&lt;a href=&quot;# 操作符重载&quot; class=&quot;headerlink&quot; title=&quot;操作符重载&quot;&gt;&lt;/a&gt; 操作符重载 &lt;/h3&gt;&lt;p&gt; 是不是对写高精度时的 &lt;code&gt;plus(a,b)&lt;/code&gt; 感到厌倦？是不是想换一种更帅的书写方式？没问题，操作符重载能满足你的愿望！它可以让你用 &lt;code&gt;a+b&lt;/code&gt; 的形式对高精度进行计算！&lt;/p&gt;&lt;pre&gt;&lt;code&gt;operator + (a,b:Type) c:Type;
operator := (a:Type1) b:Type2;
operator &amp;gt; (a,b:Type) c:boolean;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是 &lt;/p&gt;&lt;ul&gt;&lt;li&gt; 比较操作符的返回值只能是 &lt;code&gt;Boolean&lt;/code&gt;&lt;/li&gt;&lt;li&gt; 二元操作符和赋值操作符如果两端类型不同不能随意交换位置 &lt;/li&gt;&lt;li&gt; 重载后优先级不变 &lt;/li&gt;&lt;/ul&gt;&lt;p&gt; 为了解决不能随意交换位置的问题，你可以这样写：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;operator + (a:Type1;b:Type2)c:ReturnType;
begin
  ...
end;

operator + (a:Type2;b:Type1)c:ReturnType;
begin
  c:=b+a
end;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;想重载 str- 和 val-？&quot;&gt;&lt;a href=&quot;# 想重载 str- 和 val-？&quot; class=&quot;headerlink&quot; title=&quot;想重载 str()和 val()？&quot;&gt;&lt;/a&gt;想重载 str()和 val()？&lt;/h3&gt;&lt;p&gt;看完前面的函数重载，你是不是迫不及待地想要重载 &lt;code&gt;val()&lt;/code&gt; 和&lt;code&gt;str()&lt;/code&gt;这两个你看着不爽很久的函数了？但是却发现不能调用系统原来的函数了，Pascal 把它当成了递归！解决方法很简单，在要用原始系统函数的地方加上 &lt;code&gt;system.&lt;/code&gt; 即可。&lt;/p&gt;&lt;figure class=&quot;highlight delphi&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(x:longint)&lt;/span&gt;:&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//str(x,str)&amp;lt;--This is completely wrong!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  system.str(x,str);&lt;span class=&quot;comment&quot;&gt;//&amp;lt;--This is the right form&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;动态数组&quot;&gt;&lt;a href=&quot;# 动态数组&quot; class=&quot;headerlink&quot; title=&quot;动态数组&quot;&gt;&lt;/a&gt;动态数组 &lt;/h3&gt;&lt;p&gt; 担心数组太大爆内存？但心数组太小存不下？动态数组解除你的忧虑！主要操作如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;a:array of Type;&lt;/code&gt;：变量声明。&lt;/li&gt;&lt;li&gt;&lt;code&gt;setlength(a,length)&lt;/code&gt;：设定数组下标，范围为 &lt;code&gt;[0..length-1]&lt;/code&gt;，会自动清零。&lt;/li&gt;&lt;li&gt;&lt;code&gt;b:=a&lt;/code&gt;: 看上去像是赋值，但其实不是赋值，只是复制地址而已，因此对&lt;code&gt;b&lt;/code&gt; 的修改就是对 &lt;code&gt;a&lt;/code&gt; 的修改。&lt;/li&gt;&lt;li&gt;&lt;code&gt;c:=copy(a,0,length(a))&lt;/code&gt;：这就是真正的赋值了！还记得 &lt;code&gt;copy()&lt;/code&gt; 和&lt;code&gt;length()&lt;/code&gt;函数么？现在它们可以用于动态数组了！&lt;/li&gt;&lt;li&gt;&lt;code&gt;d:array of array of Type&lt;/code&gt;: 二维动态数组声明。&lt;/li&gt;&lt;li&gt;&lt;code&gt;setlength(d,length1,length2)&lt;/code&gt;: 不解释。&lt;/li&gt;&lt;li&gt;&lt;code&gt;a:=d[1]&lt;/code&gt;:&lt;code&gt;a&lt;/code&gt;是一维动态数组，对 &lt;code&gt;a[x]&lt;/code&gt; 的修改就是对 &lt;code&gt;d[1][x]&lt;/code&gt; 的修改。&lt;/li&gt;&lt;li&gt;&lt;code&gt;copy(d[x],0,length(d[x]))&lt;/code&gt;: 取出第 &lt;code&gt;x&lt;/code&gt; 个一维动态数组。&lt;/li&gt;&lt;li&gt;二维动态数组可以用 &lt;code&gt;d[x,y]&lt;/code&gt; 的方式访问，也可以用 &lt;code&gt;d[x][y]&lt;/code&gt; 的方式访问。&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&quot;取地址操作符&quot;&gt;&lt;a href=&quot;# 取地址操作符&quot; class=&quot;headerlink&quot; title=&quot;取地址操作符&quot;&gt;&lt;/a&gt;取地址操作符 &lt;/h3&gt;&lt;p&gt; 想用 C 语言中的 &lt;code&gt;&amp;amp;&lt;/code&gt; 操作符？在 Pascal 中它是 &lt;code&gt;@&lt;/code&gt;! 估计某年的 NOIP 坑了不少人。&lt;/p&gt;&lt;h3 id=&quot;输入输出重定向&quot;&gt;&lt;a href=&quot;# 输入输出重定向&quot; class=&quot;headerlink&quot; title=&quot;输入输出重定向&quot;&gt;&lt;/a&gt; 输入输出重定向 &lt;/h3&gt;&lt;p&gt; 你还在定义 &lt;code&gt;text&lt;/code&gt; 类型么？你还在用查找替换功能批量替换你的 &lt;code&gt;readln()&lt;/code&gt; 么？赶快试试这个！&lt;/p&gt;&lt;pre&gt;&lt;code&gt;assign(input,&amp;apos;foo.in&amp;apos;);reset(input);
assign(output,&amp;apos;foo.out&amp;apos;);rewrite(output);
...
close(input);close(output);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;再也不用担心输入输出了！&lt;/p&gt;&lt;h3 id=&quot;用动态数组实现伪变参&quot;&gt;&lt;a href=&quot;# 用动态数组实现伪变参&quot; class=&quot;headerlink&quot; title=&quot;用动态数组实现伪变参&quot;&gt;&lt;/a&gt;用动态数组实现伪变参 &lt;/h3&gt;&lt;p&gt; 是不是很羡慕 C 中 &lt;code&gt;printf&lt;/code&gt; 的变参？是不是很羡慕 &lt;code&gt;writeln&lt;/code&gt; 可以有好多好多参数？利用动态数组可以实现类似的功能！&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight delphi&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;average&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(arr:&lt;span class=&quot;keyword&quot;&gt;array&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; longint)&lt;/span&gt;:&lt;/span&gt;real;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i:longint;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  average:=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i:=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt; high(arr) &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    average:=average+arr[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  average:=average/length(arr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;请注意其中 &lt;code&gt;high()&lt;/code&gt; 和&lt;code&gt;length()&lt;/code&gt;的区别。合法调用如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;var A:array[1..MAX]of longint;
average([3]);
average([1,2,3,4]);
average(A);
average(A[1..5]);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;函数也是变量？！&quot;&gt;&lt;a href=&quot;# 函数也是变量？！&quot; class=&quot;headerlink&quot; title=&quot;函数也是变量？！&quot;&gt;&lt;/a&gt;函数也是变量？！&lt;/h3&gt;&lt;p&gt;或许你对 C++ 中的 &lt;code&gt;sort()&lt;/code&gt; 已有所耳闻，或许你已经知道，它的比较函数是做为参数传进去的。配合 &lt;code&gt;@&lt;/code&gt; 操作符，Pascal 可以做到相同的效果。&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight delphi&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; TMyCompareFunc=&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(a,b:MyType)&lt;/span&gt;:&lt;/span&gt;boolean;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;largerthan&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(a,b:MyType)&lt;/span&gt;:&lt;/span&gt;boolean;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a:&lt;span class=&quot;keyword&quot;&gt;array&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; MyType;l,r:longint;f:TMyCompareFunc)&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//Use `f(a[x],a[y])` to compare&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;compare(arr,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,max,@largerthan);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;既然是变量，就能互相赋值，但是请注意：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight delphi&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; TNoArgFunc=&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;integer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  F:TNoArgFunc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  N:integer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyFunc&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;integer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  MyFunc:=&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;F:=MyFunc; &lt;span class=&quot;comment&quot;&gt;//F()成为 MyFunc()的别名 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;N:=MyFunc; &lt;span class=&quot;comment&quot;&gt;//N 被赋值为 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//if F=MyFunc then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  writeln(&#39;You will never see this&#39;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 这个判断将导致 ` 类型不匹配 ` 编译错误&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; F=@MyFunc &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  writeln(&lt;span class=&quot;string&quot;&gt;&#39;这是同一个函数&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; F()=MyFunc &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  writeln(&lt;span class=&quot;string&quot;&gt;&#39;这两个函数的返回值相同&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;C 风格的操作符&quot;&gt;&lt;a href=&quot;#C 风格的操作符&quot; class=&quot;headerlink&quot; title=&quot;C 风格的操作符&quot;&gt;&lt;/a&gt;C 风格的操作符&lt;/h3&gt;&lt;p&gt; 我就不多介绍了 &lt;code&gt;+=&lt;/code&gt;、&lt;code&gt;-=&lt;/code&gt;、&lt;code&gt;*=&lt;/code&gt;、&lt;code&gt;/=&lt;/code&gt;…考试时先试试能不能用。使用有风险，偷懒须谨慎。&lt;/p&gt;&lt;h3 id=&quot;强制类型转换&quot;&gt;&lt;a href=&quot;# 强制类型转换&quot; class=&quot;headerlink&quot; title=&quot;强制类型转换&quot;&gt;&lt;/a&gt; 强制类型转换 &lt;/h3&gt;&lt;p&gt; 知道 C 中的 &lt;code&gt;(int)a&lt;/code&gt; 或是 &lt;code&gt;int(a)&lt;/code&gt; 么？不知道没关系，Pascal 中的强制类型转换是这样写的 &lt;code&gt;TypeIdentifier(Variable)&lt;/code&gt;。下面给几个例子：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight delphi&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; IntPtr=^integer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IntVal:=&lt;span class=&quot;number&quot;&gt;97&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RealVal:=&lt;span class=&quot;number&quot;&gt;3.7&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;longint(IntVal);&lt;span class=&quot;comment&quot;&gt;// 长版的 IntVal&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;real(IntVal);&lt;span class=&quot;comment&quot;&gt;// 实数版 IntVal，效果和赋值一样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pointer(IntVal);&lt;span class=&quot;comment&quot;&gt;// 一个指向内存地址 97 的无类型指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IntPtr(IntVal);&lt;span class=&quot;comment&quot;&gt;// 一个指向内存地址 97 的 Integer 指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;longint(@IntVal);&lt;span class=&quot;comment&quot;&gt;//IntVal 地址的 Longint 版。注意，它是一个数，所以可以用 writeln() 输出 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;writeln(IntPtr(@RealVal)^);&lt;span class=&quot;comment&quot;&gt;// 你可以猜猜这句话输出什么（写程序时请绝对不要这么做）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;无类型变量与无类型指针&quot;&gt;&lt;a href=&quot;# 无类型变量与无类型指针&quot; class=&quot;headerlink&quot; title=&quot;无类型变量与无类型指针&quot;&gt;&lt;/a&gt; 无类型变量与无类型指针 &lt;/h3&gt;&lt;p&gt; 标题写着 &lt;code&gt; 无类型变量 &lt;/code&gt;，其实应该叫做&lt;code&gt; 多类型变量 &lt;/code&gt; 更准确。他的主要工作原理就是在内部进行类型转换，因此效率极其低下，占用空间还特别大，连官方手册都不建议用。类型名为 &lt;code&gt;Variant&lt;/code&gt;。&lt;br&gt; 无类型指针就是上一节提到的 &lt;code&gt;Pointer&lt;/code&gt; 了。任何指针都可以赋值给它，它也可以赋值给任何指针，例子如下：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight delphi&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  p:pointer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  r:real;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  i:^integer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  r:=&lt;span class=&quot;number&quot;&gt;3.7&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  p:=@r;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  i:=p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  writeln(i^);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;看出来了么？这段文字和上一段的最后一句话等效。&lt;/p&gt;&lt;h3 id=&quot;这玩意儿是类？！&quot;&gt;&lt;a href=&quot;# 这玩意儿是类？！&quot; class=&quot;headerlink&quot; title=&quot;这玩意儿是类？！&quot;&gt;&lt;/a&gt;这玩意儿是类？！&lt;/h3&gt;&lt;p&gt;这是我最近才看到的一种写法，从来没用过。有愿意尝试的请自行研究。&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight delphi&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  TGetSum=&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a,b:longint;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Init&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(x,y:longint)&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;GetSum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;longint;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TGetSum&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Init&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(x,y:longint)&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a:=x;b:=y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TGetSum&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;GetSum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;longint;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  GetSum:=a+b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sum:TGetSum;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sum.Init(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  writeln(sum.GetSum())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;关于 Object Pascal, 推荐一本书:&lt;a href=&quot;http://code-sd.com/books/startprog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Start Programming Using Object Pascal&lt;/a&gt;&lt;/p&gt;&lt;h3 id=&quot;后记&quot;&gt;&lt;a href=&quot;# 后记&quot; class=&quot;headerlink&quot; title=&quot;后记&quot;&gt;&lt;/a&gt;后记 &lt;/h3&gt;&lt;p&gt;Pascal 是不少 OIer 最开始使用的一种语言，仅以此文献给众多正在使用和曾经使用过 Pascal 的 OIer。&lt;br&gt;&lt;strong&gt; 做人要厚道，转载请注明出处！&lt;/strong&gt;&lt;/p&gt;</content>
    
    <summary type="html">
    
      Some special skills programming with pascal. Useful in ACM.
    
    </summary>
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="Pascal" scheme="http://recursiveg.me/tags/Pascal/"/>
    
      <category term="ACM" scheme="http://recursiveg.me/tags/ACM/"/>
    
      <category term="编程" scheme="http://recursiveg.me/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>新浪微盘数据结构解析</title>
    <link href="http://recursiveg.me/2013/01/data-structure-of-vdisk/"/>
    <id>http://recursiveg.me/2013/01/data-structure-of-vdisk/</id>
    <published>2013-01-27T14:00:00.000Z</published>
    <updated>2016-01-14T02:33:05.839Z</updated>
    
    <content type="html">&lt;p&gt;&lt;em&gt;注意! 这个是 &lt;a href=&quot;http://vdisk.weibo.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; 微盘 &lt;/a&gt; 而不是 &lt;a href=&quot;http://www.vdisk.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; 威盘 &lt;/a&gt;&lt;/em&gt;&lt;br&gt; 研究这个问题的起因是有一次我需要从微盘上批量下载一堆文件。做为一个会写程序的人，我怎么能亲自做如此 ugly 的工作呢？这种事情当然要交给电脑做了！为了做到自动获取文件连接，于是就不得不研究这个问题了。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h3 id=&quot;用户的登录&quot;&gt;&lt;a href=&quot;# 用户的登录&quot; class=&quot;headerlink&quot; title=&quot;用户的登录&quot;&gt;&lt;/a&gt;用户的登录 &lt;/h3&gt;&lt;p&gt; 微盘内部使用一个叫做 &lt;code&gt;gsid&lt;/code&gt; 的值来识别用户。具体获取方法如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;URL:&lt;code&gt;http://vdisk.weibo.com/wap_auth&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;POST 参数 &lt;code&gt;username&lt;/code&gt;: 用户名 &lt;/li&gt;&lt;li&gt;POST 参数 &lt;code&gt;password&lt;/code&gt;: 用户密码&lt;/li&gt;&lt;li&gt; 返回数据：JSON 字符串。Example:&lt;code&gt;{&amp;quot;message&amp;quot;: &amp;quot;/?gsid=...&amp;quot;}&lt;/code&gt;。其中 &lt;code&gt;...&lt;/code&gt; 的部分就是 &lt;code&gt;gsid&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&quot;文件信息的获取&quot;&gt;&lt;a href=&quot;# 文件信息的获取&quot; class=&quot;headerlink&quot; title=&quot;文件信息的获取&quot;&gt;&lt;/a&gt; 文件信息的获取 &lt;/h3&gt;&lt;p&gt; 得到 &lt;code&gt;gsid&lt;/code&gt; 后，就可以用来下载文件了。当然，要先得到下载连接。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;URL：&lt;code&gt;http://vdisk.weibo.com/share/ajaxFileinfo&lt;/code&gt;&lt;/li&gt;&lt;li&gt;GET 参数 &lt;code&gt;fid&lt;/code&gt;：文件 ID&lt;/li&gt;&lt;li&gt;Cookie 参数 &lt;code&gt;gsid&lt;/code&gt;:GSID&lt;/li&gt;&lt;li&gt;浏览器标识 (UA): 需要设置为移动设备&lt;/li&gt;&lt;li&gt; 返回数据：JSON 字符串。 Example:&lt;/li&gt;&lt;/ol&gt;&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;span class=&quot;attr&quot;&gt;&quot;id&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;406458665&quot;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;\u5fae\u535a\u5c01\u9762\u80cc\u666f.zip&quot;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;uid&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;60999569&quot;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;dir_id&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;0&quot;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;ctime&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;1358820088&quot;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;ltime&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;1358820088&quot;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;dtime&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;0&quot;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;size&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;1662111&quot;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;is_locked&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;0&quot;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;type&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;application\/x-zip&quot;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;md5&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;9e8eec4a5d2d3ac5be41bb9f34dc3e40&quot;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;sha1&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;6e59853b198e3eae818d5b0756f47c34d4eae6df&quot;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;w&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;0&quot;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;h&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;0&quot;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;hid&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;0&quot;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;status&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;app_key&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;139204333&quot;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;source&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;2&quot;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;ip&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;0&quot;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;rev_id&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;140316098&quot;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;share_status&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;0&quot;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;share&quot;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;s3_url&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;http:\/\/file.data.vdisk.me\/61099569\/6e59853b198e3eae818d5b0756f47c34d4eae6df?ip=1358945643,10.75.7.27&amp;amp;ssig=o9x4sQ9tz6&amp;amp;Expires=1358944443&amp;amp;KID=sae,l30zoo1wmz&amp;amp;fn=%E5%BE%AE%E5%8D%9A%E5%B0%81%E9%9D%A2%E8%83%8C%E6%99%AF.zip&quot;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;url&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;http:\/\/vdisk.weibo.com\/s\/oex4F&quot;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;byte&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;1662111&quot;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;&quot;length&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;1662111&quot;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;其中，&lt;code&gt;s3_url&lt;/code&gt;就是下载地址了。顺带一提，从 &lt;code&gt;http://vdisk.weibo.com/file/info?fid=...&lt;/code&gt; 也可以得到文件信息，需要 Cookie:&lt;code&gt;gsid&lt;/code&gt;，但似乎不是所有文件都能成功得到信息。&lt;/p&gt;&lt;h3 id=&quot;文件下载&quot;&gt;&lt;a href=&quot;# 文件下载&quot; class=&quot;headerlink&quot; title=&quot;文件下载&quot;&gt;&lt;/a&gt;文件下载 &lt;/h3&gt;&lt;p&gt; 从上一步得到了 URL 就可以下载了。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;URL：&lt;code&gt;s3_url&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Cookie 参数 &lt;code&gt;gsid&lt;/code&gt;：GSID&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;需要注意的是，这个 URL 可能会有很多 &lt;code&gt;302 Redirection&lt;/code&gt;，可能是出于负载平衡的原因吧。&lt;/p&gt;&lt;h3 id=&quot;fid 与 fid64&quot;&gt;&lt;a href=&quot;#fid 与 fid64&quot; class=&quot;headerlink&quot; title=&quot;fid 与 fid64&quot;&gt;&lt;/a&gt;fid 与 fid64&lt;/h3&gt;&lt;p&gt; 平时我们下载都是用 &lt;code&gt;http://vdisk.weibo.com/s/aMVfa&lt;/code&gt; 这种形式的短链接，其中 &lt;code&gt;aMVfa&lt;/code&gt; 就是 fid64, 说白了就是 64 进制表示的 fid，其 0～63 对应如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此，&lt;code&gt;aR_8-&lt;/code&gt;解码后就是 &lt;code&gt;181920319&lt;/code&gt;&lt;/p&gt;&lt;h3 id=&quot;文件列表的获取&quot;&gt;&lt;a href=&quot;# 文件列表的获取&quot; class=&quot;headerlink&quot; title=&quot;文件列表的获取&quot;&gt;&lt;/a&gt; 文件列表的获取 &lt;/h3&gt;&lt;p&gt; 研究完上文所提到的东西后，应该就可以进行文件批量下载了。但做为一个上进的好青年，我们不会止步与此。为了能够方便地管理自己的文件夹，当然要做进一步研究。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;URL：&lt;code&gt;http://vdisk.weibo.com/dir/list&lt;/code&gt;&lt;/li&gt;&lt;li&gt;GET 参数 &lt;code&gt;dir_id&lt;/code&gt;：Directionary ID&lt;/li&gt;&lt;li&gt;Cookie 参数 &lt;code&gt;gsid&lt;/code&gt;：GSID&lt;/li&gt;&lt;li&gt;浏览器标识 (UA): 需要设置为移动设备&lt;/li&gt;&lt;li&gt; 返回数据：JSON 字符串。其中 &lt;code&gt;dirinfo&lt;/code&gt; 中的 &lt;code&gt;dir_num&lt;/code&gt; 和&lt;code&gt;file_num&lt;/code&gt;分别储存了在这个文件夹下有多少个目录和多少个文件。&lt;code&gt;data&lt;/code&gt;段是一个数组，每个元素都代表了一个文件或目录，其中保存了 &lt;code&gt;fid&lt;/code&gt; 或是 &lt;code&gt;dir_id&lt;/code&gt;。通过是否有&lt;code&gt;type&lt;/code&gt; 段来判断具体是文件还是目录。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;用户根文件夹的 &lt;code&gt;dir_id&lt;/code&gt; 是&lt;code&gt;0&lt;/code&gt;&lt;/p&gt;&lt;h3 id=&quot;Cookie 与浏览器标识 -UA&quot;&gt;&lt;a href=&quot;#Cookie 与浏览器标识 -UA&quot; class=&quot;headerlink&quot; title=&quot;Cookie 与浏览器标识 (UA)&quot;&gt;&lt;/a&gt;Cookie 与浏览器标识(UA)&lt;/h3&gt;&lt;p&gt; 似乎所有的链接都可以通过在 Cookie 中加入 &lt;code&gt;device=mobile&lt;/code&gt; 来跳过 UA 检查。(就是说不用设置 UA 了)&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;注意!这个是&lt;a href=&quot;http://vdisk.weibo.com&quot;&gt;微盘&lt;/a&gt;而不是&lt;a href=&quot;http://www.vdisk.cn&quot;&gt;威盘&lt;/a&gt;&lt;/em&gt;&lt;br&gt;研究这个问题的起因是有一次我需要从微盘上批量下载一堆文件。做为一个会写程序的人，我怎么能亲自做如此ugly的工作呢？这种事情当然要交给电脑做了！为了做到自动获取文件连接，于是就不得不研究这个问题了。&lt;br&gt;
    
    </summary>
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="Black Technology" scheme="http://recursiveg.me/tags/Black-Technology/"/>
    
      <category term="网盘" scheme="http://recursiveg.me/tags/%E7%BD%91%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>公钥加密</title>
    <link href="http://recursiveg.me/2012/12/public-key-cryptography/"/>
    <id>http://recursiveg.me/2012/12/public-key-cryptography/</id>
    <published>2012-12-31T13:02:00.000Z</published>
    <updated>2016-01-14T02:33:05.839Z</updated>
    
    <content type="html">&lt;p&gt; 各种加密方法大体可以分成两类，一类是对称加密，另一类是非对称加密。&lt;/p&gt;&lt;p&gt; 凯撒密码是对称加密中的一种，他的加密方法是把 A 变成 B，把 B 变成 C，于是解密的时候只要把字母替换回来就行了。也就是说，任何知道加密方法的人就可以解密。&lt;/p&gt;&lt;p&gt;RSA 是一种非对称加密算法，他的特点是任何人都可以加密，但只有我可以解密。做个比喻，人人都可以把锁头扣上，但只有拥有钥匙的人可以开锁。这个分发出去的用于加密的东西叫做公钥，也被称作证书。而留在自己身边的“钥匙”就是私钥，是绝对不能被第二个人拿到的。&lt;/p&gt;&lt;p&gt; 于是乎，你可以把公钥发给别人，别人把数据用你的公钥加密后传给你，你用私钥解密后阅读。在这个过程中，任何人截取到数据都是无效的，因为它没有你的私钥。&lt;/p&gt;&lt;p&gt;RSA 还有一个特点，就是可以用私钥加密，用公钥解密。你会问，公钥人人都能拿到，相当于人人都能解密，那这样加密有什么意义呢？意义在于，它可以作为身份验证。用私钥加密的过程叫签名，而验证签名就是用对应的公钥解密。因为为只有用对应的私钥签名的文件才能用公钥解密，既然它可以用公钥解密，就一定是由对应私钥签署的，而私钥只有你有，于是这份文件就一定是你发布的。网络上的 HTTPS 就是依靠着个。一般来说，用私钥加密的都是 MD5、SHA1 之类的，加密原文太耗系统资源。&lt;/p&gt;&lt;p&gt; 对付这种非对称的加密方式，有一种叫做“中间人攻击”的攻击方法，它会使双方之间的通信完全暴露。我就偷懒不写了，大家自己找资料。&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt; 各种加密方法大体可以分成两类，一类是对称加密，另一类是非对称加密。&lt;/p&gt;&lt;p&gt; 凯撒密码是对称加密中的一种，他的加密方法是把 A 变成 B，把 B 变成 C，于是解密的时候只要把字母替换回来就行了。也就是说，任何知道加密方法的人就可以解密。&lt;/p&gt;&lt;p&gt;RSA 是一种非
    
    </summary>
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="加密" scheme="http://recursiveg.me/tags/%E5%8A%A0%E5%AF%86/"/>
    
      <category term="RSA" scheme="http://recursiveg.me/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>Sync with iDevice on Linux</title>
    <link href="http://recursiveg.me/2012/12/sync-with-idevice-on-linux/"/>
    <id>http://recursiveg.me/2012/12/sync-with-idevice-on-linux/</id>
    <published>2012-12-31T13:01:00.000Z</published>
    <updated>2016-01-14T02:33:05.839Z</updated>
    
    <content type="html">&lt;p&gt;It’s a bit hard to connect an iDevice with Linux because Apple is not so open and we have to use iTunes to sync with our iDevice for a long time. Luckily we now have a set of tool so that we can control our device on linux. The most important two library are &lt;a href=&quot;http://www.libimobiledevice.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;libimobiledevice&lt;/a&gt;(libiphone) and libgpod.&lt;/p&gt;&lt;p&gt;libimobiledevice, like it’s name, is a library who provides the interface to access the iDevice. It provides a higher level of access such as photo, bookmark, install/uninstall softwares and even sync music. And it doesn’t need jailbreak.&lt;/p&gt;&lt;p&gt;What I want to mention is how musics synchronized with an iDevice. Under the iTunes folder (You may never seen that before. That’s ordinary.), there’s a file called iTunesDB. That’s the file which libgpod really works with. This file contains the name of songs, singers’ names, your play lists and so on. Unfortunately, because Apple don’t want it be modified by any programs except iTunes, they add some hash info into the file. If iPod found the hash is incorrect, it refused to display the songs. There was once a project called iPodHash, but it seems to be die due to a DMCA notice. Apple engineers have changed the hash algorithm for several times and the latest version haven’t been reverse-engineering, as a result, now we can only sync with a old version of iOS.&lt;/p&gt;&lt;p&gt;If your iDevice is jailbreaked, you can change a key called DBVersion(Sorry, I forgot where it is.). It tells iPod which version of hash algorithm it should use so we could use a known hash on new iOS. This process depends on libimobiledevice too. It only support to sync with iOS 4 or older. That means it’s useless even if you changed DBVersion on your iOS5 device. By the way, you may will not find a iTunesDB file but a iTunesCDB instead. It’s a compressed version of iTunesDB using zlib.&lt;/p&gt;&lt;p&gt;I feel so sad that such a project is closed and now I can only sync with my iPod on Windows.&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;It’s a bit hard to connect an iDevice with Linux because Apple is not so open and we have to use iTunes to sync with our iDevice for a lo
    
    </summary>
    
      <category term="Informatics" scheme="http://recursiveg.me/categories/Informatics/"/>
    
    
      <category term="Written In English" scheme="http://recursiveg.me/tags/Written-In-English/"/>
    
      <category term="iDevice" scheme="http://recursiveg.me/tags/iDevice/"/>
    
      <category term="Linux" scheme="http://recursiveg.me/tags/Linux/"/>
    
  </entry>
  
</feed>
