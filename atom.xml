<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RECURSIVE LAND</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://recursiveg.me/"/>
  <updated>2020-11-06T04:59:41.686Z</updated>
  <id>https://recursiveg.me/</id>
  
  <author>
    <name>RecursiveG</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IPsec 配置备忘 Part4 - Virtual IP</title>
    <link href="https://recursiveg.me/2020/11/ipsec-configurations-part4/"/>
    <id>https://recursiveg.me/2020/11/ipsec-configurations-part4/</id>
    <published>2020-11-05T12:00:00.000Z</published>
    <updated>2020-11-06T04:59:41.686Z</updated>
    
    <content type="html"><![CDATA[<p>第四篇主要讲一下怎么给客户端下发内网 IP ~<br><a href="/2020/10/ipsec-configurations-part1/">Part1 传送门</a>；<a href="/2020/10/ipsec-configurations-part2/">Part2 传送门</a>；<a href="/2020/10/ipsec-configurations-part3/">Part3 传送门</a></p><h1 id="Virtual-IP-VIP"><a href="#Virtual-IP-VIP" class="headerlink" title="Virtual IP (VIP)"></a>Virtual IP (VIP)</h1><p>接 Part3，有了 Tunnel 模式以后我们实际使用的 IP 地址就不用受制于机器的实际 IP 了。但是手动给每个客户端手动分配一个地址显然是不切实际的。于是我们可以使用 Virtual IP 功能自动向连入的客户端分配一个内网 IP，就像 DHCP 或者 SLAAC 那样。</p><h1 id="场景配置"><a href="#场景配置" class="headerlink" title="场景配置"></a>场景配置</h1><p>与之前完全对称的配置不同，使用 Virtual IP 时需要区分服务端和客户端。先在服务端配置将要分配的 IP，然后由客户端发起连接，服务端就会将配置好的 IP 分发出去。我使用 HostA 作为服务端，HostB 作为客户端。HostA 将会给 HostB 分配 IPv4 与 IPv6 各一个。使用的 Virtual IP 段是<code>fd01::100-fd01::200</code>和<code>10.10.10.100-10.10.10.150</code>。</p><pre><code>hosta$ ip -br addreth1         UP             fd00::1/64 fd01::1/128 10.10.10.1/32hostb$ ip -br addreth1         UP             fd00::2/64</code></pre><p>和 Part3 相比，HostA 这里有一些与之前不同的地方，一是内部 IP 全部放在了 eth1 上（而不是 lo 上）；二是内部 IP 的前缀长度都是最大值；三是增加了一个 IPv4 的内部 IP，用于和分配的 IPv4 Virtual IP 通信。同时 HostB 也不再手工分配<code>fd01</code>开头的内部 IP 了，将由 strongSwan 自动配置。</p><p>当连接建立后，我们应该能看到在 HostB 的 eth1 上出现两个新的，自动分配的 IP。且分配到的 IPv4 地址与 10.10.10.1 之间的通信是加密的，分配到的 IPv6 地址与 fd01::1 之间的通信是加密的。</p><a id="more"></a><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>配置文件基于 Part3 修改而来，有变化的部分已添加注释：</p><figure class="highlight bash"><figcaption><span>hosta.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">connections &#123;</span><br><span class="line">  conn_hosta_hostb &#123;</span><br><span class="line">    version = 2</span><br><span class="line">    local_addrs = fd00::1</span><br><span class="line">    remote_addrs = fd00::2</span><br><span class="line">    proposals = null-sha-modp2048</span><br><span class="line">    <span class="comment"># 指定要使用的 IP 池</span></span><br><span class="line">    pools = ip6pool,ip4pool</span><br><span class="line">    <span class="built_in">local</span> &#123;</span><br><span class="line">      id = CN=HOSTA_COMMON_NAME</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    remote &#123;</span><br><span class="line">      id = %any</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    children &#123;</span><br><span class="line">      child_sa &#123;</span><br><span class="line">        <span class="comment"># Local TS 加上新增的 IPv4 地址</span></span><br><span class="line">        local_ts = fd01::1/128,10.10.10.1/32</span><br><span class="line">        <span class="comment"># Remote TS 设置为 "dynamic"</span></span><br><span class="line">        <span class="comment"># strongSwan 会自动将其替换成分配出去的 Virtual IP</span></span><br><span class="line">        remote_ts = dynamic</span><br><span class="line">        mode = tunnel</span><br><span class="line">        esp_proposals = null-sha-modp2048</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 IP 池</span></span><br><span class="line">pools &#123;</span><br><span class="line">  <span class="comment"># IP 池的名称</span></span><br><span class="line">  ip6pool &#123;</span><br><span class="line">    <span class="comment"># 池中的 IP，也可以使用 fd01::100/120 这样的表示法</span></span><br><span class="line">    addrs = fd01::100-fd01::200</span><br><span class="line">  &#125;</span><br><span class="line">  ip4pool &#123;</span><br><span class="line">    addrs = 10.10.10.100-10.10.10.150</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>hostb.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">connections &#123;</span><br><span class="line">  conn_hosta_hostb &#123;</span><br><span class="line">    version = 2</span><br><span class="line">    local_addrs = fd00::2</span><br><span class="line">    remote_addrs = fd00::1</span><br><span class="line">    proposals = null-sha-modp2048</span><br><span class="line">    <span class="comment"># 向服务器请求 VIP，0.0.0.0 代表任意 IPv4</span></span><br><span class="line">    <span class="comment"># :: 代表任意 IPv6</span></span><br><span class="line">    vips = 0.0.0.0,::</span><br><span class="line">    <span class="built_in">local</span> &#123;</span><br><span class="line">      id = CN=HOSTB_COMMON_NAME</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    remote &#123;</span><br><span class="line">      id = CN=HOSTA_COMMON_NAME</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    children &#123;</span><br><span class="line">      child_sa &#123;</span><br><span class="line">        <span class="comment"># 类似 HostA 的 Remote TS，dynamic 会被自动替换</span></span><br><span class="line">        <span class="comment"># 成从服务端接收到的 VIP</span></span><br><span class="line">        local_ts = dynamic</span><br><span class="line">        <span class="comment"># 增加服务器的 IPv4 内网地址</span></span><br><span class="line">        remote_ts = fd01::1/128,10.10.10.1/32</span><br><span class="line">        mode = tunnel</span><br><span class="line">        esp_proposals = null-sha-modp2048</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链接测试"><a href="#链接测试" class="headerlink" title="链接测试"></a>链接测试</h1><p>与 Part3 中的对称链接不同，这次你必须从客户端发起连接，也就是从 HostB 执行如下命令：<code>swanctl -i -c child_sa</code>。连接建立后，你应该就能看到自动分配的 IP 了：</p><pre><code>hostb$ ip -br addreth1         UP             fd00::2/64 fd01::100/128 10.10.10.100/32</code></pre><p>此时再从 HostB 分别 ping <code>fd00::1</code>，<code>fd01::1</code>和<code>10.10.10.1</code>，你应该能看到前者没有加密，而后两者的 ICMP 包被包在了<code>fd00::1 &lt;---&gt; fd00::2</code>的 IPv6-ESP 包里：</p><p><img src="/images/ipsec-configurations-part4/IPv4-in-IPv6-ESP.png" alt="IPv4 ICMP inside IPv6 ESP"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第四篇主要讲一下怎么给客户端下发内网 IP ~&lt;br&gt;&lt;a href=&quot;/2020/10/ipsec-configurations-part1/&quot;&gt;Part1 传送门&lt;/a&gt;；&lt;a href=&quot;/2020/10/ipsec-configurations-part2/&quot;&gt;Part2 传送门&lt;/a&gt;；&lt;a href=&quot;/2020/10/ipsec-configurations-part3/&quot;&gt;Part3 传送门&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Virtual-IP-VIP&quot;&gt;&lt;a href=&quot;#Virtual-IP-VIP&quot; class=&quot;headerlink&quot; title=&quot;Virtual IP (VIP)&quot;&gt;&lt;/a&gt;Virtual IP (VIP)&lt;/h1&gt;&lt;p&gt;接 Part3，有了 Tunnel 模式以后我们实际使用的 IP 地址就不用受制于机器的实际 IP 了。但是手动给每个客户端手动分配一个地址显然是不切实际的。于是我们可以使用 Virtual IP 功能自动向连入的客户端分配一个内网 IP，就像 DHCP 或者 SLAAC 那样。&lt;/p&gt;
&lt;h1 id=&quot;场景配置&quot;&gt;&lt;a href=&quot;#场景配置&quot; class=&quot;headerlink&quot; title=&quot;场景配置&quot;&gt;&lt;/a&gt;场景配置&lt;/h1&gt;&lt;p&gt;与之前完全对称的配置不同，使用 Virtual IP 时需要区分服务端和客户端。先在服务端配置将要分配的 IP，然后由客户端发起连接，服务端就会将配置好的 IP 分发出去。我使用 HostA 作为服务端，HostB 作为客户端。HostA 将会给 HostB 分配 IPv4 与 IPv6 各一个。使用的 Virtual IP 段是&lt;code&gt;fd01::100-fd01::200&lt;/code&gt;和&lt;code&gt;10.10.10.100-10.10.10.150&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hosta$ ip -br addr
eth1         UP             fd00::1/64 fd01::1/128 10.10.10.1/32

hostb$ ip -br addr
eth1         UP             fd00::2/64&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;和 Part3 相比，HostA 这里有一些与之前不同的地方，一是内部 IP 全部放在了 eth1 上（而不是 lo 上）；二是内部 IP 的前缀长度都是最大值；三是增加了一个 IPv4 的内部 IP，用于和分配的 IPv4 Virtual IP 通信。同时 HostB 也不再手工分配&lt;code&gt;fd01&lt;/code&gt;开头的内部 IP 了，将由 strongSwan 自动配置。&lt;/p&gt;
&lt;p&gt;当连接建立后，我们应该能看到在 HostB 的 eth1 上出现两个新的，自动分配的 IP。且分配到的 IPv4 地址与 10.10.10.1 之间的通信是加密的，分配到的 IPv6 地址与 fd01::1 之间的通信是加密的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="IPsec" scheme="https://recursiveg.me/tags/IPsec/"/>
    
      <category term="Networking" scheme="https://recursiveg.me/tags/Networking/"/>
    
      <category term="VPN" scheme="https://recursiveg.me/tags/VPN/"/>
    
      <category term="折腾" scheme="https://recursiveg.me/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>[娱乐向] Samsung 980 Pro RAID 性能测试</title>
    <link href="https://recursiveg.me/2020/11/samsung-980pro-speedtest/"/>
    <id>https://recursiveg.me/2020/11/samsung-980pro-speedtest/</id>
    <published>2020-11-02T14:00:00.000Z</published>
    <updated>2020-11-03T19:54:06.436Z</updated>
    
    <content type="html"><![CDATA[<p>三星的新 SSD 980 Pro 已经发售一段时间了，前两天看到 Amazon 上 1TB 有货，赶紧下单两条。今天到货，于是装机测一波速度。打算用来做系统盘，所以自然就是用来组 RAID-0 咯。于是用 fio 分别测试了一下 btrfs 和 mdadm 组 RAID 的性能。测试完全不严谨，参数是用脸滚键盘滚出来的，放出来仅供各位一乐，为什么是娱乐向你看数据就知道了。同时拉上了打酱油的 960 Evo（我现在的系统盘），以及完全是搞笑用的<code>/dev/shm</code>：</p><table><thead><tr><th align="left">场景</th><th align="right">连续读取(MiB/s)</th><th align="right">连续写入(MiB/s)</th><th align="right">4K 随机读取(kIOPS)</th><th align="right">4K 随机写入(kIOPS)</th></tr></thead><tbody><tr><td align="left">980 Pro 单盘 EXT4</td><td align="right">6370</td><td align="right">4725</td><td align="right">330</td><td align="right">125</td></tr><tr><td align="left">980 Pro 单盘 BTRFS</td><td align="right">6264</td><td align="right">2720</td><td align="right">137</td><td align="right">63.7</td></tr><tr><td align="left">980 Pro mdadm RAID-0 EXT4</td><td align="right">12186</td><td align="right">9426</td><td align="right">298</td><td align="right">115</td></tr><tr><td align="left">980 Pro BTRFS RAID0</td><td align="right">5937</td><td align="right">3932</td><td align="right">133</td><td align="right">63.3</td></tr><tr><td align="left">/dev/shm</td><td align="right">6290</td><td align="right">5541</td><td align="right">792</td><td align="right">571</td></tr><tr><td align="left">960 Evo 单盘 XFS</td><td align="right">2963</td><td align="right">410</td><td align="right">199</td><td align="right">31.3</td></tr></tbody></table><p>Emmmm, mdadm RAID0 比内存快……这很合理……以及 btrfs 你的 RAID 性能还能更烂一点吗？</p><a id="more"></a><p>测试用设置在此，测试<code>/dev/shm</code>的时候关掉了<code>direct</code>以及把文件大小改成了<code>1g</code>:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[global]</span></span><br><span class="line"><span class="attr">ioengine</span>=libaio</span><br><span class="line"><span class="attr">direct</span>=<span class="number">1</span></span><br><span class="line">time_based</span><br><span class="line"><span class="attr">runtime</span>=<span class="number">60</span></span><br><span class="line"><span class="attr">numjobs</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">iodepth</span>=<span class="number">32</span></span><br><span class="line">group_reporting</span><br><span class="line"><span class="attr">size</span>=<span class="number">10</span>g</span><br><span class="line"></span><br><span class="line"><span class="section">[seq_read]</span></span><br><span class="line">stonewall</span><br><span class="line"><span class="attr">bs</span>=<span class="number">1</span>M</span><br><span class="line"><span class="attr">rw</span>=read</span><br><span class="line"></span><br><span class="line"><span class="section">[seq_write]</span></span><br><span class="line">stonewall</span><br><span class="line"><span class="attr">bs</span>=<span class="number">1</span>M</span><br><span class="line"><span class="attr">rw</span>=write</span><br><span class="line"></span><br><span class="line"><span class="section">[random_read]</span></span><br><span class="line">stonewall</span><br><span class="line"><span class="attr">bs</span>=<span class="number">4</span>k</span><br><span class="line"><span class="attr">rw</span>=randread</span><br><span class="line"></span><br><span class="line"><span class="section">[random_write]</span></span><br><span class="line">stonewall</span><br><span class="line"><span class="attr">bs</span>=<span class="number">4</span>k</span><br><span class="line"><span class="attr">rw</span>=randwrite</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;三星的新 SSD 980 Pro 已经发售一段时间了，前两天看到 Amazon 上 1TB 有货，赶紧下单两条。今天到货，于是装机测一波速度。打算用来做系统盘，所以自然就是用来组 RAID-0 咯。于是用 fio 分别测试了一下 btrfs 和 mdadm 组 RAID 的性能。测试完全不严谨，参数是用脸滚键盘滚出来的，放出来仅供各位一乐，为什么是娱乐向你看数据就知道了。同时拉上了打酱油的 960 Evo（我现在的系统盘），以及完全是搞笑用的&lt;code&gt;/dev/shm&lt;/code&gt;：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;场景&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;连续读取(MiB/s)&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;连续写入(MiB/s)&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;4K 随机读取(kIOPS)&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;4K 随机写入(kIOPS)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;980 Pro 单盘 EXT4&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;6370&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;4725&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;330&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;125&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;980 Pro 单盘 BTRFS&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;6264&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;2720&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;137&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;63.7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;980 Pro mdadm RAID-0 EXT4&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;12186&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;9426&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;298&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;115&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;980 Pro BTRFS RAID0&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;5937&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;3932&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;133&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;63.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;/dev/shm&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;6290&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;5541&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;792&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;571&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;960 Evo 单盘 XFS&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;2963&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;410&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;199&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;31.3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;Emmmm, mdadm RAID0 比内存快……这很合理……以及 btrfs 你的 RAID 性能还能更烂一点吗？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="折腾" scheme="https://recursiveg.me/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="硬件" scheme="https://recursiveg.me/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>IPsec 配置备忘 Part3 - Tunnel 模式</title>
    <link href="https://recursiveg.me/2020/10/ipsec-configurations-part3/"/>
    <id>https://recursiveg.me/2020/10/ipsec-configurations-part3/</id>
    <published>2020-10-31T02:50:00.000Z</published>
    <updated>2020-10-31T18:06:53.952Z</updated>
    
    <content type="html"><![CDATA[<p>第三篇简单介绍一下 IPsec 的 Tunnel 模式，没看过前两篇的快去看~<br><a href="/2020/10/ipsec-configurations-part1/">Part1 传送门</a>；<a href="/2020/10/ipsec-configurations-part2/">Part2 传送门</a></p><h2 id="Tunnel-模式简介"><a href="#Tunnel-模式简介" class="headerlink" title="Tunnel 模式简介"></a>Tunnel 模式简介</h2><p><img src="/images/ipsec-configurations-part3/01-tunnel-mode-header-layout.png" alt="Tunnel mode header layout"> 前两篇中我们使用的都是 Transport 模式，但是实际使用中，更常用的是 Tunnel 模式。Transport 模式只加密四层及以上数据，而不修改 IP 头，原始的 IP 头将会原样传输。这意味着我们只能进行点对点传输，因为只有一个 IP 头，我们无法告知对方服务器我们实际要访问的地址。Tunnel 模式则是连原始的 IP 头也一起加密，然后再在前端添加一个新的 IP 头，这样服务器在收到数据包后，可以解密并读取内部的 IP 头，再转发给实际的目标服务器。</p><a id="more"></a><h2 id="配置场景"><a href="#配置场景" class="headerlink" title="配置场景"></a>配置场景</h2><p>这次的场景在 Part2 的基础上略有改动：在 HostA 与 HostB 的<code>lo</code>接口上分别添加<code>fd01::1/64</code>与<code>fd01::2/64</code>:</p><pre><code>hosta$ ip -6 -br addrlo               UNKNOWN        fd01::1/64 ::1/128eth1             UP             fd00::1/64 [--omit--][--omit--]hostb$ ip -6 -br addrlo               UNKNOWN        fd01::2/64 ::1/128eth1             UP             fd00::2/64 [--omit--][--omit--]</code></pre><p>在没有建立连接的情况下，fd00::1 和 fd00::2 可互 ping，fd01::1 和 fd01::2 不可互 ping。在建立连接后，fd00::1 和 fd00::2 可互 ping，但是不加密，fd01::1 和 fd01::2 可互 ping 且流量加密。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>配置文件也是在 Part2 的基础上改动而来，变化部分已加注释</p><figure class="highlight bash"><figcaption><span>hosta.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hosta</span></span><br><span class="line">connections &#123;</span><br><span class="line">  conn_hosta_hostb &#123;</span><br><span class="line">    version = 2</span><br><span class="line">    local_addrs = fd00::1</span><br><span class="line">    remote_addrs = fd00::2</span><br><span class="line">    <span class="comment"># 使用 NULL 加密以方便抓包观察</span></span><br><span class="line">    proposals = null-sha-modp2048</span><br><span class="line">    <span class="built_in">local</span> &#123;</span><br><span class="line">      id = CN=HOSTA_COMMON_NAME</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    remote &#123;</span><br><span class="line">      id = %any</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    children &#123;</span><br><span class="line">      child_sa &#123;</span><br><span class="line">        <span class="comment"># Traffic selector 改为 fd01::*</span></span><br><span class="line">        <span class="comment"># 这意味着 fd00::* 不被选中，也就不会被加密</span></span><br><span class="line">        local_ts = fd01::1/128</span><br><span class="line">        remote_ts = fd01::2/128</span><br><span class="line">        <span class="comment"># 传输模式改为 Tunnel</span></span><br><span class="line">        mode = tunnel</span><br><span class="line">        esp_proposals = null-sha-modp2048</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>hostb.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">connections &#123;</span><br><span class="line">  conn_hosta_hostb &#123;</span><br><span class="line">    version = 2</span><br><span class="line">    <span class="comment"># 交换 local 与 remote</span></span><br><span class="line">    local_addrs = fd00::2</span><br><span class="line">    remote_addrs = fd00::1</span><br><span class="line">    proposals = null-sha-modp2048</span><br><span class="line">    <span class="built_in">local</span> &#123;</span><br><span class="line">      <span class="comment"># 使用 HostB 的 id</span></span><br><span class="line">      id = CN=HOSTB_COMMON_NAME</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    remote &#123;</span><br><span class="line">      id = %any</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    children &#123;</span><br><span class="line">      child_sa &#123;</span><br><span class="line">        <span class="comment"># 交换 local 与 remote</span></span><br><span class="line">        local_ts = fd01::2/128</span><br><span class="line">        remote_ts = fd01::1/128</span><br><span class="line">        mode = tunnel</span><br><span class="line">        esp_proposals = null-sha-modp2048</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链接测试"><a href="#链接测试" class="headerlink" title="链接测试"></a>链接测试</h2><p>启动 strongSwan 和 Wireshark，在 HostA 上，可以 ping fd00::2 但是不能 ping fd01::2。然后用<code>sudo swanctl -i -c child_sa</code>建立连接，依然可以 ping fd00::2 但是数据不加密，同时能够 ping 通 fd01::2 了。抓包可以看出明显的<code>ETHERNET-IP-ESP-IP-ICMP</code>的包头层次，并且外层 IP 使用 fd00::* 进行数据传输，内层 IP 使用 fd01::* 的实际目的地址：</p><p><img src="/images/ipsec-configurations-part3/02-esp-tunnel-mode-packet-wireshark.png" alt="Tunnel mode packet example"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第三篇简单介绍一下 IPsec 的 Tunnel 模式，没看过前两篇的快去看~&lt;br&gt;&lt;a href=&quot;/2020/10/ipsec-configurations-part1/&quot;&gt;Part1 传送门&lt;/a&gt;；&lt;a href=&quot;/2020/10/ipsec-configurations-part2/&quot;&gt;Part2 传送门&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Tunnel-模式简介&quot;&gt;&lt;a href=&quot;#Tunnel-模式简介&quot; class=&quot;headerlink&quot; title=&quot;Tunnel 模式简介&quot;&gt;&lt;/a&gt;Tunnel 模式简介&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/ipsec-configurations-part3/01-tunnel-mode-header-layout.png&quot; alt=&quot;Tunnel mode header layout&quot;&gt; 前两篇中我们使用的都是 Transport 模式，但是实际使用中，更常用的是 Tunnel 模式。Transport 模式只加密四层及以上数据，而不修改 IP 头，原始的 IP 头将会原样传输。这意味着我们只能进行点对点传输，因为只有一个 IP 头，我们无法告知对方服务器我们实际要访问的地址。Tunnel 模式则是连原始的 IP 头也一起加密，然后再在前端添加一个新的 IP 头，这样服务器在收到数据包后，可以解密并读取内部的 IP 头，再转发给实际的目标服务器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="IPsec" scheme="https://recursiveg.me/tags/IPsec/"/>
    
      <category term="Networking" scheme="https://recursiveg.me/tags/Networking/"/>
    
      <category term="VPN" scheme="https://recursiveg.me/tags/VPN/"/>
    
      <category term="折腾" scheme="https://recursiveg.me/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>IPsec 配置备忘 Part2 - 证书</title>
    <link href="https://recursiveg.me/2020/10/ipsec-configurations-part2/"/>
    <id>https://recursiveg.me/2020/10/ipsec-configurations-part2/</id>
    <published>2020-10-30T15:50:00.000Z</published>
    <updated>2020-10-31T07:24:13.801Z</updated>
    
    <content type="html"><![CDATA[<p>作为系列的第二篇文章，讲解基本的证书原理和配置方法。没看过第一部分的快去看～<br>传送门：<a href="/2020/10/ipsec-configurations-part1/">IPsec 配置备忘 Part1</a>。</p><h2 id="证书认证基础"><a href="#证书认证基础" class="headerlink" title="证书认证基础"></a>证书认证基础</h2><p>我们在 Part1 中看到，PSK 认证的基本思路是使用一个只有通信双方才知道的暗号，如果能确认对方确实知道这个暗号，那么认证就成功了。证书认证的思路非常不同：假设 A 需要向 B 证明自己的身份，同时 A 知道 B 信任 C，那么 A 可以向 C 索取一份“介绍信”，当 B 询问 A 的身份时，A 可以向 B 展示这份 C 出具的“介绍信”，如果 B 能够确认这份“介绍信”确实是由 C 出具的，那么认证就成功了。注意这个认证是单向的，假设 A 也信任 C，那么 B 也可以通过向 C 索取“介绍信”来向 A 证明自己的身份。在 PKI 体系中，A 和 B 持有各自的“私钥”，C 作为 Certificate Authority (CA) 向 A/B 颁发证书（即“介绍信”）。同时，CA 也会向自己颁发一份证书并分发给 A/B，A/B 使用 CA 的证书来确认 B/A 出示的证书确实为 C 所颁发。</p><a id="more"></a><h2 id="使用-certtool-创建证书"><a href="#使用-certtool-创建证书" class="headerlink" title="使用 certtool 创建证书"></a>使用 certtool 创建证书</h2><p>我使用 <a href="https://www.gnutls.org/manual/html_node/certtool-Invocation.html" target="_blank" rel="noopener">certtool</a> 没有什么特别的理由，你也可以用<code>openssl</code>或者 strongSwan 自带的<code>pki</code>工具。我在之前的一篇文章里介绍过如何使用 certtool 创建证书：<a href="/2016/12/assign-ipv6-through-ipsec-and-strongswan/">借助IPsec和strongSwan建立隧道并分配IPv6地址</a>。不过我还是决定再写一遍现在的配置。我们的配置场景和 Part1 中的相同，只不过把 PSK 认证换成了证书认证。</p><p>首先给 HostA, HostB 和 CA 分别创建私钥，我这里用的是 ed25519，一些设备可能不支持，请自行参考文档换成 RSA：</p><pre><code>certtool --generate-privkey --key-type ed25519 --outfile ca-key.pemcerttool --generate-privkey --key-type ed25519 --outfile hosta-key.pemcerttool --generate-privkey --key-type ed25519 --outfile hostb-key.pem</code></pre><p>生成证书时，我们需要手动指定一些证书的信息，比如证书的名称，过期时间等等。证书的 <a href="https://ldapwiki.com/wiki/Distinguished%20Names" target="_blank" rel="noopener">Distinguished Name (DN)</a> 会被用来和 IKEv2 的身份标识符进行匹配，以决定具体向对方出示哪份证书（对于发送者）以及是否接受对方的证书（对于接受者）。这些信息需要写成一个 template 文件才能被 certtool 读取，详细的 template 文件格式可以在 <a href="https://www.gnutls.org/manual/html_node/certtool-Invocation.html" target="_blank" rel="noopener">certtool 的帮助文档</a>里查到。</p><figure class="highlight bash"><figcaption><span>ca.tmpl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Common name, 是 DN 的一部分</span></span><br><span class="line">cn = <span class="string">"CA_COMMON_NAME"</span></span><br><span class="line"><span class="comment"># 组织名，是 DN 的一部分</span></span><br><span class="line">organization = <span class="string">"ORG_NAME"</span></span><br><span class="line"></span><br><span class="line">ca</span><br><span class="line"><span class="comment"># 生效与过期时间</span></span><br><span class="line">activation_date = <span class="string">"2020-01-01 00:00:00 UTC+0"</span></span><br><span class="line">expiration_date = <span class="string">"2030-01-01 00:00:00 UTC+0"</span></span><br><span class="line">cert_signing_key</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>hosta.tmpl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cn = <span class="string">"HOSTA_COMMON_NAME"</span></span><br><span class="line">activation_date = <span class="string">"2020-01-01 00:00:00 UTC+0"</span></span><br><span class="line">expiration_date = <span class="string">"2021-01-01 00:00:00 UTC+0"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>hostb.tmpl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cn = <span class="string">"HOSTB_COMMON_NAME"</span></span><br><span class="line">activation_date = <span class="string">"2020-01-01 00:00:00 UTC+0"</span></span><br><span class="line">expiration_date = <span class="string">"2021-01-01 00:00:00 UTC+0"</span></span><br></pre></td></tr></table></figure><p>然后创建证书：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成自签名 CA 证书</span></span><br><span class="line">certtool --generate-self-signed \</span><br><span class="line">    --template ca.tmpl \</span><br><span class="line">    --load-privkey ca-key.pem \</span><br><span class="line">    --outfile ca-cert.pem</span><br><span class="line"></span><br><span class="line"><span class="comment"># CA 向 HostA 颁发证书</span></span><br><span class="line">certtool --generate-certificate \</span><br><span class="line">    --template hosta.tmpl \</span><br><span class="line">    --load-ca-certificate ca-cert.pem \</span><br><span class="line">    --load-ca-privkey ca-key.pem \</span><br><span class="line">    --load-privkey hosta-key.pem \</span><br><span class="line">    --outfile hosta-cert.pem</span><br><span class="line"></span><br><span class="line"><span class="comment"># CA 向 HostB 颁发证书    </span></span><br><span class="line">certtool --generate-certificate \</span><br><span class="line">    --template hostb.tmpl \</span><br><span class="line">    --load-ca-certificate ca-cert.pem \</span><br><span class="line">    --load-ca-privkey ca-key.pem \</span><br><span class="line">    --load-privkey hostb-key.pem \</span><br><span class="line">    --outfile hostb-cert.pem</span><br></pre></td></tr></table></figure><p>最终会生成的 6 个文件，你可以使用<code>certtool --key-info &lt; hosta-key.pem</code>来查看私钥信息，用<code>certtool --certificate-info &lt; hosta-cert.pem</code>来查看证书信息，用<code>certtool --verify --load-ca-certificate ca-cert.pem &lt; hosta-cert.pem</code>来检查证书是否确实是由 CA 签发的。其中：</p><ul><li><code>hosta-key.pem, hosta-cert.pem, ca-cert.pem</code> 需要拷贝到 HostA 上</li><li><code>hostb-key.pem, hostb-cert.pem, ca-cert.pem</code> 需要拷贝到 HostB 上</li><li><code>ca-key.pem</code> 留在本地好好保管不要交给任何人。</li></ul><p>对于 strongSwan，私钥<code>*-key.pem</code>需要放置在<code>/etc/swanctl/private</code>，私钥对应的证书<code>host*-cert.pem</code>需要放置在<code>/etc/swanctl/x509</code>，CA 证书<code>ca-cert.pem</code>需要放置在<code>/etc/swanctl/x509ca</code>。</p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>基本上和 Part1 中的配置一样，有不同之处已经加了注释</p><figure class="highlight bash"><figcaption><span>hosta.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">connections &#123;</span><br><span class="line">  conn_hosta_hostb &#123;</span><br><span class="line">    version = 2</span><br><span class="line">    local_addrs = fd00::1</span><br><span class="line">    remote_addrs = fd00::2</span><br><span class="line">    proposals = aes256gcm128-sha512-x25519</span><br><span class="line">    <span class="built_in">local</span> &#123;</span><br><span class="line">      <span class="comment"># id 是证书的 DN，由于我们在 hosta.tmpl 里只指定了 CN，</span></span><br><span class="line">      <span class="comment"># 所以 DN 就是 "CN=&#123;...&#125;"。这个 id 会被发送给对方，</span></span><br><span class="line">      <span class="comment"># 同时对应的证书/密钥对（hosta-cert/key.pem）会被选中，</span></span><br><span class="line">      <span class="comment"># 作为对 id 的证明。</span></span><br><span class="line">      id = CN=HOSTA_COMMON_NAME</span><br><span class="line">      <span class="comment"># 使用证书作为身份标识符的证明方式</span></span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    remote &#123;</span><br><span class="line">      <span class="comment"># 接受任何 id，只要这个 id 能通过证书验证</span></span><br><span class="line">      <span class="comment"># i.e. 只要对方出示的证书确实是由某个 CA 签署的即可。</span></span><br><span class="line">      id = %any</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    children &#123;</span><br><span class="line">      child_sa &#123;</span><br><span class="line">        local_ts = fd00::1/128</span><br><span class="line">        remote_ts = fd00::2/128</span><br><span class="line">        mode = transport</span><br><span class="line">        esp_proposals = aes256gcm128-sha512-x25519</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不需要 secrets 指定 PSK 了。</span></span><br></pre></td></tr></table></figure><p>将<code>remote.id</code>设置成<code>%any</code>会有一定的安全问题，比如 HostA 是服务器，HostB 和 HostC 是客户端，如果 HostB 连接 HostA 的时候不检查 id，那么如果 HostC 能劫持 IP 地址，它就能假装成 HostA。毕竟 HostB 不关心它连接的到底是 A 还是 C。解决方法也很简单，指定<code>remote.id</code>为<code>CN=HOSTB_COMMON_NAME</code>即可。</p><p>HostB 的配置除了<code>local.id</code>外完全一致</p><figure class="highlight bash"><figcaption><span>hostb.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">connections &#123;</span><br><span class="line">  conn_hosta_hostb &#123;</span><br><span class="line">    version = 2</span><br><span class="line">    local_addrs = fd00::1</span><br><span class="line">    remote_addrs = fd00::2</span><br><span class="line">    proposals = aes256gcm128-sha512-x25519</span><br><span class="line">    <span class="built_in">local</span> &#123;</span><br><span class="line">      id = CN=HOSTB_COMMON_NAME <span class="comment"># 使用 HostB 的证书的 DN</span></span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    remote &#123;</span><br><span class="line">      id = %any</span><br><span class="line">      auth = pubkey</span><br><span class="line">    &#125;</span><br><span class="line">    children &#123;</span><br><span class="line">      child_sa &#123;</span><br><span class="line">        local_ts = fd00::1/128</span><br><span class="line">        remote_ts = fd00::2/128</span><br><span class="line">        mode = transport</span><br><span class="line">        esp_proposals = aes256gcm128-sha512-x25519</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链接测试"><a href="#链接测试" class="headerlink" title="链接测试"></a>链接测试</h2><p>同 Part1，在任意一侧使用<code>sudo swanctl -i -c child_sa</code>建立连接即可。连接建立后抓包即可看到加密流量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为系列的第二篇文章，讲解基本的证书原理和配置方法。没看过第一部分的快去看～&lt;br&gt;传送门：&lt;a href=&quot;/2020/10/ipsec-configurations-part1/&quot;&gt;IPsec 配置备忘 Part1&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;证书认证基础&quot;&gt;&lt;a href=&quot;#证书认证基础&quot; class=&quot;headerlink&quot; title=&quot;证书认证基础&quot;&gt;&lt;/a&gt;证书认证基础&lt;/h2&gt;&lt;p&gt;我们在 Part1 中看到，PSK 认证的基本思路是使用一个只有通信双方才知道的暗号，如果能确认对方确实知道这个暗号，那么认证就成功了。证书认证的思路非常不同：假设 A 需要向 B 证明自己的身份，同时 A 知道 B 信任 C，那么 A 可以向 C 索取一份“介绍信”，当 B 询问 A 的身份时，A 可以向 B 展示这份 C 出具的“介绍信”，如果 B 能够确认这份“介绍信”确实是由 C 出具的，那么认证就成功了。注意这个认证是单向的，假设 A 也信任 C，那么 B 也可以通过向 C 索取“介绍信”来向 A 证明自己的身份。在 PKI 体系中，A 和 B 持有各自的“私钥”，C 作为 Certificate Authority (CA) 向 A/B 颁发证书（即“介绍信”）。同时，CA 也会向自己颁发一份证书并分发给 A/B，A/B 使用 CA 的证书来确认 B/A 出示的证书确实为 C 所颁发。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="IPsec" scheme="https://recursiveg.me/tags/IPsec/"/>
    
      <category term="Networking" scheme="https://recursiveg.me/tags/Networking/"/>
    
      <category term="VPN" scheme="https://recursiveg.me/tags/VPN/"/>
    
      <category term="折腾" scheme="https://recursiveg.me/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>IPsec 配置备忘 Part1 - IKEv2 基础</title>
    <link href="https://recursiveg.me/2020/10/ipsec-configurations-part1/"/>
    <id>https://recursiveg.me/2020/10/ipsec-configurations-part1/</id>
    <published>2020-10-29T15:40:00.000Z</published>
    <updated>2020-10-31T06:23:16.065Z</updated>
    
    <content type="html"><![CDATA[<p>俗话说得好，配置 IPsec 隧道只有零次和无数次，在被 strongSwan 折磨了 N 次以后，我终于决定要把之前试过的配置都记录下来，于是就有了这个系列。我计划基本上每个 PART 会介绍一个（或几个）特定场景下的配置，配置文件样例以 strongSwan vici 为主，之后可能会介绍 iOS, Android 或者是 Mikrotik 路由器的配置方法，如果我能坚持不鸽写到那里的话（画外音：你这 FLAG 立得……）。如果各位有想看的配置场景欢迎留言告诉我，会考虑先写。</p><h2 id="IKEv2-与-IPsec-基础"><a href="#IKEv2-与-IPsec-基础" class="headerlink" title="IKEv2 与 IPsec 基础"></a>IKEv2 与 IPsec 基础</h2><p>严格来说 IKEv2 不是 VPN，它的全称是 Internet Key Exchange，只是一种用于交换密钥的协议罢了。密钥在计算机里一般就表示为一串固定长度的二进制数据，密钥交换就是指在两台设备之间约定一个相同的二进制串，就像两个密友之间约定暗号一样。一旦密钥交换完毕，IKE 的使命就结束了，具体怎么用约定好的密钥加密数据不是 IKE 解决的问题。在 Linux 系统上，实际的数据包加密解密是由内核的 XFRM 框架负责的，你可以使用<code>ip xfrm</code>命令看到配置好的密钥以及加解密使用的算法。事实上，不使用 IKEv2 而完全手动“交换”密钥是可行的，比如<a href="https://gist.github.com/blackgear/a9f96261b091b2215dfd" target="_blank" rel="noopener">朴素VPN：一个纯内核级静态隧道</a>。你可以看到作者直接使用<code>ip xfrm {policy,state} add</code>指令设定密钥，然后内核就会自动用设定的密钥加密流量。</p><p>然而，手动管理内核状态是复杂的，人工分发密钥也不怎么安全，这时就轮到 strongSwan 登场啦（或者说，任何实现了 IKE 的 Daemon 服务）。两台服务器的 strongSwan 使用 IKEv2 协议交换密钥，解决了密钥分发的问题。随后 strongSwan 会把交换得来的密钥设定进内核，这样内核就会自动加密指定的流量了。</p><p>从数据包层面上看，IKE 是7层协议，密钥交换使用特殊的 UDP 包完成。而一般被加密的数据包会使用 ESP 封装，ESP 头一般紧跟在 IP 头后。ESP 也可以被封装进 UDP 用以穿越 NAT。</p><h2 id="没有-TUN-设备"><a href="#没有-TUN-设备" class="headerlink" title="没有 TUN 设备"></a>没有 TUN 设备</h2><p>内核 XFRM 的工作方式和基于 TUN 设备的 VPN 很不一样。一般基于 TUN 的 VPN 会加密所有进入 TUN 设备的流量，因此你可以直接使用路由表来控制哪些流量走 VPN，哪些不走。而 XFRM 的匹配基于策略（i.e. 源地址+目标地址+一些别的），如果某个数据包匹配到了一个策略，这个数据包就会根据这个策略指定的方式被加密。</p><p>比方说有<code>A [fd00::1]</code>和<code>B [fd00::2]</code>，如果你从 A 发送一个数据包到 B，普通情况下这个数据包是明文的。如果你在 A 配置了<code>src=fd00::1,dst=fd00::2,encrypt=&lt;...&gt;</code>的策略并再发一个数据包，这个包就会自动被加密。B 收到了这个数据包，但是它并不知道该如何解密，所以你必须同时在 B 配置一条<code>src=fd00::1,dst=fd00::2,decrypt=&lt;...&gt;</code>的策略，这样 B 才能解密。对于从 B 到 A 的流量也需要类似的两条策略。使用 IKEv2 的话，这些策略 strongSwan 都会自动帮你设置好，无需操心。于是你会发现，尽管我们仍然在使用节点本身的 IP，但是流量却已经被加密了。</p><p>对于那些必须使用路由表或是策略匹配不是很有效的场景, <a href="https://wiki.strongswan.org/projects/strongswan/wiki/RouteBasedVPN" target="_blank" rel="noopener">Route-based IPsec VPN</a> 也是存在的。我也许会在未来的某一期讲。</p><a id="more"></a><h2 id="一些-IKEv2-的细节"><a href="#一些-IKEv2-的细节" class="headerlink" title="一些 IKEv2 的细节"></a>一些 IKEv2 的细节</h2><p>IKEv2 除了交换密钥以外，还负责包括身份认证，协议协商等一系列其他工作。实际使用的时候，我们一般需要指定这些参数：</p><ul><li>对方的 IKE 服务器地址</li><li>自己的身份标识符</li><li>能接受的对方的身份标识符，可选。</li><li>对自己身份标识符的证明，一般是 PSK (预共享密钥) 或者是证书。</li><li>对对方身份标识符证明的验证方式，比方说，如果对方使用证书认证其身份，则可以通过检查 CA 证书链的方式来证明其证书的有效性。</li><li>自己能接受的 Cipher suite</li><li>Local traffic selector</li><li>Remote traffic selector</li></ul><p>以上所有这些参数需要在两端都配置。其中，cipher suite 需要至少指定两次，原因是 IKEv2 是一个两阶段协议，两阶段使用的 cipher suite 可以不同。在第一阶段会简单地进行一次 DH 密钥交换，建立 IKE_SA，然后进入第二阶段。二阶段中的身份认证，traffic selector 协商等均会被加密。在二阶段 IKE 会建立 CHILD_SA，也是用来加密实际数据的 SA，CHILD_SA 的协商结果，包括密钥，加密算法，traffic selector 等均会被设定入内核，以便内核进行实际的加密操作。</p><p><a href="https://docs.paloaltonetworks.com/pan-os/9-0/pan-os-admin/vpns/site-to-site-vpn-concepts/ikev2/traffic-selectors.html" target="_blank" rel="noopener">Traffic selector</a> 决定了内核匹配数据包的策略，即，哪些数据需要被加密。比方说，一个 VPN 客户端可能会设定 <code>local_ts=10.0.0.14/32, remote_ts=0.0.0.0/0</code> 这意味着该客户端希望所有流量都被加密。而一个服务器可能会设定 <code>local_ts=&lt;所有非中国大陆IP&gt;, remote_ts=10.0.0.14/32</code>，这说明该服务器不希望处理去往中国大陆 IP 的流量。如果这两者进行协商，结果客户端就不会将去往中国大陆 IP 的流量发送给服务端。这也被称作 <a href="https://wiki.strongswan.org/projects/strongswan/wiki/ForwardingAndSplitTunneling" target="_blank" rel="noopener">Split Tunneling</a>。</p><h2 id="简单-Host-to-Host-配置"><a href="#简单-Host-to-Host-配置" class="headerlink" title="简单 Host-to-Host 配置"></a>简单 Host-to-Host 配置</h2><p>这是一份简单的 Host-to-Host 配置样例，场景和<code>没有 TUN 设备</code>中描述的一致。我在本地的两台物理机上进行配置，两台机器使用网线直连，并用<code>ip addr add fd00::{1,2}/64 dev &lt;name&gt;</code>手动配置 IP。认证方式使用 PSK。在 Archlinux 上，配置文件位于<code>/etc/swanctl/swanctl.conf</code>。使用<code>sudo systemctl start strongswan</code>来启动 strongSwan。</p><p>这是 HostA 的配置:</p><figure class="highlight bash"><figcaption><span>hosta.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">connections &#123;</span><br><span class="line">  conn_hosta_hostb &#123;</span><br><span class="line">    <span class="comment"># IKEv2</span></span><br><span class="line">    version = 2</span><br><span class="line">    <span class="comment"># 本地 IKEv2 服务地址</span></span><br><span class="line">    local_addrs = fd00::1</span><br><span class="line">    <span class="comment"># 对方 IKEv2 服务地址</span></span><br><span class="line">    remote_addrs = fd00::2</span><br><span class="line">    <span class="comment"># IKE_SA 的 cipher suite</span></span><br><span class="line">    proposals = aes256gcm128-sha512-x25519</span><br><span class="line">    <span class="built_in">local</span> &#123;</span><br><span class="line">      id = hosta     <span class="comment"># 己方身份标识符</span></span><br><span class="line">      auth = psk     <span class="comment"># 己方身份标识符的证明方式</span></span><br><span class="line">    &#125;</span><br><span class="line">    remote &#123;</span><br><span class="line">      id = %any      <span class="comment"># 对方身份标识符，这里接受任意标识符</span></span><br><span class="line">      auth = psk     <span class="comment"># 对方身份标识符证明的验证方式</span></span><br><span class="line">    &#125;</span><br><span class="line">    children &#123;       <span class="comment"># 列出需要建立的 CHILD_SA</span></span><br><span class="line">      child_sa &#123;     <span class="comment"># 只有一个 CHILD_SA, 叫做 "child_sa"</span></span><br><span class="line">        local_ts = fd00::1/128  <span class="comment"># Local traffic selector</span></span><br><span class="line">        remote_ts = fd00::2/128 <span class="comment"># Remote traffic selector</span></span><br><span class="line">        mode = transport        <span class="comment"># 使用 Tansport 模式而不是 Tunnel 模式</span></span><br><span class="line">        <span class="comment"># CHILD_SA 的 cipher suite, 其实这里用的和 IKE_SA 的是一样的</span></span><br><span class="line">        esp_proposals = aes256gcm128-sha512-x25519</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">secrets &#123;</span><br><span class="line">  ike_hosta &#123;</span><br><span class="line">    <span class="comment"># 发送己方身份时，使用这个 PSK</span></span><br><span class="line">    id = hosta</span><br><span class="line">    secret = pwd_for_hosta</span><br><span class="line">  &#125;</span><br><span class="line">  ike_hostb &#123;</span><br><span class="line">    <span class="comment"># 对方发送的身份标识符是"hostb"，会匹配到这个 PSK</span></span><br><span class="line">    <span class="comment"># 实际操作中一般不这么写，而是把两个 id 写到同一个 ike_* 块中，共用 secret。</span></span><br><span class="line">    id = hostb</span><br><span class="line">    secret = pwd_for_hostb</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HostB 的配置，几乎一样：</p><figure class="highlight bash"><figcaption><span>hostb.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">connections &#123;</span><br><span class="line">  conn_hosta_hostb &#123;</span><br><span class="line">    version = 2</span><br><span class="line">    local_addrs = fd00::2  <span class="comment"># IP 地址交换一下</span></span><br><span class="line">    remote_addrs = fd00::1</span><br><span class="line">    proposals = aes256gcm128-sha512-x25519</span><br><span class="line">    <span class="built_in">local</span> &#123;</span><br><span class="line">      id = hostb  <span class="comment"># 标识符改一下</span></span><br><span class="line">      auth = psk</span><br><span class="line">    &#125;</span><br><span class="line">    remote &#123;</span><br><span class="line">      id = %any</span><br><span class="line">      auth = psk</span><br><span class="line">    &#125;</span><br><span class="line">    children &#123;</span><br><span class="line">      child_sa &#123;</span><br><span class="line">        local_ts = fd00::2/128  <span class="comment"># IP 地址交换一下</span></span><br><span class="line">        remote_ts = fd00::1/128</span><br><span class="line">        mode = transport</span><br><span class="line">        esp_proposals = aes256gcm128-sha512-x25519</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">secrets &#123;</span><br><span class="line">  ike_hosta &#123;</span><br><span class="line">    id = hosta</span><br><span class="line">    secret = pwd_for_hosta</span><br><span class="line">  &#125;</span><br><span class="line">  ike_hostb &#123;</span><br><span class="line">    id = hostb</span><br><span class="line">    secret = pwd_for_hostb</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链接测试"><a href="#链接测试" class="headerlink" title="链接测试"></a>链接测试</h2><p>测试之前需要先检查一下 IP 掩码的长度，如果和我一样使用<code>/64</code>的话，可能会受到<code>bypass-lan</code>插件的干扰，导致数据不被加密。需要去<code>/etc/strongswan.d/charon/bypass-lan.conf</code>把它关掉。然后重启 strongSwan 即可。由于我们没有配置自动连接，所以启动 strongSwan 后数据流还是未加密的：</p><pre><code>23:50:29.873728 IP6 (flowlabel 0xe3038, hlim 64, next-header ICMPv6 (58) payload length: 64) fd00::1 &gt; fd00::2: [icmp6 sum ok] ICMP6, echo request, seq 1  0x0000:  600e 3038 0040 3a40 fd00 0000 0000 0000  `.08.@:@........  0x0010:  0000 0000 0000 0001 fd00 0000 0000 0000  ................  0x0020:  0000 0000 0000 0002 8000 02ec 001d 0001  ................  0x0030:  15ed 9c5f 0000 0000 0457 0d00 0000 0000  ..._.....W......  0x0040:  1011 1213 1415 1617 1819 1a1b 1c1d 1e1f  ................  0x0050:  2021 2223 2425 2627 2829 2a2b 2c2d 2e2f  .!&quot;#$%&amp;&apos;()*+,-./  0x0060:  3031 3233 3435 3637                      01234567</code></pre><p>需要使用 <code>swanctl</code> 手动建立连接：</p><pre><code>sudo swanctl -i -c child_sa</code></pre><p>你应该能看到 IKEv2 的四个 UDP 包，然后再 ping，数据就是加密的了：</p><pre><code>23:51:18.731508 IP6 (flowlabel 0xe3038, hlim 64, next-header ESP (50) payload length: 100) fd00::1 &gt; fd00::2: ESP(spi=0xc704dbda,seq=0x1), length 100  0x0000:  600e 3038 0064 3240 fd00 0000 0000 0000  `.08.d2@........  0x0010:  0000 0000 0000 0001 fd00 0000 0000 0000  ................  0x0020:  0000 0000 0000 0002 c704 dbda 0000 0001  ................  0x0030:  dc51 b5d7 bef1 bce6 da9d 74b2 7e6c 482d  .Q........t.~lH-  0x0040:  d9db 6e37 24d6 9fc6 10bb 525c e308 bc76  ..n7$.....R\...v  0x0050:  9d26 74d6 64ff ef55 5a54 5f95 94c7 01cf  .&amp;t.d..UZT_.....  0x0060:  2ae7 51b2 db41 439b 4d37 1f1e 3075 74d1  *.Q..AC.M7..0ut.  0x0070:  25dc 2990 8c07 b484 a37e b052 e5fc 8709  %.)......~.R....  0x0080:  e229 c79d 0816 0ae5 5c8b 652f            .)......\.e/</code></pre><h2 id="strongSwan-调试技巧"><a href="#strongSwan-调试技巧" class="headerlink" title="strongSwan 调试技巧"></a>strongSwan 调试技巧</h2><p>在 Archlinux 上，strongSwan 的日志级别控制在<code>/etc/strongswan.d/charon-systemd.conf</code>。另外，strongSwan 支持 NULL 加密（即不加密）以方便调试，将<code>proposals</code>和<code>esp_proposals</code>修改为如下值即可：</p><pre><code>proposals = null-sha-modp2048esp_proposals = null-sha-modp2048</code></pre><p>然后在 Wireshark 中选中 <code>Attempt to detect/decode NULL encrypted ESP payloads</code> 即可直接查看数据包内容：</p><p><img src="/images/ipsec-configurations-part1/null-encrypt-wireshark.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;俗话说得好，配置 IPsec 隧道只有零次和无数次，在被 strongSwan 折磨了 N 次以后，我终于决定要把之前试过的配置都记录下来，于是就有了这个系列。我计划基本上每个 PART 会介绍一个（或几个）特定场景下的配置，配置文件样例以 strongSwan vici 为主，之后可能会介绍 iOS, Android 或者是 Mikrotik 路由器的配置方法，如果我能坚持不鸽写到那里的话（画外音：你这 FLAG 立得……）。如果各位有想看的配置场景欢迎留言告诉我，会考虑先写。&lt;/p&gt;
&lt;h2 id=&quot;IKEv2-与-IPsec-基础&quot;&gt;&lt;a href=&quot;#IKEv2-与-IPsec-基础&quot; class=&quot;headerlink&quot; title=&quot;IKEv2 与 IPsec 基础&quot;&gt;&lt;/a&gt;IKEv2 与 IPsec 基础&lt;/h2&gt;&lt;p&gt;严格来说 IKEv2 不是 VPN，它的全称是 Internet Key Exchange，只是一种用于交换密钥的协议罢了。密钥在计算机里一般就表示为一串固定长度的二进制数据，密钥交换就是指在两台设备之间约定一个相同的二进制串，就像两个密友之间约定暗号一样。一旦密钥交换完毕，IKE 的使命就结束了，具体怎么用约定好的密钥加密数据不是 IKE 解决的问题。在 Linux 系统上，实际的数据包加密解密是由内核的 XFRM 框架负责的，你可以使用&lt;code&gt;ip xfrm&lt;/code&gt;命令看到配置好的密钥以及加解密使用的算法。事实上，不使用 IKEv2 而完全手动“交换”密钥是可行的，比如&lt;a href=&quot;https://gist.github.com/blackgear/a9f96261b091b2215dfd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;朴素VPN：一个纯内核级静态隧道&lt;/a&gt;。你可以看到作者直接使用&lt;code&gt;ip xfrm {policy,state} add&lt;/code&gt;指令设定密钥，然后内核就会自动用设定的密钥加密流量。&lt;/p&gt;
&lt;p&gt;然而，手动管理内核状态是复杂的，人工分发密钥也不怎么安全，这时就轮到 strongSwan 登场啦（或者说，任何实现了 IKE 的 Daemon 服务）。两台服务器的 strongSwan 使用 IKEv2 协议交换密钥，解决了密钥分发的问题。随后 strongSwan 会把交换得来的密钥设定进内核，这样内核就会自动加密指定的流量了。&lt;/p&gt;
&lt;p&gt;从数据包层面上看，IKE 是7层协议，密钥交换使用特殊的 UDP 包完成。而一般被加密的数据包会使用 ESP 封装，ESP 头一般紧跟在 IP 头后。ESP 也可以被封装进 UDP 用以穿越 NAT。&lt;/p&gt;
&lt;h2 id=&quot;没有-TUN-设备&quot;&gt;&lt;a href=&quot;#没有-TUN-设备&quot; class=&quot;headerlink&quot; title=&quot;没有 TUN 设备&quot;&gt;&lt;/a&gt;没有 TUN 设备&lt;/h2&gt;&lt;p&gt;内核 XFRM 的工作方式和基于 TUN 设备的 VPN 很不一样。一般基于 TUN 的 VPN 会加密所有进入 TUN 设备的流量，因此你可以直接使用路由表来控制哪些流量走 VPN，哪些不走。而 XFRM 的匹配基于策略（i.e. 源地址+目标地址+一些别的），如果某个数据包匹配到了一个策略，这个数据包就会根据这个策略指定的方式被加密。&lt;/p&gt;
&lt;p&gt;比方说有&lt;code&gt;A [fd00::1]&lt;/code&gt;和&lt;code&gt;B [fd00::2]&lt;/code&gt;，如果你从 A 发送一个数据包到 B，普通情况下这个数据包是明文的。如果你在 A 配置了&lt;code&gt;src=fd00::1,dst=fd00::2,encrypt=&amp;lt;...&amp;gt;&lt;/code&gt;的策略并再发一个数据包，这个包就会自动被加密。B 收到了这个数据包，但是它并不知道该如何解密，所以你必须同时在 B 配置一条&lt;code&gt;src=fd00::1,dst=fd00::2,decrypt=&amp;lt;...&amp;gt;&lt;/code&gt;的策略，这样 B 才能解密。对于从 B 到 A 的流量也需要类似的两条策略。使用 IKEv2 的话，这些策略 strongSwan 都会自动帮你设置好，无需操心。于是你会发现，尽管我们仍然在使用节点本身的 IP，但是流量却已经被加密了。&lt;/p&gt;
&lt;p&gt;对于那些必须使用路由表或是策略匹配不是很有效的场景, &lt;a href=&quot;https://wiki.strongswan.org/projects/strongswan/wiki/RouteBasedVPN&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Route-based IPsec VPN&lt;/a&gt; 也是存在的。我也许会在未来的某一期讲。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="IPsec" scheme="https://recursiveg.me/tags/IPsec/"/>
    
      <category term="Networking" scheme="https://recursiveg.me/tags/Networking/"/>
    
      <category term="VPN" scheme="https://recursiveg.me/tags/VPN/"/>
    
      <category term="折腾" scheme="https://recursiveg.me/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>Linux + Windows 10 多系统安装 U 盘</title>
    <link href="https://recursiveg.me/2020/10/linux-windows-multiboot-usb/"/>
    <id>https://recursiveg.me/2020/10/linux-windows-multiboot-usb/</id>
    <published>2020-10-24T16:50:00.000Z</published>
    <updated>2020-11-05T00:06:24.634Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong><em>Update:</em></strong> Windows 的引导程序似乎有些问题，如果在同一块 U 盘上写入多个 ISO 分区的话，似乎引导会错乱，最终启动的安装程序版本不是引导程序所在分区的版本。所以暂时一个 U 盘还是只能放一个 Windows 版本。垃圾巨硬。</p></blockquote><p>日常折腾中总免不了要用 LiveCD 修理一下系统，或者是重装一下 Windows 之类的。这时候制作一个引导用的 U 盘基本是最方便的选项了。有不少工具都能创建 U 盘引导，比如 ArchLinux 的 ISO 镜像可以直接用<code>dd</code>写入，Windows 的安装盘也能用 <a href="https://rufus.ie" target="_blank" rel="noopener">Rufus</a> 创建。不过在使用上还是有些不便，比如<code>dd</code>会覆盖整个U盘，在ISO之外不能再存储其他文件。Rufus 只能在 Windows 上运行，而且一只 U 盘也只能放一份 ISO。于是尝试搞明白怎么把 Linux 的 LiveCD 和 Windows 的安装 ISO 写入到同一只 U 盘就很有必要了。</p><p>我个人使用的设备都支持 UEFI，所以这里制作的启动盘也只支持 UEFI 启动，需要 MBR 模式启动的读者请往它处寻。当然，Secure Boot 是要关掉的。制作过程我使用 Linux，纯 Windows 用户现在也可以退出了。基本上，我们需要创建一个 EFI 系统分区（EFI System Partition, ESP），其中包含基本的引导程序（Grub2）和 Linux LiveCD 的 ISO 文件。由于 Windows 的安装程序无法以 ISO 形式被引导，因此我们需要给每个 Windows ISO 文件创建一个分区，并将 ISO 中的内容解压进去。但是分区一旦创建不像文件那么好修改，所以创建每个 Windows ISO 分区的时候我都留了一些额外空间，以备以后 ISO 大小变化，这也意味着这些空间就基本浪费了。That&#39;s sad but I guess it&#39;s how things work.</p><p>另外，购买一个优质的 U 盘还是有必要的，不然不管是创建启动盘还是安装系统都会慢得让你痛不欲生。建议用之前先给 U 盘测一下速，什么拷贝速度只有 2MB/s 的金士顿可以直接进垃圾桶了。至于 U 盘大小取决于你要放多少个 ISO 文件和多少个 Windows 分区，一般 Linux 镜像大小在 500MB~3GB 的都有，Windows 10 的分区一般每个需要 5~6GB.</p><a id="more"></a><p>先给 U 盘分区，用<code>fdisk</code>或者别的什么工具都行。我用的 32GB 的 U 盘，分了 6GB 给 ESP，然后是另外两个 6GB 的分区给 Windows 10 的安装程序。剩下空间留着给以后使用。</p><p>然后格式化，ESP 需要 FAT32，Windows 分区用 NTFS 即可。记得多次检查盘符，不然格式化错盘就不好玩了。我给 NTFS 设置的卷标和 ISO 的一致，可以用<code>file &lt;img.iso&gt;</code>看到，不过我不确定这是不是必须的。</p><pre><code>sudo mkfs.fat -F 32 /dev/sdXYsudo mkfs.ntfs -f -L CPBA_X64FRE_ZH-CN_DV9 /dev/sdXY</code></pre><p>然后把 GRUB2 安装到 ESP 分区上，假设你的 ESP 分区挂载在了<code>$esp</code>:</p><pre><code>sudo grub-install --target=x86_64-efi --removable --boot-directory=$esp/boot --efi-directory=$esp</code></pre><p>接着复制 ISO 文件到 U 盘。Linux 的 ISO 可以直接放在 ESP 分区里的任意位置，我放在了<code>$esp/boot/iso/</code>。Windows ISO 需要用 7z 之类的工具解压到 NTFS 分区里：</p><pre><code>7z x cn_windows_10_business_editions_version_1909_updated_dec_2019_x64_dvd_262ac8af.iso -o&apos;/run/media/recursiveg/CPBA_X64FRE_ZH-CN_DV9&apos;</code></pre><p>最后需要手工编写<code>$esp/boot/grub/grub.cfg</code>文件。我从我系统的配置里复制了一部分图形初始化的指令，然后写了用来引导 LiveCD 和 Windows 的菜单项。一般每个发行版的启动命令都会不一样，需要自己查询。Windows 启动项中<code>search</code>的<code>--label</code>参数需要和格式化时设置的一样，当然你也可以用 UUID 等别的标识符。我还另外拷贝了一个 UEFI Shell 到 U 盘里。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># copied from arch boot config</span></span><br><span class="line"><span class="keyword">function</span> load_video &#123;</span><br><span class="line">  <span class="keyword">if</span> [ x<span class="variable">$feature_all_video_module</span> = xy ]; <span class="keyword">then</span></span><br><span class="line">    insmod all_video</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    insmod efi_gop</span><br><span class="line">    insmod efi_uga</span><br><span class="line">    insmod ieee1275_fb</span><br><span class="line">    insmod vbe</span><br><span class="line">    insmod vga</span><br><span class="line">    insmod video_bochs</span><br><span class="line">    insmod video_cirrus</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> loadfont unicode ; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">set</span> gfxmode=auto</span><br><span class="line">  load_video</span><br><span class="line">  insmod gfxterm</span><br><span class="line">  <span class="built_in">set</span> locale_dir=<span class="variable">$prefix</span>/locale</span><br><span class="line">  <span class="comment">#set lang=zh_CN</span></span><br><span class="line">  insmod gettext</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">insmod part_gpt</span><br><span class="line">insmod search_fs_uuid</span><br><span class="line"></span><br><span class="line"><span class="comment"># path to the partition holding ISO images (using UUID)</span></span><br><span class="line">probe -u <span class="variable">$root</span> --<span class="built_in">set</span>=rootuuid</span><br><span class="line"><span class="built_in">set</span> imgdevpath=<span class="string">"/dev/disk/by-uuid/<span class="variable">$rootuuid</span>"</span></span><br><span class="line"></span><br><span class="line">menuentry <span class="string">'archlinux-2020.10.01-x86_64.iso'</span> &#123;</span><br><span class="line">  <span class="built_in">set</span> isofile=<span class="string">'/boot/iso/archlinux-2020.10.01-x86_64.iso'</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">'Mounting archlinux-2020.10.01-x86_64.iso ...'</span></span><br><span class="line">  loopback loop <span class="variable">$isofile</span></span><br><span class="line">  linux (loop)/arch/boot/x86_64/vmlinuz-linux img_dev=<span class="variable">$imgdevpath</span> img_loop=<span class="variable">$isofile</span> earlymodules=loop</span><br><span class="line">  initrd (loop)/arch/boot/intel-ucode.img (loop)/arch/boot/amd-ucode.img (loop)/arch/boot/x86_64/initramfs-linux.img</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">menuentry <span class="string">"ubuntu-20.04.1-desktop-amd64.iso"</span> &#123;</span><br><span class="line">  <span class="built_in">set</span> isofile=<span class="string">"/boot/iso/ubuntu-20.04.1-desktop-amd64.iso"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">'Mounting ubuntu-20.04.1-desktop-amd64.iso ...'</span></span><br><span class="line">  loopback loop <span class="variable">$isofile</span></span><br><span class="line">  linux (loop)/casper/vmlinuz boot=casper iso-scan/filename=<span class="variable">$isofile</span> noprompt noeject</span><br><span class="line">  initrd (loop)/casper/initrd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">menuentry <span class="string">"Windows 10 Installer (CN Business editions 1909 Dec 2019)"</span> &#123;</span><br><span class="line">  insmod ntfs</span><br><span class="line">  search --no-floppy --<span class="built_in">set</span>=root --label CPBA_X64FRE_ZH-CN_DV9</span><br><span class="line">  chainloader /efi/boot/bootx64.efi</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Booting windows ..."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">menuentry <span class="string">"Windows 10 Installer (CN Oct 2020)"</span> &#123;</span><br><span class="line">  insmod ntfs</span><br><span class="line">  search --no-floppy --<span class="built_in">set</span>=root --label CCCOMA_X64FRE_ZH-CN_DV9</span><br><span class="line">  chainloader /efi/boot/bootx64.efi</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Booting windows ..."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">menuentry <span class="string">"shellx64_v2.efi"</span> &#123;</span><br><span class="line">  chainloader /boot/shellx64_v2.efi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">menuentry <span class="string">"Enter BIOS setup"</span> &#123;</span><br><span class="line">  fwsetup</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全部设置好以后可以用虚拟机测试一下是不是所有项目都能正常启动，如果都没有问题就 OK 了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Update:&lt;/em&gt;&lt;/strong&gt; Windows 的引导程序似乎有些问题，如果在同一块 U 盘上写入多个 ISO 分区的话，似乎引导会错乱，最终启动的安装程序版本不是引导程序所在分区的版本。所以暂时一个 U 盘还是只能放一个 Windows 版本。垃圾巨硬。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;日常折腾中总免不了要用 LiveCD 修理一下系统，或者是重装一下 Windows 之类的。这时候制作一个引导用的 U 盘基本是最方便的选项了。有不少工具都能创建 U 盘引导，比如 ArchLinux 的 ISO 镜像可以直接用&lt;code&gt;dd&lt;/code&gt;写入，Windows 的安装盘也能用 &lt;a href=&quot;https://rufus.ie&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Rufus&lt;/a&gt; 创建。不过在使用上还是有些不便，比如&lt;code&gt;dd&lt;/code&gt;会覆盖整个U盘，在ISO之外不能再存储其他文件。Rufus 只能在 Windows 上运行，而且一只 U 盘也只能放一份 ISO。于是尝试搞明白怎么把 Linux 的 LiveCD 和 Windows 的安装 ISO 写入到同一只 U 盘就很有必要了。&lt;/p&gt;
&lt;p&gt;我个人使用的设备都支持 UEFI，所以这里制作的启动盘也只支持 UEFI 启动，需要 MBR 模式启动的读者请往它处寻。当然，Secure Boot 是要关掉的。制作过程我使用 Linux，纯 Windows 用户现在也可以退出了。基本上，我们需要创建一个 EFI 系统分区（EFI System Partition, ESP），其中包含基本的引导程序（Grub2）和 Linux LiveCD 的 ISO 文件。由于 Windows 的安装程序无法以 ISO 形式被引导，因此我们需要给每个 Windows ISO 文件创建一个分区，并将 ISO 中的内容解压进去。但是分区一旦创建不像文件那么好修改，所以创建每个 Windows ISO 分区的时候我都留了一些额外空间，以备以后 ISO 大小变化，这也意味着这些空间就基本浪费了。That&amp;#39;s sad but I guess it&amp;#39;s how things work.&lt;/p&gt;
&lt;p&gt;另外，购买一个优质的 U 盘还是有必要的，不然不管是创建启动盘还是安装系统都会慢得让你痛不欲生。建议用之前先给 U 盘测一下速，什么拷贝速度只有 2MB/s 的金士顿可以直接进垃圾桶了。至于 U 盘大小取决于你要放多少个 ISO 文件和多少个 Windows 分区，一般 Linux 镜像大小在 500MB~3GB 的都有，Windows 10 的分区一般每个需要 5~6GB.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="装机" scheme="https://recursiveg.me/tags/%E8%A3%85%E6%9C%BA/"/>
    
      <category term="折腾" scheme="https://recursiveg.me/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="Windows" scheme="https://recursiveg.me/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>在 Raspberry Pi 4B 上安装 ArchLinux</title>
    <link href="https://recursiveg.me/2020/10/archlinux-on-raspberrypi-4b/"/>
    <id>https://recursiveg.me/2020/10/archlinux-on-raspberrypi-4b/</id>
    <published>2020-10-03T05:50:00.000Z</published>
    <updated>2020-10-30T03:57:48.330Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/archlinux-on-raspberrypi-4b/01-neofetch.png" alt="Neofetch"><br>很久之前就买了一个树莓派，不过一直在吃灰，正好最近有空就再拿出来折腾一下。原装系统是 32 位的，那么就必定要换一个 64 位的啦，不然对不起这 64 位的 CPU 呀。秉承“Arch大法好”的理念，我就决定用 Archlinux ARM 了。我非常建议先用原版系统<a href="https://www.raspberrypi.org/documentation/hardware/raspberrypi/booteeprom.md" target="_blank" rel="noopener">更新 Bootloader 和 EEPROM</a>到最新版本。这样可以避免各种奇怪的 bug 和使用一些新加入的功能，比如从网络启动什么的。</p><p>ArchLinux ARM 其实已经提供了<a href="https://archlinuxarm.org/platforms/armv8/broadcom/raspberry-pi-4" target="_blank" rel="noopener">树莓派的安装教程</a>，基本上只要跟着做即可，我用的是 AArch64 镜像，并且把根文件系统从 ext4 换成了 f2fs，希望在 SD 卡上能有一点点加成效果。装完以后发现串口没有输出，自然不能忍，继续折腾。RPi 4B 一共有<a href="https://www.raspberrypi.org/documentation/configuration/uart.md" target="_blank" rel="noopener">两个串口控制器</a>，一个 PL011，另一个被称作 MiniUART。默认情况下，PL011 连接到蓝牙模块，并且 MiniUART 被禁用，但是我们可以通过 <a href="https://www.raspberrypi.org/documentation/configuration/config-txt/README.md" target="_blank" rel="noopener"><code>config.txt</code> 加载 dtb overlay</a> 来调整。一些常见的配置有：</p><ul><li>启用 MiniUART 串口，PL011 继续负责蓝牙</li><li>禁用蓝牙，让 PL011 负责串口通信</li><li>启用 MiniUART，让 MiniUART 负责蓝牙，PL011 负责串口</li></ul><p>但是 ArchLinux ARM 使用 U-Boot 来启动内核，并不遵循 config.txt (╯°Д°)╯ ┻━┻</p><p>那么我们只能把 U-Boot 干掉了 （&lt;ゝω・）☆</p><a id="more"></a><h2 id="使用-MiniUART-作为串口"><a href="#使用-MiniUART-作为串口" class="headerlink" title="使用 MiniUART 作为串口"></a>使用 MiniUART 作为串口</h2><p>SD 卡的 <a href="https://www.raspberrypi.org/documentation/configuration/boot_folder.md" target="_blank" rel="noopener"><code>\boot</code> 目录</a>里需要这么7个文件，RPi 4B 的 bootloader 才好启动 Linux 内核：</p><ul><li><code>config.txt</code>: 主要配置文件，<code>uboot-raspberrypi</code> 有提供，但是我们手写。</li><li><code>start4.elf</code> 和 <code>fixup4.dat</code>: 第二阶段 Bootloader, 由 <code>raspberrypi-bootloader</code> 包提供。</li><li><code>rpi4.dtb</code>: RPi 4B 的 Device Tree 文件, <code>linux-aarch64</code> 包中提供了一个基于上游代码的，位于 <code>/boot/dtbs</code>。但是我试了几次都不能正常启动，所以还是从 Raspberry Pi <a href="https://github.com/raspberrypi/firmware/releases" target="_blank" rel="noopener">官方的 Github</a> 下载了一份。</li><li><code>Image</code>: 内核可执行文件，由 <code>linux-aarch64</code> 包提供。</li><li><code>initramfs-linux.img</code>：由 <code>mkinitcpio</code> 程序生成。</li><li><code>cmdline.txt</code>: 内核参数文件，手写。</li></ul><p>那么直接上配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enable_uart&#x3D;1                               # 启用 MiniUART</span><br><span class="line">kernel&#x3D;Image                                # 指定内核文件的名称</span><br><span class="line">arm_64bit&#x3D;1                                 # 要求以 64 位模式启动，否则默认是 32 位</span><br><span class="line">device_tree&#x3D;rpi4.dtb                        # Github 上的 bcm2711-rpi-4-b.dtb 文件，我改了个名</span><br><span class="line">initramfs initramfs-linux.img followkernel  # 指定 initramfs 文件</span><br></pre></td></tr></table></figure><p><code>start4.elf</code>、<code>fixup4.dat</code> 和 <code>cmdline.txt</code> 都是原名，就无需写进 <code>config.txt</code> 里了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console&#x3D;serial0,115200 root&#x3D;PARTUUID&#x3D;e10d384f-02 rootfstype&#x3D;f2fs rootflags&#x3D;rw elevator&#x3D;deadline audit&#x3D;0 rootwait</span><br></pre></td></tr></table></figure><ul><li><code>PARTUUID</code> 需要改成你自己的，可以用 <code>sudo blkid</code> 查看</li><li><code>rootflags</code> f2fs 似乎默认以只读挂载，会导致没有办法登录。</li><li><code>audit=0</code> 关掉 audit，否则内核信息撒得满地都是。</li></ul><p>全部折腾完以后把 SD 卡塞进树莓派，应该就能在串口看到登录界面了。</p><h2 id="使用-PL011-作为串口"><a href="#使用-PL011-作为串口" class="headerlink" title="使用 PL011 作为串口"></a>使用 PL011 作为串口</h2><p>我在安装的时候碰到一个 MiniUART 的 BUG，串口的 Baudrate 不对，内核输出一片乱码。可以尝试使用 PL011 作为串口，也可以升级内核解决。使用 PL011 需要在 boot 分区里加一个新的文件</p><ul><li><code>overlays/disable-bt.dtbo</code>: 需要从 Github 上下载，用来禁用蓝牙，并且让 PL011 负责串口通信。</li></ul><p>同时需要修改 config.txt 加上 <code>dtoverlay=disable-bt</code> 以启用。此时 <code>enable_uart=1</code> 不再是必要的了。</p><h2 id="登录之后"><a href="#登录之后" class="headerlink" title="登录之后"></a>登录之后</h2><p>登录之后建议先把 <code>uboot-raspberrypi</code> 卸了，然后 dhcpcd 连上网 <code>pacman -Syu</code> 一下，再重启确认一下启动过程都正常。之后就是标准的 ArchLinux 服务器配置过程：时区, 网络, 防火墙, etc. 搞定以后我们就有一台 AArch64 服务器了。</p><p>暂时没有 GUI 的需求，相关的配置就留到下次再折腾了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/archlinux-on-raspberrypi-4b/01-neofetch.png&quot; alt=&quot;Neofetch&quot;&gt;&lt;br&gt;很久之前就买了一个树莓派，不过一直在吃灰，正好最近有空就再拿出来折腾一下。原装系统是 32 位的，那么就必定要换一个 64 位的啦，不然对不起这 64 位的 CPU 呀。秉承“Arch大法好”的理念，我就决定用 Archlinux ARM 了。我非常建议先用原版系统&lt;a href=&quot;https://www.raspberrypi.org/documentation/hardware/raspberrypi/booteeprom.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;更新 Bootloader 和 EEPROM&lt;/a&gt;到最新版本。这样可以避免各种奇怪的 bug 和使用一些新加入的功能，比如从网络启动什么的。&lt;/p&gt;
&lt;p&gt;ArchLinux ARM 其实已经提供了&lt;a href=&quot;https://archlinuxarm.org/platforms/armv8/broadcom/raspberry-pi-4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;树莓派的安装教程&lt;/a&gt;，基本上只要跟着做即可，我用的是 AArch64 镜像，并且把根文件系统从 ext4 换成了 f2fs，希望在 SD 卡上能有一点点加成效果。装完以后发现串口没有输出，自然不能忍，继续折腾。RPi 4B 一共有&lt;a href=&quot;https://www.raspberrypi.org/documentation/configuration/uart.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;两个串口控制器&lt;/a&gt;，一个 PL011，另一个被称作 MiniUART。默认情况下，PL011 连接到蓝牙模块，并且 MiniUART 被禁用，但是我们可以通过 &lt;a href=&quot;https://www.raspberrypi.org/documentation/configuration/config-txt/README.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;config.txt&lt;/code&gt; 加载 dtb overlay&lt;/a&gt; 来调整。一些常见的配置有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启用 MiniUART 串口，PL011 继续负责蓝牙&lt;/li&gt;
&lt;li&gt;禁用蓝牙，让 PL011 负责串口通信&lt;/li&gt;
&lt;li&gt;启用 MiniUART，让 MiniUART 负责蓝牙，PL011 负责串口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是 ArchLinux ARM 使用 U-Boot 来启动内核，并不遵循 config.txt (╯°Д°)╯ ┻━┻&lt;/p&gt;
&lt;p&gt;那么我们只能把 U-Boot 干掉了 （&amp;lt;ゝω・）☆&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="折腾" scheme="https://recursiveg.me/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="树莓派" scheme="https://recursiveg.me/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="硬件" scheme="https://recursiveg.me/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>MikroTik RB4011 访客网络配置备忘</title>
    <link href="https://recursiveg.me/2020/07/mikrotik-rb4011-setup-memo/"/>
    <id>https://recursiveg.me/2020/07/mikrotik-rb4011-setup-memo/</id>
    <published>2020-07-03T04:30:00.000Z</published>
    <updated>2020-07-03T23:06:13.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/images/mikrotik-rb4011-setup-memo/0-speedtest.png" alt="Speedtest"><br>由于之前陆陆续续添置了不少电子设备，以及更换 ISP 的原因，机架上连了5台设备，每台各负责一点点事情，不管是配置还是调试都很麻烦。再加上旧路由器不能很好同时处理千兆 NAT 和 VLAN，于是最近入手了一台 <a href="https://mikrotik.com/product/rb4011igs_5hacq2hnd_in" target="_blank" rel="noopener">RB4011iGS+5HacQ2HnD-IN</a>，把这一堆乱七八糟的设备统统换掉。主要需求有三点：</p><ol><li>划分2个 VLAN，一个内部网络，一个访客网络。</li><li>IPv4 和 IPv6 双栈接入。</li><li>因为路由器直接暴露在 Internet 上了，所以防火墙一定要配好，包括 VLAN 之间的访问也是靠防火墙来控制的。</li></ol><a id="more"></a><h1 id="端口及-VLAN-配置"><a href="#端口及-VLAN-配置" class="headerlink" title="端口及 VLAN 配置"></a>端口及 VLAN 配置</h1><p>MikroTik 家的路由器的二层交换配置是比较不统一的。受限制于不同产品的硬件，想要完全利用硬件交换，不同的型号在 Bridge 的设定上都略有不同。建议到 <a href="https://wiki.mikrotik.com/wiki/Manual:Switch_Chip_Features" target="_blank" rel="noopener">MikroTik Wiki: Switch Chip Features</a> 页面查询具体型号的配置方法。由于我的大部分内网流量还是要过 CPU 三层路由的，所以我没有在这一点上做特别优化，反正 RB4011 的性能够用。我这里以两个 VLAN，每个 VLAN 里各有一个 Ethernet 接口和一个 Wireless 接口为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;interface wireless</span><br><span class="line"># 修改内部无线网络接口 VLAN ID 为 900</span><br><span class="line">set [ find default-name&#x3D;wlan1 ] name&#x3D;wlan5g vlan-id&#x3D;900 vlan-mode&#x3D;use-tag &lt;...其他参数省略...&gt;</span><br><span class="line"># 增加访客无线网络接口 VLAN ID 为 200</span><br><span class="line">add master-interface&#x3D;wlan5g name&#x3D;wlan5g_guest vlan-id&#x3D;200 vlan-mode&#x3D;use-tag &lt;...其他参数省略...&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;interface bridge</span><br><span class="line"># 新建网桥，注意这个网桥自己的 VLAN ID 我们用不到，所以填什么都可以</span><br><span class="line">add frame-types&#x3D;admit-only-vlan-tagged ingress-filtering&#x3D;yes name&#x3D;LAN protocol-mode&#x3D;none pvid&#x3D;900 vlan-filtering&#x3D;yes</span><br><span class="line"></span><br><span class="line">&#x2F;interface bridge port</span><br><span class="line"># 把两个无线和两个有线都加进桥</span><br><span class="line">add bridge&#x3D;LAN frame-types&#x3D;admit-only-vlan-tagged ingress-filtering&#x3D;yes interface&#x3D;wlan5g pvid&#x3D;900</span><br><span class="line">add bridge&#x3D;LAN frame-types&#x3D;admit-only-vlan-tagged ingress-filtering&#x3D;yes interface&#x3D;wlan5g_guest pvid&#x3D;200</span><br><span class="line">add bridge&#x3D;LAN frame-types&#x3D;admit-only-untagged-and-priority-tagged ingress-filtering&#x3D;yes interface&#x3D;ether2_nas pvid&#x3D;900</span><br><span class="line">add bridge&#x3D;LAN frame-types&#x3D;admit-only-untagged-and-priority-tagged ingress-filtering&#x3D;yes interface&#x3D;ether3 pvid&#x3D;200</span><br><span class="line"></span><br><span class="line">&#x2F;interface bridge vlan</span><br><span class="line"># 配置桥的 VLAN 转发表</span><br><span class="line">add bridge&#x3D;LAN vlan-ids&#x3D;900 tagged&#x3D;LAN,wlan5g untagged&#x3D;ether2_nas</span><br><span class="line">add bridge&#x3D;LAN vlan-ids&#x3D;200 tagged&#x3D;LAN,wlan5g_guest untagged&#x3D;ether3</span><br><span class="line"></span><br><span class="line">&#x2F;interface vlan</span><br><span class="line"># 在桥上新建两个 VLAN 接口，之后 IP 地址以及 DHCP 服务器就分配给它们</span><br><span class="line">add interface&#x3D;LAN name&#x3D;LAN.guest vlan-id&#x3D;200</span><br><span class="line">add interface&#x3D;LAN name&#x3D;LAN.trusted vlan-id&#x3D;900</span><br><span class="line"></span><br><span class="line">&#x2F;ip address</span><br><span class="line"># 分配 IP</span><br><span class="line">add address&#x3D;192.168.9.1&#x2F;24 interface&#x3D;LAN.trusted network&#x3D;192.168.9.0</span><br><span class="line">add address&#x3D;192.168.2.1&#x2F;24 interface&#x3D;LAN.guest network&#x3D;192.168.2.0</span><br></pre></td></tr></table></figure><h1 id="DHCP-配置"><a href="#DHCP-配置" class="headerlink" title="DHCP 配置"></a>DHCP 配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># IPv4 DHCP 客户端</span><br><span class="line">&#x2F;ip dhcp-client</span><br><span class="line">add !dhcp-options disabled&#x3D;no interface&#x3D;ether1_ont use-peer-dns&#x3D;no use-peer-ntp&#x3D;no</span><br><span class="line"></span><br><span class="line"># IPv4 DHCP 服务器</span><br><span class="line">&#x2F;ip pool</span><br><span class="line">add name&#x3D;dhcp_trusted ranges&#x3D;192.168.9.200-192.168.9.250</span><br><span class="line">add name&#x3D;dhcp_guest ranges&#x3D;192.168.2.200-192.168.2.250</span><br><span class="line">&#x2F;ip dhcp-server</span><br><span class="line">add address-pool&#x3D;dhcp_trusted disabled&#x3D;no interface&#x3D;LAN.trusted name&#x3D;dhcp_trusted</span><br><span class="line">add address-pool&#x3D;dhcp_guest disabled&#x3D;no interface&#x3D;LAN.guest name&#x3D;dhcp_guest</span><br><span class="line">&#x2F;ip dhcp-server network</span><br><span class="line">add address&#x3D;192.168.2.0&#x2F;24 gateway&#x3D;192.168.2.1</span><br><span class="line">add address&#x3D;192.168.9.0&#x2F;24 gateway&#x3D;192.168.9.1</span><br><span class="line"></span><br><span class="line"># DHCPv6 获取前缀</span><br><span class="line">&#x2F;ipv6 dhcp-client</span><br><span class="line">add add-default-route&#x3D;yes interface&#x3D;ether1_ont pool-name&#x3D;ipv6_ont_pool request&#x3D;prefix use-peer-dns&#x3D;no</span><br><span class="line"></span><br><span class="line"># 配置 IPv6 SLAAC</span><br><span class="line">&#x2F;ipv6 address</span><br><span class="line">add from-pool&#x3D;ipv6_ont_pool interface&#x3D;LAN.trusted</span><br><span class="line">add from-pool&#x3D;ipv6_ont_pool interface&#x3D;LAN.guest</span><br></pre></td></tr></table></figure><h1 id="IPv4-防火墙配置"><a href="#IPv4-防火墙配置" class="headerlink" title="IPv4 防火墙配置"></a>IPv4 防火墙配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;ip firewall nat</span><br><span class="line">add action&#x3D;masquerade chain&#x3D;srcnat ipsec-policy&#x3D;out,none out-interface&#x3D;ether1_ont comment&#x3D;&quot;NAT&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;ip firewall filter</span><br><span class="line">add action&#x3D;accept chain&#x3D;input comment&#x3D;&quot;defconf: accept established,related,untracked&quot; connection-state&#x3D;established,related,untracked</span><br><span class="line">add action&#x3D;drop chain&#x3D;input comment&#x3D;&quot;defconf: drop invalid&quot; connection-state&#x3D;invalid</span><br><span class="line">add action&#x3D;drop chain&#x3D;input comment&#x3D;&quot;非内部网络不可访问路由器&quot; in-interface&#x3D;!LAN.trusted</span><br><span class="line"></span><br><span class="line">add action&#x3D;accept chain&#x3D;forward comment&#x3D;&quot;defconf: accept in ipsec policy&quot; ipsec-policy&#x3D;in,ipsec</span><br><span class="line">add action&#x3D;accept chain&#x3D;forward comment&#x3D;&quot;defconf: accept out ipsec policy&quot; ipsec-policy&#x3D;out,ipsec</span><br><span class="line">add action&#x3D;fasttrack-connection chain&#x3D;forward comment&#x3D;&quot;defconf: fasttrack&quot; connection-state&#x3D;established,related</span><br><span class="line">add action&#x3D;accept chain&#x3D;forward comment&#x3D;&quot;defconf: accept established,related, untracked&quot; connection-state&#x3D;established,related,untracked</span><br><span class="line">add action&#x3D;drop chain&#x3D;forward comment&#x3D;&quot;defconf: drop invalid&quot; connection-state&#x3D;invalid</span><br><span class="line">add action&#x3D;drop chain&#x3D;forward comment&#x3D;&quot;defconf: drop all from ether1 not DSTNATed&quot; connection-nat-state&#x3D;!dstnat connection-state&#x3D;new in-interface&#x3D;ether1_ont</span><br><span class="line">add action&#x3D;drop chain&#x3D;forward comment&#x3D;&quot;其他 VLAN 不可访问内部 VLAN&quot; out-interface&#x3D;LAN.trusted</span><br><span class="line">add action&#x3D;drop chain&#x3D;forward comment&#x3D;&quot;访客 VLAN 不可访问除 Internet 以外的网络&quot; in-interface&#x3D;LAN.guest out-interface&#x3D;!ether1_ont</span><br></pre></td></tr></table></figure><h1 id="IPv6-防火墙配置"><a href="#IPv6-防火墙配置" class="headerlink" title="IPv6 防火墙配置"></a>IPv6 防火墙配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;ipv6 firewall filter</span><br><span class="line">add action&#x3D;accept chain&#x3D;input comment&#x3D;&quot;defconf: accept established,related,untracked&quot; connection-state&#x3D;established,related,untracked</span><br><span class="line">add action&#x3D;drop chain&#x3D;input comment&#x3D;&quot;defconf: drop invalid&quot; connection-state&#x3D;invalid</span><br><span class="line">add action&#x3D;accept chain&#x3D;input comment&#x3D;&quot;允许所有 ICMPv6 报文&quot; protocol&#x3D;icmpv6</span><br><span class="line">add action&#x3D;accept chain&#x3D;input comment&#x3D;&quot;允许 DHCPv6 前缀分配报文&quot; dst-port&#x3D;546 protocol&#x3D;udp src-address&#x3D;fe80::&#x2F;16</span><br><span class="line">add action&#x3D;drop chain&#x3D;input comment&#x3D;&quot;非内部网络不可访问路由器&quot; in-interface&#x3D;!LAN.trusted</span><br><span class="line"></span><br><span class="line">add action&#x3D;accept chain&#x3D;forward comment&#x3D;&quot;defconf: accept in ipsec policy&quot; ipsec-policy&#x3D;in,ipsec</span><br><span class="line">add action&#x3D;accept chain&#x3D;forward comment&#x3D;&quot;defconf: accept out ipsec policy&quot; ipsec-policy&#x3D;out,ipsec</span><br><span class="line">add action&#x3D;accept chain&#x3D;forward comment&#x3D;&quot;defconf: accept established,related, untracked&quot; connection-state&#x3D;established,related,untracked</span><br><span class="line">add action&#x3D;drop chain&#x3D;forward comment&#x3D;&quot;defconf: drop invalid&quot; connection-state&#x3D;invalid</span><br><span class="line">add action&#x3D;accept chain&#x3D;forward comment&#x3D;&quot;允许访问互联网&quot; out-interface&#x3D;ether1_ont</span><br><span class="line">add action&#x3D;drop chain&#x3D;forward comment&#x3D;&quot;拒绝所有其他转发流量&quot;</span><br></pre></td></tr></table></figure><h1 id="测试总结"><a href="#测试总结" class="headerlink" title="测试总结"></a>测试总结</h1><p>配置完了以后我对这一套设备还是挺满意的。在 IPv6 没有 Fasttrack 只能纯 CPU 转发的情况下，双向同时 900Mbps 测速，CPU 占用在 80% 左右。发热也没有什么感觉，反正平时一直丢角落里，估计整台机器最烫的部分就是那个 SFP+ 的万兆收发器了吧。</p><p><img src="/images/mikrotik-rb4011-setup-memo/1-final-setup.jpg" alt="Final"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/mikrotik-rb4011-setup-memo/0-speedtest.png&quot; alt=&quot;Speedtest&quot;&gt;&lt;br&gt;由于之前陆陆续续添置了不少电子设备，以及更换 ISP 的原因，机架上连了5台设备，每台各负责一点点事情，不管是配置还是调试都很麻烦。再加上旧路由器不能很好同时处理千兆 NAT 和 VLAN，于是最近入手了一台 &lt;a href=&quot;https://mikrotik.com/product/rb4011igs_5hacq2hnd_in&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RB4011iGS+5HacQ2HnD-IN&lt;/a&gt;，把这一堆乱七八糟的设备统统换掉。主要需求有三点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;划分2个 VLAN，一个内部网络，一个访客网络。&lt;/li&gt;
&lt;li&gt;IPv4 和 IPv6 双栈接入。&lt;/li&gt;
&lt;li&gt;因为路由器直接暴露在 Internet 上了，所以防火墙一定要配好，包括 VLAN 之间的访问也是靠防火墙来控制的。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Life" scheme="https://recursiveg.me/categories/Life/"/>
    
    
      <category term="Networking" scheme="https://recursiveg.me/tags/Networking/"/>
    
      <category term="装机" scheme="https://recursiveg.me/tags/%E8%A3%85%E6%9C%BA/"/>
    
      <category term="MikroTik" scheme="https://recursiveg.me/tags/MikroTik/"/>
    
      <category term="RouterOS" scheme="https://recursiveg.me/tags/RouterOS/"/>
    
  </entry>
  
  <entry>
    <title>WinRAR 恢复记录添加及使用教程</title>
    <link href="https://recursiveg.me/2020/04/winrar-best-practice/"/>
    <id>https://recursiveg.me/2020/04/winrar-best-practice/</id>
    <published>2020-04-09T14:30:00.000Z</published>
    <updated>2020-10-30T03:49:49.971Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文中的所有图片及文字均使用 CC0 发布，可任意转载使用。</p></blockquote><p>本文属于疫情期间的摸鱼之作，旨在推广 RAR 压缩格式的正确压缩方法，让资源分享更轻松一些。</p><h1 id="获取-WinRAR"><a href="#获取-WinRAR" class="headerlink" title="获取 WinRAR"></a>获取 WinRAR</h1><p>先说一下为什么用 WinRAR 而不用 7zip, 因为 7zip 没有恢复记录。在百度网盘等平台分享文件时，文件可能发生损坏，没有恢复记录的话只能尝试重新下载浪费时间，而有恢复记录的话有大概率可以成功修复，正确解压。</p><p>国内特供版的 WinRAR 可以免费使用，但是有广告。如果不想要广告，你可以从以下链接下载官方无广告简体中文版</p><pre><code>https://www.win-rar.com/fileadmin/winrar-versions/sc/sc20200409/rrlb/winrar-x64-590sc.exe</code></pre><p>注意，如果你没有<code>rarreg.key</code>文件进行注册的话依然是有广告的。至于具体的注册方法请自行搜寻。</p><a id="more"></a><h1 id="添加恢复记录"><a href="#添加恢复记录" class="headerlink" title="添加恢复记录"></a>添加恢复记录</h1><p>恢复记录需要在创建压缩文件时添加，你需要先勾选<code>添加恢复记录</code>复选框。<br><img src="/images/winrar-best-practice/01-check-add-rr-box.png" alt="添加恢复记录"><br>然后检查恢复记录的百分比设置。<br><img src="/images/winrar-best-practice/02-rr-percentile.png" alt="检查恢复记录大小"><br>对于大于 100MB 的大型文件文件来说，默认的 3% 足够使用。如果你的文件非常小，比如只有 几MB 或者 十几MB 你可以考虑增加到 5%。增大这项设置会同时增大文件体积，因此不建议设置得过大，尤其是对于几个 GB 的文件来说。如果你在压缩时忘记添加恢复记录或者是想要修改恢复记录的大小，也可以在事后进行操作：<br><img src="/images/winrar-best-practice/03-modify-rr-percentile.png" alt="修改恢复记录大小"></p><h1 id="损坏压缩文件的修复"><a href="#损坏压缩文件的修复" class="headerlink" title="损坏压缩文件的修复"></a>损坏压缩文件的修复</h1><p>如果你在解压时遇到“校验和错误”，那么你下载到的压缩文件就是损坏了：<br><img src="/images/winrar-best-practice/04-broken-file-example.png" alt=""><br>你可以使用“工具”菜单尝试修复它。修复操作会生成一个新的，修复好的压缩包，你需要选择这个新文件的保存位置：<br><img src="/images/winrar-best-practice/05-select-fixed-save-location.png" alt=""><br>稍等片刻就会生成一个修复后的文件：<br><img src="/images/winrar-best-practice/06-fixed-file.png" alt=""><br>你也有可能在修复过程中遇到错误，但只要修复后的文件可以正确解压不报错，就没有问题。<br>但是只有添加了恢复记录的文件可以使用修复操作，因此所有人在压缩时都添加恢复记录是非常重要的。<br>如果修复后的文件依然不能正确解压，要么是损坏的部分过多无法修复，要么是资源发布者没有添加恢复记录。<br>在这种情况下就只能重新下载试试了。</p><h1 id="给压缩文件加密"><a href="#给压缩文件加密" class="headerlink" title="给压缩文件加密"></a>给压缩文件加密</h1><p>给压缩文件加密是防止文件被和谐的重要方法之一。<br><img src="/images/winrar-best-practice/07-add-password.png" alt=""></p><h1 id="分卷压缩"><a href="#分卷压缩" class="headerlink" title="分卷压缩"></a>分卷压缩</h1><p>如果你要分享一个非常巨大的压缩包，比如说十几个GB，直接作为一个文件分享一般不是一个好主意，因为下载者有可能下载到中途失败，不得不从头再来。将大压缩包切分成多个较小的文件可以有效减少这种情况的发生。<br><img src="/images/winrar-best-practice/08-split-volume.png" alt=""></p><h1 id="Linux-用户？"><a href="#Linux-用户？" class="headerlink" title="Linux 用户？"></a>Linux 用户？</h1><ul><li>很不幸地，创建或是修复带恢复记录的压缩包都需要<code>rar</code>而不是<code>unrar</code>。</li><li>如果遇到压缩包包含了文件名过长的文件，可以尝试创建一个 NTFS 格式的磁盘文件，用回环挂载，然后把文件解压进去。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文中的所有图片及文字均使用 CC0 发布，可任意转载使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文属于疫情期间的摸鱼之作，旨在推广 RAR 压缩格式的正确压缩方法，让资源分享更轻松一些。&lt;/p&gt;
&lt;h1 id=&quot;获取-WinRAR&quot;&gt;&lt;a href=&quot;#获取-WinRAR&quot; class=&quot;headerlink&quot; title=&quot;获取 WinRAR&quot;&gt;&lt;/a&gt;获取 WinRAR&lt;/h1&gt;&lt;p&gt;先说一下为什么用 WinRAR 而不用 7zip, 因为 7zip 没有恢复记录。在百度网盘等平台分享文件时，文件可能发生损坏，没有恢复记录的话只能尝试重新下载浪费时间，而有恢复记录的话有大概率可以成功修复，正确解压。&lt;/p&gt;
&lt;p&gt;国内特供版的 WinRAR 可以免费使用，但是有广告。如果不想要广告，你可以从以下链接下载官方无广告简体中文版&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://www.win-rar.com/fileadmin/winrar-versions/sc/sc20200409/rrlb/winrar-x64-590sc.exe&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意，如果你没有&lt;code&gt;rarreg.key&lt;/code&gt;文件进行注册的话依然是有广告的。至于具体的注册方法请自行搜寻。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="网盘" scheme="https://recursiveg.me/tags/%E7%BD%91%E7%9B%98/"/>
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="WinRAR" scheme="https://recursiveg.me/tags/WinRAR/"/>
    
  </entry>
  
  <entry>
    <title>CMake 项目生成脚本</title>
    <link href="https://recursiveg.me/2020/03/cmake-environment-script/"/>
    <id>https://recursiveg.me/2020/03/cmake-environment-script/</id>
    <published>2020-03-16T15:00:00.000Z</published>
    <updated>2020-03-17T04:14:43.308Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 比较尴尬的一点就是缺少比较“傻瓜”的工具库，不得不依靠第三方来补充。想快速开始写个小的 Demo 的时候光找库就花去不少时间。于是糊了一个脚本去自动生成这些基础的东西。放在这里方便自己以后参考。</p><p>用到的库列表：</p><ul><li>{fmt}: 字符串格式化库</li><li>spdlog: 日志</li><li>backward-cpp: 崩溃时的堆栈输出</li><li>benchmark: 快速性能测试</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print_help</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Usage:"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"   cproject &lt;type&gt; &lt;name&gt;"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Types:"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"   bin, bench"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">die</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Unexpected error"</span></span><br><span class="line">    <span class="built_in">exit</span> 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ninja does not work with backward-cpp</span></span><br><span class="line"><span class="function"><span class="title">new_bin</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> name=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">    mkdir <span class="string">"<span class="variable">$name</span>"</span> || die</span><br><span class="line">    <span class="built_in">cd</span> <span class="string">"<span class="variable">$name</span>"</span> || die</span><br><span class="line">    git <span class="built_in">clone</span> <span class="string">'https://github.com/fmtlib/fmt.git'</span> third_party/fmt || die</span><br><span class="line">    git <span class="built_in">clone</span> <span class="string">'https://github.com/bombela/backward-cpp.git'</span> third_party/backward-cpp || die</span><br><span class="line">    git <span class="built_in">clone</span> <span class="string">'https://github.com/gabime/spdlog.git'</span> third_party/spdlog || die</span><br><span class="line">    cat &lt;&lt; EOF &gt; CMakeLists.txt</span><br><span class="line">cmake_minimum_required(VERSION 3.11)</span><br><span class="line">project(<span class="variable">$&#123;name&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(NOT CMAKE_BUILD_TYPE)</span><br><span class="line">    <span class="built_in">set</span>(CMAKE_BUILD_TYPE Debug)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS ON)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_C_STANDARD 11)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD 17)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_POSITION_INDEPENDENT_CODE ON)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">"\$&#123;CMAKE_CXX_FLAGS&#125; -Wall -Wextra"</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS_DEBUG <span class="string">"\$&#123;CMAKE_CXX_FLAGS_DEBUG&#125; -ggdb -O0"</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">"\$&#123;CMAKE_EXE_LINKER_FLAGS&#125; -rdynamic"</span>)</span><br><span class="line"></span><br><span class="line">add_subdirectory(third_party/fmt)</span><br><span class="line">add_subdirectory(third_party/spdlog)</span><br><span class="line">add_subdirectory(third_party/backward-cpp)</span><br><span class="line"></span><br><span class="line">add_executable(main)</span><br><span class="line">target_sources(main PRIVATE main.cpp \<span class="variable">$&#123;BACKWARD_ENABLE&#125;</span>)</span><br><span class="line">target_link_libraries(main PRIVATE fmt spdlog -ldw)</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">    cat &lt;&lt; <span class="string">'EOF'</span> &gt; main.cpp</span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">#include "fmt/format.h"</span></span><br><span class="line"><span class="comment">#include "spdlog/spdlog.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define CRASH(...)                      \</span></span><br><span class="line">    &#123; ::spdlog::critical(__VA_ARGS__);  \</span><br><span class="line">      int _ [[maybe_unused]] =          \</span><br><span class="line">         *reinterpret_cast&lt;int*&gt;(0); &#125;</span><br><span class="line"></span><br><span class="line">inline int <span class="function"><span class="title">get_return_code</span></span>() &#123;</span><br><span class="line">    CRASH(<span class="string">"unimplemented function: &#123;&#125;"</span>, __func__);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">    fmt::<span class="built_in">print</span>(<span class="string">"&#123;&#125;, &#123;&#125;\n\n"</span>, <span class="string">"hello"</span>, <span class="string">"world"</span>);</span><br><span class="line"></span><br><span class="line">    spdlog::set_level(spdlog::level::debug);</span><br><span class="line">    spdlog::debug(<span class="string">"debug message"</span>);</span><br><span class="line">    spdlog::info(<span class="string">"info message"</span>);</span><br><span class="line">    spdlog::warn(<span class="string">"warning message"</span>);</span><br><span class="line">    spdlog::error(<span class="string">"Some error message with arg: &#123;&#125;"</span>, 1);</span><br><span class="line">    <span class="built_in">return</span> get_return_code();</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Skeleton generated. Run the command and you shall see "</span> \</span><br><span class="line">         <span class="string">"the stacktrace demo."</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"  cd <span class="variable">$&#123;name&#125;</span> &amp;&amp; cmake -B build &amp;&amp; "</span> \</span><br><span class="line">         <span class="string">"make -C build -j main &amp;&amp; build/main"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">new_bench</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> name=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">    mkdir <span class="string">"<span class="variable">$name</span>"</span> || die</span><br><span class="line">    <span class="built_in">cd</span> <span class="string">"<span class="variable">$name</span>"</span> || die</span><br><span class="line">    git <span class="built_in">clone</span> <span class="string">'https://github.com/fmtlib/fmt.git'</span> third_party/fmt || die</span><br><span class="line">    git <span class="built_in">clone</span> <span class="string">'https://github.com/bombela/backward-cpp.git'</span> third_party/backward-cpp || die</span><br><span class="line">    git <span class="built_in">clone</span> <span class="string">'https://github.com/gabime/spdlog.git'</span> third_party/spdlog || die</span><br><span class="line">    git <span class="built_in">clone</span> <span class="string">'https://github.com/google/benchmark.git'</span> third_party/benchmark || die</span><br><span class="line">    git <span class="built_in">clone</span> <span class="string">'https://github.com/google/googletest.git'</span> third_party/benchmark/googletest || die</span><br><span class="line">    cat &lt;&lt; EOF &gt; CMakeLists.txt</span><br><span class="line">cmake_minimum_required(VERSION 3.11)</span><br><span class="line">project(<span class="variable">$&#123;name&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(NOT CMAKE_BUILD_TYPE)</span><br><span class="line">    <span class="built_in">set</span>(CMAKE_BUILD_TYPE Release)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS ON)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_C_STANDARD 11)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD 17)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_POSITION_INDEPENDENT_CODE ON)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">"\$&#123;CMAKE_CXX_FLAGS&#125; -Wall -Wextra -g"</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">"\$&#123;CMAKE_EXE_LINKER_FLAGS&#125; -rdynamic"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(BENCHMARK_ENABLE_LTO <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">add_subdirectory(third_party/fmt)</span><br><span class="line">add_subdirectory(third_party/spdlog)</span><br><span class="line">add_subdirectory(third_party/backward-cpp)</span><br><span class="line">add_subdirectory(third_party/benchmark)</span><br><span class="line"></span><br><span class="line">add_executable(bench)</span><br><span class="line">target_sources(bench PRIVATE bench.cpp \<span class="variable">$&#123;BACKWARD_ENABLE&#125;</span>)</span><br><span class="line">target_link_libraries(bench PRIVATE fmt spdlog benchmark::benchmark_main -ldw)</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">    cat &lt;&lt; <span class="string">'EOF'</span> &gt; bench.cpp</span><br><span class="line"><span class="comment">#include "benchmark/benchmark.h"</span></span><br><span class="line"><span class="comment">#include &lt;cinttypes&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdlib&gt;</span></span><br><span class="line"></span><br><span class="line">constexpr size_t ARRAY_LEN = 1024*64;</span><br><span class="line">static void BM_SeqArrayAccess(benchmark::State&amp; state) &#123;</span><br><span class="line">    int stride = state.range(0);</span><br><span class="line">    uint64_t arr[ARRAY_LEN];</span><br><span class="line">    <span class="keyword">for</span> (auto _ : state) &#123;</span><br><span class="line">        <span class="keyword">for</span> (size_t idx = 0; idx &lt; ARRAY_LEN; idx += stride) &#123;</span><br><span class="line">            arr[idx] = random();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BENCHMARK(BM_SeqArrayAccess)</span><br><span class="line">    -&gt;Arg(1)</span><br><span class="line">    -&gt;Arg(2)</span><br><span class="line">    -&gt;Arg(3)</span><br><span class="line">    -&gt;Arg(4)</span><br><span class="line">    -&gt;Arg(5)</span><br><span class="line">    -&gt;Arg(6)</span><br><span class="line">    -&gt;Arg(7)</span><br><span class="line">    -&gt;Arg(8);</span><br><span class="line">EOF</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Skeleton generated."</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"  cd <span class="variable">$&#123;name&#125;</span> &amp;&amp; cmake -B build &amp;&amp; "</span> \</span><br><span class="line">         <span class="string">"make -C build -j bench &amp;&amp; build/bench"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"You may also need to change your CPU scheduler:"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"  sudo cpupower frequency-set -g performance"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$2</span>"</span> == <span class="string">""</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Missing project name"</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    print_help</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ -e <span class="string">"<span class="variable">$2</span>"</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"File \"<span class="variable">$2</span>\" already exists"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$1</span>"</span> == <span class="string">"bin"</span> ]]; <span class="keyword">then</span></span><br><span class="line">    new_bin <span class="string">"<span class="variable">$2</span>"</span></span><br><span class="line"><span class="keyword">elif</span> [[ <span class="string">"<span class="variable">$1</span>"</span> == <span class="string">"bench"</span> ]]; <span class="keyword">then</span></span><br><span class="line">    new_bench <span class="string">"<span class="variable">$2</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Unknown type: <span class="variable">$1</span>"</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    print_help</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C++ 比较尴尬的一点就是缺少比较“傻瓜”的工具库，不得不依靠第三方来补充。想快速开始写个小的 Demo 的时候光找库就花去不少时间。于是糊了一个脚本去自动生成这些基础的东西。放在这里方便自己以后参考。&lt;/p&gt;
&lt;p&gt;用到的库列表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;{fmt}: 
      
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="编程" scheme="https://recursiveg.me/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="CMake" scheme="https://recursiveg.me/tags/CMake/"/>
    
      <category term="C++" scheme="https://recursiveg.me/tags/C/"/>
    
      <category term="脚本" scheme="https://recursiveg.me/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>简易内核开发环境</title>
    <link href="https://recursiveg.me/2020/01/simple-kernel-dev-environment/"/>
    <id>https://recursiveg.me/2020/01/simple-kernel-dev-environment/</id>
    <published>2020-01-12T04:30:00.000Z</published>
    <updated>2020-01-12T22:01:14.348Z</updated>
    
    <content type="html"><![CDATA[<p>近期尝试了一下写 Linux 内核代码，于是把折腾过程记录一下，方便以后参考。本文默认使用 x86_64 架构以及 Linux 作为宿主系统。</p><h2 id="使用-QEMU-运行-Linux-内核"><a href="#使用-QEMU-运行-Linux-内核" class="headerlink" title="使用 QEMU 运行 Linux 内核"></a>使用 QEMU 运行 Linux 内核</h2><p>在开始写代码之前，我们需要先准备好模拟器用于运行 Linux。我这里用了QEMU，你也可以用 VirtualBox 之类的虚拟机。一般来说，我们需要一个内核可执行文件（内核本体）和一个 initramfs 镜像（提供用户态程序）。当内核被加载后，它会自动载入 initramfs 镜像，并执行其中的<code>/init</code>程序。由于这一节的重点是 QEMU 配置，所以我直接使用宿主机的内核和 initramfs。以我的 Archlinux 系统为例，内核文件是<code>/boot/vmlinuz-linux</code>，initramfs 文件是<code>/boot/initramfs-linux.img</code>。使用以下命令启动 QEMU，按<code>Ctrl-A x</code>退出。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -kernel /boot/vmlinuz-linux \</span><br><span class="line">    -initrd /boot/initramfs-linux.img \</span><br><span class="line">    -nographic -append <span class="string">"console=ttyS0"</span> \</span><br><span class="line">    -m 512 \</span><br><span class="line">    --<span class="built_in">enable</span>-kvm \</span><br><span class="line">    -cpu host</span><br></pre></td></tr></table></figure><ul><li><code>-kernel</code> 指定内核可执行文件。</li><li><code>-initrd</code> 指定 initramfs disk 镜像文件。</li><li><code>-nographic -append &quot;console=ttyS0&quot;</code> 禁用视频输出并使用串口作为终端。</li><li><code>-m 512</code> 设定内存。</li><li><code>--enable-kvm</code> 使用KVM。</li><li><code>-cpu host</code> 使用宿主机的 CPU 特性。</li></ul><p>你应该能看到一些系统启动的信息以及无法挂载根分区的报错，这是正常现象，因为我们没有提供任何磁盘文件。你应该可以进入一个紧急修复 Shell, 执行一些简单的如 <code>ls</code> <code>cd</code> 之类的命令。</p><a id="more"></a><h2 id="创建自己的-initramfs"><a href="#创建自己的-initramfs" class="headerlink" title="创建自己的 initramfs"></a>创建自己的 initramfs</h2><p>确保 QEMU 能够正常工作后，我们来创建自己 initramfs 替换掉上一步中的<code>/boot/initramfs-linux.img</code>。这一节的内容主要来自 <a href="https://lyngvaer.no/log/create-linux-initramfs" target="_blank" rel="noopener">Creating a initramfs image from scratch</a> 一文。initramfs 镜像本质上是一个经过压缩的 cpio 归档文件（cpio 约等于 tar）。根据内核版本的不同，你可以使用不同的压缩算法。我的内核比较新，所以可以使用lz4压缩。同时，我们直接下载使用编译好的<code>busybox</code>可执行文件作为我们的 Shell。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mkdir initramfs_root  <span class="comment"># 创建initramfs的根目录</span></span><br><span class="line"><span class="built_in">cd</span> initramfs_root</span><br><span class="line"></span><br><span class="line">mkdir bin dev etc lib mnt proc sbin sys tmp var  <span class="comment"># 创建一系列必要的目录</span></span><br><span class="line"><span class="built_in">pushd</span> bin</span><br><span class="line">wget <span class="string">'https://busybox.net/downloads/binaries/1.31.0-defconfig-multiarch-musl/busybox-x86_64'</span> -Obusybox <span class="comment"># 下载busybox</span></span><br><span class="line">chmod +x busybox</span><br><span class="line"><span class="built_in">popd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /init 是一个脚本，由busybox解释执行</span></span><br><span class="line">cat &lt;&lt; <span class="string">'EOF'</span> &gt; init</span><br><span class="line"><span class="meta">#!/bin/busybox sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载必要的文件系统目录</span></span><br><span class="line">/bin/busybox mount -t devtmpfs devtmpfs /dev</span><br><span class="line">/bin/busybox mount -t proc     proc     /proc</span><br><span class="line">/bin/busybox mount -t sysfs    sysfs    /sys</span><br><span class="line">/bin/busybox mount -t tmpfs    tmpfs    /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印一些欢迎信息</span></span><br><span class="line">/bin/busybox <span class="built_in">echo</span> Hello from initramfs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行shell，将控制权交给用户</span></span><br><span class="line">/bin/busybox sh</span><br><span class="line">EOF</span><br><span class="line">chmod +x init</span><br><span class="line"></span><br><span class="line"><span class="comment"># find .  列举需要压缩的文件</span></span><br><span class="line"><span class="comment"># cpio -o 执行归档</span></span><br><span class="line"><span class="comment">#      -H newc 指定归档文件格式</span></span><br><span class="line"><span class="comment"># lz4  -l 使用内核可以识别的压缩格式</span></span><br><span class="line">find . | cpio -ov -H newc | lz4 -l -9 &gt; ../initramfs.cpio.lz4</span><br></pre></td></tr></table></figure><p>这样，一个自定义的<code>initramfs.cpio.lz4</code>文件就构建好了。用其替换掉<code>/boot/initramfs-linux.img</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -kernel /boot/vmlinuz-linux \</span><br><span class="line">    -initrd initramfs.cpio.lz4 \</span><br><span class="line">    -nographic -append <span class="string">"console=ttyS0"</span> \</span><br><span class="line">    -m 512 \</span><br><span class="line">    --<span class="built_in">enable</span>-kvm \</span><br><span class="line">    -cpu host</span><br></pre></td></tr></table></figure><p>这样你应该就能得到一条欢迎信息和一个 Shell。由于我们没有创建常用命令到<code>busybox</code>的软链接，所以执行指令时需要加上<code>busybox</code>的前缀。以下是我的运行结果。</p><pre><code>Hello from initramfssh: can&apos;t access tty; job control turned off/ # busybox lsbin   dev   etc   init  lib   mnt   proc  root  sbin  sys   tmp   var/ #</code></pre><h2 id="编译自己的内核"><a href="#编译自己的内核" class="headerlink" title="编译自己的内核"></a>编译自己的内核</h2><p>替换掉 initramfs 镜像后，我们接着来替换内核。自己编译内核大概分三步：下载代码；配置内核；编译内核。Linux 的内核源代码可以在 <a href="https://www.kernel.org/" target="_blank" rel="noopener">https://www.kernel.org/</a> 下载。下载并解压到某个文件夹，比方说<code>linux-5.5-rc5</code>。通常来说手动配置内核是个苦差事，于是我们直接使用默认配置就好。默认配置文件位于<code>arch/x86/configs/x86_64_defconfig</code>。</p><pre><code>linux-5.5-rc5$ make x86_64_defconfig  # 使用64位默认配置...此处省略若干行...linux-5.5-rc5$ make -j10  # 请根据你电脑的核心数量调整...此处省略若干行...Kernel: arch/x86/boot/bzImage is ready  (#1)</code></pre><p>依葫芦画瓢，用这个编译好的<code>bzImage</code>替换掉<code>/boot/vmlinuz-linux</code>，你应该得到和之前一样的欢迎信息和 Shell。</p><h2 id="Hello-world-不含-glibc"><a href="#Hello-world-不含-glibc" class="headerlink" title="Hello world! (不含 glibc)"></a>Hello world! (不含 glibc)</h2><p>使用 C 语言写 Hello world! 是一码事，不用 glibc 写 Hello world! 是另一码事。在我们创建的 initramfs 中，我们没有包含任何类似<code>glibc</code>的 C 标准库，因此我们不能使用诸如<code>printf()</code>之类的方便函数，需要直接使用系统调用进行输出。从汇编层面来说，要进行系统调用，只需要将系统调用号以及参数统统塞入一系列寄存器，然后执行<code>syscall</code>指令即可。更详细的我在几年前的一篇<a href="https://recursiveg.me/2014/05/programming-with-ptrace-part4/">《Programming with PTRACE, Part4 - 系统调用进阶》</a>里有讲到。那么直接贴代码：</p><figure class="highlight cpp"><figcaption><span>helloworld.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDOUT 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_write 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_exit 60</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_write</span><span class="params">(<span class="keyword">long</span> fd, <span class="keyword">const</span> <span class="keyword">void</span>* addr, <span class="keyword">long</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"mov %0, %%rax;"</span></span><br><span class="line">        <span class="string">"mov %1, %%rdi;"</span></span><br><span class="line">        <span class="string">"mov %2, %%rsi;"</span></span><br><span class="line">        <span class="string">"mov %3, %%rdx;"</span>    </span><br><span class="line">        <span class="string">"syscall"</span></span><br><span class="line"></span><br><span class="line">    ::  <span class="string">"i"</span>(SYS_write),</span><br><span class="line">        <span class="string">"r"</span>(fd),</span><br><span class="line">        <span class="string">"r"</span>(addr),</span><br><span class="line">        <span class="string">"r"</span>(len)</span><br><span class="line"></span><br><span class="line">    :   <span class="string">"%rax"</span>,</span><br><span class="line">        <span class="string">"%rdi"</span>,</span><br><span class="line">        <span class="string">"%rsi"</span>,</span><br><span class="line">        <span class="string">"%rdx"</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_exit</span><span class="params">(<span class="keyword">long</span> return_code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"mov %0, %%rax;"</span></span><br><span class="line">        <span class="string">"mov %1, %%rdi;"</span></span><br><span class="line">        <span class="string">"syscall"</span></span><br><span class="line"></span><br><span class="line">    ::  <span class="string">"i"</span>(SYS_exit),</span><br><span class="line">        <span class="string">"r"</span>(return_code)</span><br><span class="line"></span><br><span class="line">    :   <span class="string">"%rax"</span>,</span><br><span class="line">        <span class="string">"%rdi"</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[len] != <span class="string">'\0'</span>) len++;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _start() &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"Hello world!\n"</span>;</span><br><span class="line">    sys_write(STDOUT, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    sys_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个值得注意的点：使用<code>_start()</code>而不是<code>main()</code>；<code>exit()</code>系统调用不能省。另外这个程序编译的时候也需要一些特殊的技巧，需要静态链接并且不需要标准库支持：</p><pre><code>gcc -nostdlib -static helloworld.c -fno-stack-protector -o helloworld</code></pre><p>将编译出的文件放入<code>initramfs_root</code>并重新打包，然后在 QEMU 中运行就能看到效果了。</p><pre><code>Hello from initramfssh: can&apos;t access tty; job control turned off/ # /bin/helloworldHello world!</code></pre><h2 id="Challenge-Hello-world-from-kernel-space"><a href="#Challenge-Hello-world-from-kernel-space" class="headerlink" title="Challenge (Hello world from kernel space)"></a>Challenge (Hello world from kernel space)</h2><p>至此，我们已经知道了如何在 QEMU 中启动一个包含内核和用户空间程序的 Linux 系统，并且知道了如何利用系统调用让用户态程序输出字符串。有兴趣的读者可以尝试给内核添加一个新的系统调用，当被调用时向 kernel log 输出<code>Hello kernel world!</code>。就像这样：</p><pre><code>/ # /bin/helloworld_syscall[    4.621241] Hello kernel world!</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期尝试了一下写 Linux 内核代码，于是把折腾过程记录一下，方便以后参考。本文默认使用 x86_64 架构以及 Linux 作为宿主系统。&lt;/p&gt;
&lt;h2 id=&quot;使用-QEMU-运行-Linux-内核&quot;&gt;&lt;a href=&quot;#使用-QEMU-运行-Linux-内核&quot; class=&quot;headerlink&quot; title=&quot;使用 QEMU 运行 Linux 内核&quot;&gt;&lt;/a&gt;使用 QEMU 运行 Linux 内核&lt;/h2&gt;&lt;p&gt;在开始写代码之前，我们需要先准备好模拟器用于运行 Linux。我这里用了QEMU，你也可以用 VirtualBox 之类的虚拟机。一般来说，我们需要一个内核可执行文件（内核本体）和一个 initramfs 镜像（提供用户态程序）。当内核被加载后，它会自动载入 initramfs 镜像，并执行其中的&lt;code&gt;/init&lt;/code&gt;程序。由于这一节的重点是 QEMU 配置，所以我直接使用宿主机的内核和 initramfs。以我的 Archlinux 系统为例，内核文件是&lt;code&gt;/boot/vmlinuz-linux&lt;/code&gt;，initramfs 文件是&lt;code&gt;/boot/initramfs-linux.img&lt;/code&gt;。使用以下命令启动 QEMU，按&lt;code&gt;Ctrl-A x&lt;/code&gt;退出。&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;qemu-system-x86_64 \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -kernel /boot/vmlinuz-linux \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -initrd /boot/initramfs-linux.img \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -nographic -append &lt;span class=&quot;string&quot;&gt;&quot;console=ttyS0&quot;&lt;/span&gt; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -m 512 \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    --&lt;span class=&quot;built_in&quot;&gt;enable&lt;/span&gt;-kvm \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -cpu host&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-kernel&lt;/code&gt; 指定内核可执行文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-initrd&lt;/code&gt; 指定 initramfs disk 镜像文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-nographic -append &amp;quot;console=ttyS0&amp;quot;&lt;/code&gt; 禁用视频输出并使用串口作为终端。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-m 512&lt;/code&gt; 设定内存。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--enable-kvm&lt;/code&gt; 使用KVM。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-cpu host&lt;/code&gt; 使用宿主机的 CPU 特性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你应该能看到一些系统启动的信息以及无法挂载根分区的报错，这是正常现象，因为我们没有提供任何磁盘文件。你应该可以进入一个紧急修复 Shell, 执行一些简单的如 &lt;code&gt;ls&lt;/code&gt; &lt;code&gt;cd&lt;/code&gt; 之类的命令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="编程" scheme="https://recursiveg.me/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Kernel" scheme="https://recursiveg.me/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>AMD Threadripper 3960X 装机</title>
    <link href="https://recursiveg.me/2019/12/build-amd-3960x-pc/"/>
    <id>https://recursiveg.me/2019/12/build-amd-3960x-pc/</id>
    <published>2019-12-24T04:00:00.000Z</published>
    <updated>2020-01-12T19:04:35.210Z</updated>
    
    <content type="html"><![CDATA[<p>眼看2019年就要结束了，发现自己的手竟然还在。于是决定连着胳膊一起剁掉。<br><img src="/images/build-amd-3960x-pc/01-all.jpg" alt="配件合照"></p><a id="more"></a><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>没什么好说的，AMD YES 就完事儿了。<br><img src="/images/build-amd-3960x-pc/02-cpu.jpg" alt="AMD Threadripper 3960X"></p><h2 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h2><p>主板选了微星的 TRX40 PRO 10G (我就是不喜欢 Asus 你来打我啊)。10G 版比 WIFI 少了无线模块，多了一张万兆以太网卡。不过不管哪样我都暂时用不上。另外还有一张 PCI-E x8 转两个 M.2 的转接卡，没那么多 SSD，同样用不上就是了。除此以外就是说明书、光污染线之类的玩意儿。<br><img src="/images/build-amd-3960x-pc/03-mobo.jpg" alt="MSI TRX40 PRO 10G"></p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>极度非主流的内存配置，4根英睿达的 16G ECC 内存。型号为<code>CT16G4WFD8266</code>。</p><p>于是先把 CPU 和内存装上主板：<br><img src="/images/build-amd-3960x-pc/04-cpu-mem-installed.jpg" alt="CPU &amp; Memory Installed"></p><h2 id="一体式水冷"><a href="#一体式水冷" class="headerlink" title="一体式水冷"></a>一体式水冷</h2><p>随便选的 九州神风堡垒360EX。少数几个当时能以合理价格买到的支持 TR4 的一体水冷。<br><img src="/images/build-amd-3960x-pc/05-aio-cooler.jpg" alt="Deepcool Castle 360EX"><br>另外现在的风扇都这么花哨了吗，怎么扇叶上都装扰流板了？<br><img src="/images/build-amd-3960x-pc/06-aio-cooler-fan.jpg" alt="Deepcool Castle 360EX - Fan"></p><h2 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h2><p>随便选的 海韵 Focus GX-850。少数几个当时能以合理价格买到的便宜的 850W 电源。另外这电源还送了一个测试器，本质就是把 ATX 接头里的某两根线短接一下，用以测试电源本身能不能工作。但是我为什么不直接把它插到主板上去测试呢？<br><img src="/images/build-amd-3960x-pc/07-psu1.jpg" alt="Seasonic Focus GX-850"><br><img src="/images/build-amd-3960x-pc/07-psu2.jpg" alt="Seasonic Focus GX-850"></p><h2 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h2><p>显卡方面，AMD 好像不是很香，但我还是选了 RX590。别问为什么，问就是 <a href="https://youtu.be/iYWzMvlj2RQ" target="_blank" rel="noopener">Fuck you NVIDIA</a>。<br><img src="/images/build-amd-3960x-pc/08-rx590.jpg" alt="Sapphire Pulse RX 590"></p><h2 id="40Gbps"><a href="#40Gbps" class="headerlink" title="40Gbps"></a>40Gbps</h2><p>之前提到用不到万兆网卡，一是没有万兆交换机，二是有捡垃圾捡回来的 40G Infiniband 卡，台式机和 NAS 之间用 QSPF 线直连，速度反正比机械硬盘快就是了。顺带把旧机器上的系统盘也拆过来。<br><img src="/images/build-amd-3960x-pc/09-ib-nvme.jpg" alt="ConnectX-3 &amp; Samsung 960 EVO"></p><h2 id="塞进机箱"><a href="#塞进机箱" class="headerlink" title="塞进机箱"></a>塞进机箱</h2><p>机箱选了毫无灯光的 Fractal Design Define C，这个机箱没有前置的 USB Type-C 接口比较可惜。显卡的 PCI-E 供电线荡在那儿还是有点丑。<br><img src="/images/build-amd-3960x-pc/10-internal.jpg" alt="Internal"><br>背面走线随便走走，机箱能合上就是胜利。<br><img src="/images/build-amd-3960x-pc/11-internal-back.jpg" alt="Internal - Back"></p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>新机器插电一次亮，不过意料之中的，进不去系统。根据 <a href="https://www.phoronix.com/scan.php?page=news_item&px=Linux-Boot-Threadripper-Zen2MCE" target="_blank" rel="noopener">Phoronix 的报道</a>，需要在内核参数中添加<code>mce=off</code>才能正常启动。然后进 BIOS 把虚拟化、IOMMU、ECC 之类的都开起来，这机器就算装完了。随意跑了一下<code>s-tui</code>，48个线程满载还是蛮恐怖的。<br><img src="/images/build-amd-3960x-pc/12-stressing.png" alt="htop+s-tui"><br>一般空载整机功耗 100W 左右。单烤 CPU 全核频率在 4GHz 左右，整机功耗 400W，想必加上显卡后能轻松过 500W，电费也要开始燃烧了。另外这接近 80℃ 的温度感觉有点高，难道是水冷没装好？</p><p>装机总结：AMD YES</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;眼看2019年就要结束了，发现自己的手竟然还在。于是决定连着胳膊一起剁掉。&lt;br&gt;&lt;img src=&quot;/images/build-amd-3960x-pc/01-all.jpg&quot; alt=&quot;配件合照&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Life" scheme="https://recursiveg.me/categories/Life/"/>
    
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="AMD" scheme="https://recursiveg.me/tags/AMD/"/>
    
      <category term="装机" scheme="https://recursiveg.me/tags/%E8%A3%85%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Haskell 简易指南</title>
    <link href="https://recursiveg.me/2019/03/haskell-intro/"/>
    <id>https://recursiveg.me/2019/03/haskell-intro/</id>
    <published>2019-03-20T18:00:00.000Z</published>
    <updated>2020-01-12T19:20:05.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>用任何你喜欢的方法安装 <a href="https://www.haskell.org/" target="_blank" rel="noopener">Glasgow Haskell Compiler</a> (a.k.a. GHC)。Cabal 之类的<br>依赖管理系统就用不着了。 <del>因为我也不会用。</del> 保证能够执行<code>ghc</code>和<code>ghci</code>命令就行。</p><h1 id="GHCi基础"><a href="#GHCi基础" class="headerlink" title="GHCi基础"></a>GHCi基础</h1><p>首先，把以下文件保存成<code>helloworld.hs</code>。</p><figure class="highlight haskell"><figcaption><span>helloworld.hs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> = <span class="string">"hello, world"</span></span><br></pre></td></tr></table></figure><p>然后执行<code>ghci helloworld.hs</code>，然后在<code>&gt;</code>提示符后输入<code>foo</code>并回车</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GHCi, version 8.6.3: http:&#x2F;&#x2F;www.haskell.org&#x2F;ghc&#x2F;  :? for help</span><br><span class="line">[1 of 1] Compiling Main             ( helloworld.hs, interpreted )</span><br><span class="line">Ok, one module loaded.</span><br><span class="line">*Main&gt; foo</span><br><span class="line">&quot;hello, world&quot;</span><br><span class="line">*Main&gt;</span><br></pre></td></tr></table></figure><p>你可以使用<code>:r</code>来重新载入文件，也可以使用<code>:l &lt;文件名&gt;</code>来载入代码。</p><a id="more"></a><h1 id="基础表达式"><a href="#基础表达式" class="headerlink" title="基础表达式"></a>基础表达式</h1><p>你可以修改你的代码文件，并在GHCi中观察程序行为。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里是注释</span></span><br><span class="line"></span><br><span class="line"><span class="title">foo</span> = <span class="string">"hello, world"</span>  <span class="comment">-- 名称绑定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义一个函数，返回参数加一</span></span><br><span class="line"><span class="title">plus1</span> x=x+<span class="number">1</span></span><br><span class="line"><span class="comment">-- 函数调用的格式为 &lt;函数名&gt; &lt;参数1&gt; &lt;参数2&gt; ……</span></span><br><span class="line"><span class="comment">-- *Main&gt; plus1 41</span></span><br><span class="line"><span class="comment">-- 42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 递归调用，定义的顺序很重要，在前面的定义优先考虑</span></span><br><span class="line"><span class="title">fact</span> <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="title">fact</span> n = n * fact (n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列表 (a.k.a. 数组)</span></span><br><span class="line"><span class="title">list1</span> = [<span class="string">"I"</span>, <span class="string">"am"</span>, <span class="string">"a"</span>, <span class="string">"list"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 元组</span></span><br><span class="line"><span class="title">tuple1</span> = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="title">triple1</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 元组的模式匹配</span></span><br><span class="line"><span class="title">sumOfTuple</span> (x1, x2) = x1+x2</span><br><span class="line"><span class="comment">-- *Main&gt; sumOfTuple tuple1</span></span><br><span class="line"><span class="comment">-- 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列表与列表合并</span></span><br><span class="line"><span class="title">list2</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">list3</span> = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="title">list4</span> = list2 ++ list3</span><br><span class="line"><span class="comment">-- *Main&gt; list4</span></span><br><span class="line"><span class="comment">-- [1,2,3,4,5,6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串是字符组成的列表</span></span><br><span class="line"><span class="title">str1</span> = <span class="string">"foo"</span> ++ ['b','a','r']</span><br><span class="line"><span class="comment">-- *Main&gt; str1</span></span><br><span class="line"><span class="comment">-- "foobar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列表头部插入, 以下四种表达方式等价</span></span><br><span class="line"><span class="title">list5</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">list6</span> = <span class="number">1</span>:[<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">list7</span> = <span class="number">1</span>:<span class="number">2</span>:[<span class="number">3</span>]</span><br><span class="line"><span class="title">list8</span> = <span class="number">1</span>:<span class="number">2</span>:<span class="number">3</span>:[]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列表的模式匹配</span></span><br><span class="line"><span class="title">sumOfList</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">sumOfList</span> (headElement:remainingElements) = headElement + sumOfList remainingElements</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 强制前缀表达式</span></span><br><span class="line"><span class="title">three</span> = (+) <span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 强制中缀表达式，mod为取模函数</span></span><br><span class="line"><span class="title">four</span> = <span class="number">18</span> `mod` <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数部分求值 (Partial application)，以下两个函数等价</span></span><br><span class="line"><span class="comment">-- 单引号没有特殊意义，是合法函数名的一部分</span></span><br><span class="line"><span class="title">plus2</span>  x = (+) <span class="number">2</span> x</span><br><span class="line"><span class="title">plus2'</span>   = (+) <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- if 条件 (类似三目运算符)</span></span><br><span class="line"><span class="title">five</span> = <span class="keyword">if</span> <span class="type">False</span> <span class="keyword">then</span> <span class="number">4</span> <span class="keyword">else</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- let 名称绑定</span></span><br><span class="line"><span class="title">six</span>  = <span class="keyword">let</span> x = <span class="number">7</span> <span class="keyword">in</span> x<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Guard</span></span><br><span class="line"><span class="title">sign</span> x</span><br><span class="line">    | x &lt; <span class="number">0</span>     = <span class="number">-1</span></span><br><span class="line">    | x == <span class="number">0</span>    = <span class="number">0</span></span><br><span class="line">    | otherwise = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数复合</span></span><br><span class="line"><span class="title">plus4</span>  x = plus2 (plus2 x)</span><br><span class="line"><span class="title">plus4'</span> x = (plus2 . plus2) x</span><br><span class="line"><span class="title">plus4''</span>  = plus2 . plus2</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Lambda表达式 (a.k.a. 匿名函数)</span></span><br><span class="line"><span class="title">sum'</span>  = (\x y -&gt; x+y)</span><br><span class="line"><span class="title">plus5</span> = (\x   -&gt; sum' x <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>这里仅列出了极少数基本用法。更多关于语言本身的以及数据结构的特定语法规则请参考相关Haskell教程。</p><h1 id="类型标记"><a href="#类型标记" class="headerlink" title="类型标记"></a>类型标记</h1><p>Haskell 是一门具有类型推导的静态类型语言。每个表达式都有自己的类型，在 GHCi 的交互模式下，可以使用<code>:t &lt;表达式&gt;</code>来检查表达式的类型。类型注记通常写为<code>&lt;表达式&gt; :: &lt;类型&gt;</code>。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 布尔型</span></span><br><span class="line">*<span class="type">Main</span>&gt; :t <span class="type">True</span></span><br><span class="line"><span class="type">True</span>::<span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 元组</span></span><br><span class="line">*<span class="type">Main</span>&gt; :t (<span class="type">True</span>, <span class="type">False</span>)</span><br><span class="line">(<span class="type">True</span>, <span class="type">False</span>) :: (<span class="type">Bool</span>, <span class="type">Bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列表</span></span><br><span class="line">*<span class="type">Main</span>&gt; :t <span class="string">"123"</span></span><br><span class="line"><span class="string">"123"</span> :: [<span class="type">Char</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数</span></span><br><span class="line">*<span class="type">Main</span>&gt; :t (+)</span><br><span class="line">(+) :: <span class="type">Num</span> a =&gt; a -&gt; a -&gt; a</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 部分求值后，新的函数只需要一个参数</span></span><br><span class="line">*<span class="type">Main</span>&gt; :t (+) <span class="number">1</span></span><br><span class="line">(+) <span class="number">1</span> :: <span class="type">Num</span> a =&gt; a -&gt; a</span><br></pre></td></tr></table></figure><p>函数类型以 <code>(参数1的类型) -&gt; (参数2的类型) -&gt; ... -&gt; (返回值的类型)</code> 形式表达。不明显区分参数和返回值。<code>Num</code>是代表数字的类型类，可以近似理解成Java中的接口。<code>Num a =&gt;</code> 表示 “在后续的类型定义中，<code>a</code>可以被替换成任何满足<code>Num</code>的类型”。整数<code>Int</code>和浮点数<code>Float</code>都是<code>Num</code>类型类的成员，所以加法函数既可以将整数相加，也可以将浮点数相加。</p><p>类型箭头都是右结合，但是你可以手动添加括号来改变类型的意义</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 接受一个整型参数，返回一个新函数。这个新函数接受一个整型，返回一个整型</span></span><br><span class="line"><span class="title">product'</span> :: <span class="type">Int</span> -&gt; (<span class="type">Int</span> -&gt; <span class="type">Int</span>)</span><br><span class="line"><span class="title">product'</span> x y = x * y</span><br><span class="line"><span class="title">timesThree</span> = product' <span class="number">3</span></span><br><span class="line"><span class="title">nine</span> = timesThree <span class="number">3</span></span><br><span class="line"><span class="title">nine'</span> = (product' <span class="number">3</span>) <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 接受一个参数，该参数是“接受一个整型，返回一个整型”的函数，然后返回一个整型</span></span><br><span class="line"><span class="title">some_func</span> :: (<span class="type">Int</span> -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">some_func</span> f = f <span class="number">42</span></span><br><span class="line"><span class="comment">-- *Main&gt; some_func (* 2)</span></span><br><span class="line"><span class="comment">-- 84</span></span><br></pre></td></tr></table></figure><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>Haskell 中定义新类型的基本语法是<code>data &lt;新类型名&gt; [类型参数..] = &lt;构造函数1&gt; [成员类型...] | &lt;构造函数2&gt; [成员类型...] | ...</code>。类型名和构造函数都需要首字母大写。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">NameAndAge</span> = <span class="type">MakeNameAndAge</span> <span class="type">String</span> <span class="type">Int</span></span></span><br><span class="line"><span class="comment">-- *Main&gt; :t MakeNameAndAge</span></span><br><span class="line"><span class="comment">-- MakeNameAndAge :: String -&gt; Int -&gt; NameAndAge</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">IntOrBool</span> = <span class="type">MakeInt</span> <span class="type">Int</span> | <span class="type">MakeBool</span> <span class="type">Bool</span></span></span><br><span class="line"><span class="comment">-- *Main&gt; :t MakeInt</span></span><br><span class="line"><span class="comment">-- MakeInt :: Int -&gt; IntOrBool</span></span><br><span class="line"><span class="comment">-- *Main&gt; :t MakeBool</span></span><br><span class="line"><span class="comment">-- MakeBool :: Bool -&gt; IntOrBool</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Weekends</span> = <span class="type">Saturday</span> | <span class="type">Sunday</span></span></span><br><span class="line"><span class="comment">-- Saturday :: Weekends</span></span><br><span class="line"><span class="comment">-- Sunday :: Weekends</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">TupleOf</span> a = <span class="type">MakeTupleOf</span> a a</span></span><br><span class="line"><span class="comment">-- MakeTupleOf :: a -&gt; a -&gt; TupleOf a</span></span><br><span class="line"><span class="comment">-- MakeTupleOf False True :: TupleOf Bool</span></span><br><span class="line"><span class="comment">-- MakeTupleOf 1 2 :: Num a =&gt; TupleOf a</span></span><br><span class="line"><span class="comment">-- MakeTupleOf plus1 plus2 :: Num a =&gt; TupleOf (a -&gt; a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 你可以使用函数的模式匹配来提取数据结构中的成员</span></span><br><span class="line"><span class="title">printNameAndAge</span> :: <span class="type">NameAndAge</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">printNameAndAge</span> (<span class="type">MakeNameAndAge</span> name age) =</span><br><span class="line">    <span class="string">"I'm "</span> ++ name ++ <span class="string">" and I'm "</span> ++ (show age) ++ <span class="string">" years old."</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 你也可以使用模式匹配来判断是哪一个构造函数</span></span><br><span class="line"><span class="title">printIntOrBool</span> :: <span class="type">IntOrBool</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">printIntOrBool</span> (<span class="type">MakeInt</span> n) = <span class="string">"Wow, an integer: "</span> ++ (show n)</span><br><span class="line"><span class="title">printIntOrBool</span> (<span class="type">MakeBool</span> b) = <span class="string">"Wow, a boolean: "</span> ++ (show b)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 你甚至可以进行递归类型定义 。当然，你需要一个终止条件。</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">ListOf</span> a = <span class="type">EmptyList</span> | <span class="type">AppendList</span> (<span class="type">ListOf</span> <span class="title">a</span>) a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 相关操作也需要使用递归函数来完成</span></span><br><span class="line"><span class="title">contains</span> :: (<span class="type">Eq</span> a) =&gt; <span class="type">ListOf</span> a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">contains</span> <span class="type">EmptyList</span> _ = <span class="type">False</span></span><br><span class="line"><span class="title">contains</span> (<span class="type">AppendList</span> list x') x =</span><br><span class="line">    <span class="keyword">if</span> x == x' <span class="keyword">then</span> <span class="type">True</span> <span class="keyword">else</span> contains list x</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为 ListOf a 类型实现 Eq 类型类</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Eq</span> a =&gt; <span class="type">Eq</span> (<span class="type">ListOf</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    <span class="type">EmptyList</span> == <span class="type">EmptyList</span>                   = <span class="type">True</span></span><br><span class="line">    (<span class="type">AppendList</span> l1 a1) == (<span class="type">AppendList</span> l2 a2) = a1 == a2 &amp;&amp; l1 == l2</span><br><span class="line">    _ == _                                   = <span class="type">False</span></span><br></pre></td></tr></table></figure><p>注意：<code>a</code>是一个类型，<code>ListOf a</code>是一个类型，但是 <strong><em>ListOf 不是类型，ListOf 不是类型，ListOf 不是类型。</em></strong> 这个定义表示：<code>ListOf a</code>满足<code>Eq</code> 仅当 <code>a</code>满足<code>Eq</code>。要查看类型的相关信息，可以在 GHCi 中执行<code>:info</code>指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*Main&gt; :info Eq</span><br><span class="line">class Eq a where</span><br><span class="line">  (&#x3D;&#x3D;) :: a -&gt; a -&gt; Bool</span><br><span class="line">  (&#x2F;&#x3D;) :: a -&gt; a -&gt; Bool</span><br><span class="line">  &#123;-# MINIMAL (&#x3D;&#x3D;) | (&#x2F;&#x3D;) #-&#125;</span><br><span class="line">  -- Defined in ‘GHC.Classes’</span><br><span class="line">instance [safe] Eq a &#x3D;&gt; Eq (ListOf a) -- Defined at [omitted]</span><br><span class="line">[... omitted ...]</span><br></pre></td></tr></table></figure><h1 id="也许是个单子"><a href="#也许是个单子" class="headerlink" title="也许是个单子"></a>也许是个单子</h1><p><code>Maybe a</code>类似Java中的<code>Optional&lt;T&gt;</code>，常用于表示“会失败”的函数。</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Maybe</span> a = <span class="type">Nothing</span> | <span class="type">Just</span> a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一些函数</span></span><br><span class="line"><span class="title">func1</span> :: <span class="type">Float</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">func2</span> :: <span class="type">Int</span> -&gt; <span class="type">Maybe</span> <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p><code>Monad</code>是个类型类</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; :info <span class="type">Monad</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad</span> (<span class="title">m</span> :: * -&gt; *) <span class="keyword">where</span></span></span><br><span class="line">  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line">  (&gt;&gt;) :: m a -&gt; m b -&gt; m b</span><br><span class="line">  return :: a -&gt; m a</span><br><span class="line">  fail :: <span class="type">String</span> -&gt; m a</span><br></pre></td></tr></table></figure><p>简化一下</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line">  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line">  return :: a -&gt; m a</span><br></pre></td></tr></table></figure><p>当我们说<code>Maybe</code>是一个<code>Monad</code>的时候，一方面指 Maybe 属于 Monad 这个类型类<code>instance Monad Maybe where ...</code>。另一方面指<code>Maybe(数据结构)</code>，<code>(&gt;&gt;=)::Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b (函数)</code>，<code>return::a -&gt; Maybe a (函数)</code>这三者构成了一个满足某些条件的数学结构，这些条件被称为<a href="https://wiki.haskell.org/Monad_laws" target="_blank" rel="noopener">Monad Laws</a>。事实上，Haskell编译器不会检查 Monad Laws 是否满足，你可以胡乱写一些数据结构和函数，然后将其塞入 Monad 这个类型类中。换句话说，Haskell中的Monad就是一个接口，任何实现接口的数据类型都可以称其为Monad。</p><p>回到<code>Maybe</code>上，现在你想把这两个会失败的函数连接在一起</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">func3</span> :: <span class="type">Float</span> -&gt; <span class="type">Maybe</span> <span class="type">Bool</span></span><br><span class="line"><span class="comment">-- 错误示范，类型不匹配</span></span><br><span class="line"><span class="comment">-- func3 = func2.func1</span></span><br><span class="line"><span class="comment">-- 正确示范</span></span><br><span class="line"><span class="title">func3</span> n = <span class="keyword">case</span> (func1 n) <span class="keyword">of</span></span><br><span class="line">    <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></span><br><span class="line">    <span class="type">Just</span> n' -&gt; func2 n'</span><br></pre></td></tr></table></figure><p>看上去不错，我们需要一种操作，能把任意两个可失败的函数连在一起，这样以后再碰到这种情况直接复用就行了。如果第一个函数类型是<code>a-&gt;Maybe b</code>，第二个函数类型是<code>b-&gt;Maybe c</code>，那么复合函数的类型应该是<code>a-&gt;Maybe c</code></p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">composite</span> :: (b -&gt; <span class="type">Maybe</span> c) -&gt; (a -&gt; <span class="type">Maybe</span> b) -&gt; (a -&gt; <span class="type">Maybe</span> c)</span><br><span class="line"><span class="title">composite</span> f g = \x -&gt;</span><br><span class="line">    <span class="keyword">case</span> g x <span class="keyword">of</span></span><br><span class="line">        <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></span><br><span class="line">        <span class="type">Just</span> y  -&gt; f y</span><br><span class="line"></span><br><span class="line"><span class="title">func3'</span> = composite func2 func1</span><br></pre></td></tr></table></figure><p>看上去不错，不过有个小问题，执行的第一步<code>g x</code>并不需要<code>composite</code>函数来操心，完全可以由调用者算好了传进来，于是我们再简化下</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">composite</span> :: (b -&gt; <span class="type">Maybe</span> c) -&gt; (<span class="type">Maybe</span> b) -&gt; (<span class="type">Maybe</span> c)</span><br><span class="line"><span class="title">composite</span> f gx =</span><br><span class="line">    <span class="keyword">case</span> gx <span class="keyword">of</span></span><br><span class="line">        <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></span><br><span class="line">        <span class="type">Just</span> y  -&gt; f y</span><br><span class="line"></span><br><span class="line"><span class="title">func3''</span> x = composite func2 (func1 x)</span><br></pre></td></tr></table></figure><p>只要交换一下两个参数的顺序，我们就有了<code>Monad Maybe</code>的<code>&gt;&gt;=</code>函数。对于<code>Maybe</code>来说，它恰好有一个操作能满足Monad的定义，于是<code>Maybe</code>就是一个Monad。</p><h1 id="做得越多，写得越少"><a href="#做得越多，写得越少" class="headerlink" title="做得越多，写得越少"></a>做得越多，写得越少</h1><p><code>do</code>是Haskell中的一个关于<code>&gt;&gt;=</code>的语法糖，考虑有多个“可失败”函数需要调用的情况</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f1</span> x = <span class="type">Just</span> (x+<span class="number">1</span>)</span><br><span class="line"><span class="title">f2</span> x = <span class="type">Just</span> (x*<span class="number">2</span>)</span><br><span class="line"><span class="title">f3</span> x = <span class="type">Just</span> (x<span class="number">-3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 &gt;&gt;= 函数</span></span><br><span class="line"><span class="title">just16</span> = (<span class="type">Just</span> <span class="number">5</span>)</span><br><span class="line">         &gt;&gt;= (\x -&gt; f1 (x+<span class="number">1</span>))</span><br><span class="line">         &gt;&gt;= (\y -&gt; f2 (y+<span class="number">2</span>))</span><br><span class="line">         &gt;&gt;= (\z -&gt; f3 (z+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 do 语法</span></span><br><span class="line"><span class="title">just16'</span> = <span class="keyword">do</span></span><br><span class="line">    x &lt;- <span class="type">Just</span> <span class="number">5</span></span><br><span class="line">    y &lt;- f1 (x+<span class="number">1</span>)</span><br><span class="line">    z &lt;- f2 (y+<span class="number">2</span>)</span><br><span class="line">    f3 (z+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><code>do</code>会按照规则展开成<code>&gt;&gt;=</code>函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do x &lt;- expr</span><br><span class="line">   more_exprs</span><br><span class="line">会被展开成</span><br><span class="line">expr &gt;&gt;&#x3D; (\x -&gt; more_exprs)</span><br></pre></td></tr></table></figure><p>因此两者是等价的。但是<code>do</code>语法更加整齐易于阅读。</p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul><li><a href="https://www.haskell.org/documentation/" target="_blank" rel="noopener">一大堆的资料</a></li><li><a href="http://learnyouahaskell.com/chapters" target="_blank" rel="noopener">Learn You a Haskell for Great Good!</a>: 是一本 Haskell 教程</li><li><a href="https://hoogle.haskell.org/" target="_blank" rel="noopener">Hoogle</a>：Haskell 函数查询工具</li><li><a href="https://www.google.com" target="_blank" rel="noopener">Google</a>：你永远的好伙伴 ;-)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;用任何你喜欢的方法安装 &lt;a href=&quot;https://www.haskell.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Glasgow Haskell Compiler&lt;/a&gt; (a.k.a. GHC)。Cabal 之类的&lt;br&gt;依赖管理系统就用不着了。 &lt;del&gt;因为我也不会用。&lt;/del&gt; 保证能够执行&lt;code&gt;ghc&lt;/code&gt;和&lt;code&gt;ghci&lt;/code&gt;命令就行。&lt;/p&gt;
&lt;h1 id=&quot;GHCi基础&quot;&gt;&lt;a href=&quot;#GHCi基础&quot; class=&quot;headerlink&quot; title=&quot;GHCi基础&quot;&gt;&lt;/a&gt;GHCi基础&lt;/h1&gt;&lt;p&gt;首先，把以下文件保存成&lt;code&gt;helloworld.hs&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;figcaption&gt;&lt;span&gt;helloworld.hs&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;hello, world&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后执行&lt;code&gt;ghci helloworld.hs&lt;/code&gt;，然后在&lt;code&gt;&amp;gt;&lt;/code&gt;提示符后输入&lt;code&gt;foo&lt;/code&gt;并回车&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GHCi, version 8.6.3: http:&amp;#x2F;&amp;#x2F;www.haskell.org&amp;#x2F;ghc&amp;#x2F;  :? for help&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[1 of 1] Compiling Main             ( helloworld.hs, interpreted )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ok, one module loaded.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*Main&amp;gt; foo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;hello, world&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*Main&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你可以使用&lt;code&gt;:r&lt;/code&gt;来重新载入文件，也可以使用&lt;code&gt;:l &amp;lt;文件名&amp;gt;&lt;/code&gt;来载入代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="编程" scheme="https://recursiveg.me/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Haskell" scheme="https://recursiveg.me/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>编写一个简易的Chrome扩展</title>
    <link href="https://recursiveg.me/2017/05/simple-chrome-extension/"/>
    <id>https://recursiveg.me/2017/05/simple-chrome-extension/</id>
    <published>2017-05-12T09:30:00.000Z</published>
    <updated>2020-01-12T19:20:05.830Z</updated>
    
    <content type="html"><![CDATA[<p>时隔半年的毫无诚心的流水帐作品。<br>假设读者有基础的Javascript能力。</p><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>常去的某资源站的某资源发布者喜欢把重要的内容加上花里胡哨的特殊效果并藏在页面的角落里。<br>虽说要尊重资源的发布者，不过这种给人添堵的行为实在令我感到不爽，于是研究了一下Chrome的扩展程序（Extension）。</p><h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><p>要干的事情有两件：</p><ol><li>将内容移到页面的显著位置</li><li><del>去掉辣眼睛的特殊效果</del> 好吧，其实这条并不重要，毕竟内容已经被移到显著位置了</li></ol><p>很自然的，直接用Javascript操纵DOM树即可实现希望的效果。<br>那么要怎么自动载入脚本呢？</p><a id="more"></a><h1 id="编写扩展"><a href="#编写扩展" class="headerlink" title="编写扩展"></a>编写扩展</h1><p>感谢Chrome提供了强大的扩展系统。自动载入脚本这种功能自然是小菜一碟啦。<br>首先编写一个脚本<code>content_script.js</code>操纵页面元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (page_require_modification()) &#123;</span><br><span class="line">    <span class="keyword">var</span> content = <span class="built_in">document</span>.getElementById(<span class="string">"hidden-div"</span>).innerHTML;</span><br><span class="line">    <span class="keyword">var</span> clean_content = <span class="built_in">document</span>.createElement(<span class="string">"p"</span>);</span><br><span class="line">    clean_content.append(<span class="built_in">document</span>.createTextNode(content));</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"main-div"</span>).append(clean_content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有魔法，想干啥就写啥，就像是HTML本身引用了一个JS文件一样。也不需要考虑<code>document.ready</code>的问题，因为Chrome默认会在文档加载完成后再加载自定义的JS。</p><p>接着需要一个<code>manifest.json</code>文件，这样Chrome才能将其作为一个Extension加载。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"manifest_version"</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"在这里填上扩展的名称"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"这里填一些描述"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">"content_scripts"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="attr">"matches"</span>: [<span class="string">"https://www.google.com/*"</span>],</span><br><span class="line">          <span class="attr">"js"</span>: [<span class="string">"content_script.js"</span>]</span><br><span class="line">      &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>你觉得我会把实际的URL写出来嘛？肯定不会啦！</del><br>Chrome把这种注入到页面中的脚本称做<code>content_scripts</code>。当页面的URL符合<code>matches</code>中的pattern时，就自动加载<code>js</code>中指定的脚本。当然，脚本的文件名可以自由决定，只要前后一致即可。</p><p>最后一步，将<code>manifest.json</code>和<code>content_script.js</code>放入同一个文件夹。然后在<code>chrome://extensions</code>选择<code>加载已解压的扩展程序</code>即可加载扩展啦。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>manifest.json</code>文件指示了一个Chrome扩展</li><li>Chrome扩展能将自定义脚本注入到符合指定URL的页面中</li><li>这种单纯的脚本注入任务可能Greasemonkey更适合一些，不过这次就先研究Chrome扩展啦~ 有机会再研究油猴脚本。</li><li>Chrome扩展可以和浏览器本身做到更紧密的结合，比如提供菜单项或者是GUI之类的，不过这篇文章完全没有涉及。</li><li><a href="https://developer.chrome.com/extensions" target="_blank" rel="noopener">Google的官方扩展指南</a>永远是你的好伙伴</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时隔半年的毫无诚心的流水帐作品。&lt;br&gt;假设读者有基础的Javascript能力。&lt;/p&gt;
&lt;h1 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h1&gt;&lt;p&gt;常去的某资源站的某资源发布者喜欢把重要的内容加上花里胡哨的特殊效果并藏在页面的角落里。&lt;br&gt;虽说要尊重资源的发布者，不过这种给人添堵的行为实在令我感到不爽，于是研究了一下Chrome的扩展程序（Extension）。&lt;/p&gt;
&lt;h1 id=&quot;基本思路&quot;&gt;&lt;a href=&quot;#基本思路&quot; class=&quot;headerlink&quot; title=&quot;基本思路&quot;&gt;&lt;/a&gt;基本思路&lt;/h1&gt;&lt;p&gt;要干的事情有两件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将内容移到页面的显著位置&lt;/li&gt;
&lt;li&gt;&lt;del&gt;去掉辣眼睛的特殊效果&lt;/del&gt; 好吧，其实这条并不重要，毕竟内容已经被移到显著位置了&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;很自然的，直接用Javascript操纵DOM树即可实现希望的效果。&lt;br&gt;那么要怎么自动载入脚本呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="编程" scheme="https://recursiveg.me/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="技术宅" scheme="https://recursiveg.me/tags/%E6%8A%80%E6%9C%AF%E5%AE%85/"/>
    
      <category term="Chrome" scheme="https://recursiveg.me/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>借助IPsec和strongSwan建立隧道并分配IPv6地址</title>
    <link href="https://recursiveg.me/2016/12/assign-ipv6-through-ipsec-and-strongswan/"/>
    <id>https://recursiveg.me/2016/12/assign-ipv6-through-ipsec-and-strongswan/</id>
    <published>2016-12-24T07:54:08.000Z</published>
    <updated>2020-01-12T19:20:06.296Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>在一年前，我写过一篇<a href="/2015/09/get-ipv6-via-gre-tunnel/">文章</a>，介绍利用GRE隧道将一台服务器的IPv6地址“分配”给另一台电脑，令其能访问IPv6网络的方法。<br>不过那种方法存在一些问题：</p><ul><li>不能通过NAT</li><li>数据不加密</li><li>需要在服务器手动更新IP</li></ul><p>于是热爱折腾<del>作死</del>的我研究了一下使用IPsec配合IKEv2对流量进行加密的方法。</p><p>服务器与本地均为ArchLinux（Arch大法好），strongSwan软件包可从AUR安装。<br>服务器需要至少有一个公网IPv4和一段Routed IPv6 Subnet。</p><a id="more"></a><h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><p>我们一共需要三对“密钥-证书”对：</p><ul><li>CA密钥和证书：用于签署其它的证书，同时CA证书需要分发到所有机器上。</li><li>服务器密钥和证书</li><li>客户端密钥和证书</li></ul><p>我使用了ECC证书，因为其具有更短的长度。如果老版本不支持ECC的，也可以使用RSA证书。<br>先生成三把私钥：</p><pre><code>certtool --generate-privkey --ecc --outfile ca.keycerttool --generate-privkey --ecc --outfile server.keycerttool --generate-privkey --ecc --outfile client.key</code></pre><p>然后自签名CA证书，<code>Common Name</code>可以随意填，但是和之后的配置一定要统一：</p><pre><code>certtool --generate-self-signed --load-privkey ca.key --outfile ca.crt</code></pre><p>接着再用CA证书签名其它两把密钥，<code>Common Name</code>同样可以随意填，但是不要一样：</p><pre><code>certtool --generate-certificate --load-ca-privkey ca.key --load-ca-certificate ca.crt --load-privkey server.key --outfile server.crtcerttool --generate-certificate --load-ca-privkey ca.key --load-ca-certificate ca.crt --load-privkey client.key --outfile client.crt</code></pre><p>这样就一共产生了六个文件，保存备用。</p><h2 id="服务端设置"><a href="#服务端设置" class="headerlink" title="服务端设置"></a>服务端设置</h2><p>首先需要把密钥文件放到对应的位置：</p><ul><li><code>ca.crt</code>放入<code>/etc/ipsec.d/cacerts/</code></li><li><code>server.key</code>放入<code>/etc/ipsec.d/private/</code></li><li><code>server.crt</code>放入<code>/etc/ipsec.d/certs/</code></li></ul><p>然后编辑<code>/etc/ipsec.secrets</code>文件，注意空格</p><pre><code>&quot;CN=IPsec server&quot; : ECDSA &quot;server.key&quot;</code></pre><p>前面<code>CN=...</code>那一串是证书的Subject，CN即Common Name，可以通过<code>certtool -i &lt; server.crt</code>查看。</p><p>最后编辑<code>/etc/ipsec.conf</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">config setup</span><br><span class="line">    charondebug&#x3D;&quot;cfg 2, dmn 2, ike 2, net 2&quot;</span><br><span class="line"></span><br><span class="line">conn serverconn #此处是链接名称，可以自由填写</span><br><span class="line">    left&#x3D;%any</span><br><span class="line">    leftcert&#x3D;server.crt</span><br><span class="line">    leftid&#x3D;&quot;&#123;这边填入server.crt的Subject&#125;&quot;</span><br><span class="line">    leftca&#x3D;&quot;&#123;这边填入ca.crt的Subject&#125;&quot;</span><br><span class="line">    leftsubnet&#x3D;::&#x2F;0     #表示整个IPv6网络都在这端</span><br><span class="line"></span><br><span class="line">    right&#x3D;%any</span><br><span class="line">    rightca&#x3D;&quot;&#123;这边填入ca.crt的Subject&#125;&quot;</span><br><span class="line">    rightsourceip&#x3D;2001:abc:def:123:456::&#x2F;80 #客户端IP所在的&#x2F;80段</span><br><span class="line"></span><br><span class="line">    auto&#x3D;add</span><br><span class="line">    keyexchange&#x3D;ikev2</span><br><span class="line">    ike&#x3D;aes256gcm128-sha2_512-modp4096! #选择你喜欢的加密方法</span><br></pre></td></tr></table></figure><p>然后打开IPv6 Forwarding并启动服务</p><pre><code>sudo sysctl net.ipv6.conf.all.forwarding=1sudo systemctl start strongswan</code></pre><h2 id="客户端设置"><a href="#客户端设置" class="headerlink" title="客户端设置"></a>客户端设置</h2><p>步骤基本相同。</p><ul><li><code>ca.crt</code>放入<code>/etc/ipsec.d/cacerts/</code></li><li><code>client.key</code>放入<code>/etc/ipsec.d/private/</code></li><li><code>client.crt</code>放入<code>/etc/ipsec.d/certs/</code></li><li>编辑<code>ipsec.secrets</code>为<code>&quot;CN=...&quot; : ECDSA &quot;client.key&quot;</code></li></ul><p>编辑<code>/etc/ipsec.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">config setup</span><br><span class="line">    charondebug&#x3D;&quot;cfg 2, dmn 2, ike 2, net 2&quot;</span><br><span class="line"></span><br><span class="line">conn clientconn #此处是链接名称，可以自由填写</span><br><span class="line">    left&#x3D;%any</span><br><span class="line">    leftcert&#x3D;client.crt</span><br><span class="line">    leftsourceip&#x3D;%config6 #从服务器获取一个IPv6地址</span><br><span class="line"></span><br><span class="line">    right&#x3D;&#123;这里填上你服务器的IPv4地址&#125;</span><br><span class="line">    rightid&#x3D;&quot;&#123;这边填入server.crt的Subject&#125;&quot;</span><br><span class="line">    rightsubnet&#x3D;::&#x2F;0 #表示整个IPv6网络都在另一端</span><br><span class="line"></span><br><span class="line">    auto&#x3D;start        #自动连接</span><br><span class="line">    dpdaction&#x3D;restart #自动重连</span><br><span class="line">    keyexchange&#x3D;ikev2</span><br><span class="line">    ike&#x3D;aes256gcm128-sha2_512-modp4096!</span><br></pre></td></tr></table></figure><p>然后执行<code>sudo ipsec start --nofork</code>，如果出现<code>keeping connection path</code>字样应该就连接成功了。网卡上会出现一个新的IPv6地址，然后就可以直接访问IPv6网络了。</p><p>如果连接不成功或者是无法访问网络，可以考虑检查一下防火墙是不是把数据包drop了。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://wiki.strongswan.org/projects/strongswan/wiki" target="_blank" rel="noopener">strongSwan Wiki</a> strongSwan的官方文档库，同时提供了很多IPsec的资料</li><li><a href="https://www.gnutls.org/manual/html_node/certtool-Invocation.html" target="_blank" rel="noopener">certtool使用手册</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;在一年前，我写过一篇&lt;a href=&quot;/2015/09/get-ipv6-via-gre-tunnel/&quot;&gt;文章&lt;/a&gt;，介绍利用GRE隧道将一台服务器的IPv6地址“分配”给另一台电脑，令其能访问IPv6网络的方法。&lt;br&gt;不过那种方法存在一些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能通过NAT&lt;/li&gt;
&lt;li&gt;数据不加密&lt;/li&gt;
&lt;li&gt;需要在服务器手动更新IP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是热爱折腾&lt;del&gt;作死&lt;/del&gt;的我研究了一下使用IPsec配合IKEv2对流量进行加密的方法。&lt;/p&gt;
&lt;p&gt;服务器与本地均为ArchLinux（Arch大法好），strongSwan软件包可从AUR安装。&lt;br&gt;服务器需要至少有一个公网IPv4和一段Routed IPv6 Subnet。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="IPsec" scheme="https://recursiveg.me/tags/IPsec/"/>
    
      <category term="Networking" scheme="https://recursiveg.me/tags/Networking/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境TCP Socket与Epoll使用备忘</title>
    <link href="https://recursiveg.me/2015/12/linux-socket-epoll-demo/"/>
    <id>https://recursiveg.me/2015/12/linux-socket-epoll-demo/</id>
    <published>2015-12-25T11:15:13.000Z</published>
    <updated>2020-01-12T19:20:06.730Z</updated>
    
    <content type="html"><![CDATA[<p>流水帐式地记录了 Linux 下 TCP Socket 通信的方法和基本的 Epoll 使用方法。<br>没有错误处理。</p><h2 id="地址解析"><a href="#地址解析" class="headerlink" title="地址解析"></a>地址解析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">listen_addr</span>;</span> <span class="comment">//存放解析结果。参见`man getaddrinfo`</span></span><br><span class="line">getaddrinfo(<span class="string">"0.0.0.0"</span>, <span class="string">"55553"</span>, <span class="literal">NULL</span>, &amp;listen_addr); <span class="comment">// getaddrinfo([主机名],[端口],[hint],[结果])。成功返回 `0`</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">freeaddrinfo(listen_addr); <span class="comment">//释放资源，返回void</span></span><br></pre></td></tr></table></figure><h2 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h2><p>这种方式只能同时处理一个连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// int socket(int domain, int type, int protocol); 参见`man 3 socket` 创建文件描述符， 出错返回-1</span></span><br><span class="line">bind(fd, listen_addr-&gt;ai_addr, listen_addr-&gt;ai_addrlen);</span><br><span class="line">    <span class="comment">// int bind(int socket, const struct sockaddr *address,socklen_t address_len);</span></span><br><span class="line">    <span class="comment">// 绑定地址，出错返回-1，参见`man 3 bind`</span></span><br><span class="line"><span class="built_in">listen</span>(fd, SOMAXCONN);</span><br><span class="line">    <span class="comment">// int listen(int fd, int backlog(最大队列长度))</span></span><br><span class="line">    <span class="comment">// 开始监听，出错返回-1</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> new_fd = accept(fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// accept([fd], [监听地址], [监听地址结构体长度]) 第2，3个参数同bind()</span></span><br><span class="line">        <span class="comment">// 接受连接请求，若无请求则阻塞(也有可能是EAGAIN,取决于你需要什么)</span></span><br><span class="line">        <span class="comment">// 返回用于和对端通信的新的文件描述符,出错返回-1</span></span><br><span class="line">    <span class="comment">// ... handle(new_fd);</span></span><br><span class="line">    <span class="built_in">close</span>(new_fd); <span class="comment">// 关闭文件描述符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">server_addr</span>;</span></span><br><span class="line">getaddrinfo(<span class="string">"127.0.0.1"</span>, <span class="string">"55553"</span>, <span class="literal">NULL</span>, &amp;server_addr);</span><br><span class="line"><span class="keyword">int</span> server_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">connect</span>(server_socket, server_addr-&gt;ai_addr, server_addr-&gt;ai_addrlen)</span><br><span class="line">    <span class="comment">// 基本同bind() 参见 man 3 connect</span></span><br><span class="line">    <span class="comment">// 成功后可用server_socket与服务器通信</span></span><br><span class="line"><span class="comment">// ... send(...)</span></span><br><span class="line"><span class="comment">// ... recv(...)</span></span><br><span class="line"><span class="built_in">close</span>(server_socket);</span><br><span class="line">freeaddrinfo(server_addr);</span><br></pre></td></tr></table></figure><h2 id="传送数据"><a href="#传送数据" class="headerlink" title="传送数据"></a>传送数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *payload = <span class="string">"hello"</span></span><br><span class="line">send(new_fd, payload, <span class="built_in">strlen</span>(payload), <span class="number">0</span>); <span class="comment">// send([fd], [buffer], [需发送消息长度], [flag]) 返回实际发送的消息长度</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">255</span>];</span><br><span class="line">recv(new_fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>); <span class="comment">// send([fd], [buffer], [最大接收消息长度], [flag]) 返回实际接收的消息长度。阻塞模式下，若无消息则阻塞</span></span><br></pre></td></tr></table></figure><h2 id="多进程请求处理"><a href="#多进程请求处理" class="headerlink" title="多进程请求处理"></a>多进程请求处理</h2><p>对于每一个请求fork()一个新的进程进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> new_fd = accept(fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123; <span class="comment">// fork()返回0说明是子进程</span></span><br><span class="line">        <span class="comment">// ... handle(new_fd);</span></span><br><span class="line">        <span class="built_in">close</span>(new_fd);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> epollfd = epoll_create(<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">// 创建epoll文件描述符，出错返回-1</span></span><br><span class="line">    <span class="comment">// int epoll_create(int size) 从Linux2.6.8开始，size值被忽略，不过为保持兼容需要设定为一个正整数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span> <span class="comment">// 记录套接字相关信息</span></span><br><span class="line">ev.events = EPOLLIN; <span class="comment">// 监视有数据可读事件</span></span><br><span class="line">ev.data.fd = fd; <span class="comment">// 文件描述符数据，其实这里可以放任何数据。</span></span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;ev);</span><br><span class="line">    <span class="comment">// int epoll_ctl([Epoll FD], [Operation], [fd], [epoll_event]);</span></span><br><span class="line">    <span class="comment">// 加入监听列表，当fd上有对应事件产生时，epoll_wait会将epoll_event填充到events_in数组里</span></span><br><span class="line">    <span class="comment">// 出错返回-1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events_in</span>[16];</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> event_count = epoll_wait(epollfd, events_in, <span class="number">16</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 等待事件，epoll_wait会将事件填充至events_in内</span></span><br><span class="line">        <span class="comment">// int epoll_wait([epoll fd], struct epoll_event *events, [最大事件数量], int timeout);</span></span><br><span class="line">        <span class="comment">// 返回 获得的事件数量，若超时且没有任何事件返回0，出错返回-1。timeout设置为-1表示无限等待。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;event_count; i++) &#123; <span class="comment">// 遍历所有事件</span></span><br><span class="line">        <span class="keyword">if</span> (events_in[i].data.fd == fd) &#123; <span class="comment">// 新连接请求</span></span><br><span class="line">            <span class="keyword">int</span> new_fd = accept(fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            ev.events = EPOLLIN; <span class="comment">// 参见man 7 epoll 如果要使用Edge Trigger还需将new_fd设为非阻塞</span></span><br><span class="line">            ev.data.fd = new_fd;</span><br><span class="line">            epoll_ctl(epollfd, EPOLL_CTL_ADD, new_fd, &amp;ev); <span class="comment">// 将新连接加入监视列表</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> new_fd = events_in[i].data.fd;</span><br><span class="line">            <span class="comment">// ... handle(new_fd);</span></span><br><span class="line">            epoll_ctl(epollfd, EPOLL_CTL_DEL, new_fd, <span class="literal">NULL</span>); <span class="comment">// 不再监听fd，最后一个参数被忽略</span></span><br><span class="line">            <span class="built_in">close</span>(new_fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><ul><li><a href="http://www.linux-mag.com/id/308/" target="_blank" rel="noopener">Blocking 与 Non-Blocking I/O</a></li><li><a href="http://www.ccvita.com/515.html" target="_blank" rel="noopener">Epoll 的 Edge-Trigger 与 Level-Trigger</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;流水帐式地记录了 Linux 下 TCP Socket 通信的方法和基本的 Epoll 使用方法。&lt;br&gt;没有错误处理。&lt;/p&gt;
&lt;h2 id=&quot;地址解析&quot;&gt;&lt;a href=&quot;#地址解析&quot; class=&quot;headerlink&quot; title=&quot;地址解析&quot;&gt;&lt;/a&gt;地址解析&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;addrinfo&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;listen_addr&lt;/span&gt;;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//存放解析结果。参见`man getaddrinfo`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getaddrinfo(&lt;span class=&quot;string&quot;&gt;&quot;0.0.0.0&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;55553&quot;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &amp;amp;listen_addr); &lt;span class=&quot;comment&quot;&gt;// getaddrinfo([主机名],[端口],[hint],[结果])。成功返回 `0`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;freeaddrinfo(listen_addr); &lt;span class=&quot;comment&quot;&gt;//释放资源，返回void&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;监听&quot;&gt;&lt;a href=&quot;#监听&quot; class=&quot;headerlink&quot; title=&quot;监听&quot;&gt;&lt;/a&gt;监听&lt;/h2&gt;&lt;p&gt;这种方式只能同时处理一个连接&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fd = socket(AF_INET, SOCK_STREAM, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// int socket(int domain, int type, int protocol); 参见`man 3 socket` 创建文件描述符， 出错返回-1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bind(fd, listen_addr-&amp;gt;ai_addr, listen_addr-&amp;gt;ai_addrlen);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// int bind(int socket, const struct sockaddr *address,socklen_t address_len);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 绑定地址，出错返回-1，参见`man 3 bind`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;listen&lt;/span&gt;(fd, SOMAXCONN);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// int listen(int fd, int backlog(最大队列长度))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 开始监听，出错返回-1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; new_fd = accept(fd, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// accept([fd], [监听地址], [监听地址结构体长度]) 第2，3个参数同bind()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 接受连接请求，若无请求则阻塞(也有可能是EAGAIN,取决于你需要什么)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 返回用于和对端通信的新的文件描述符,出错返回-1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ... handle(new_fd);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;close&lt;/span&gt;(new_fd); &lt;span class=&quot;comment&quot;&gt;// 关闭文件描述符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Epoll" scheme="https://recursiveg.me/tags/Epoll/"/>
    
      <category term="Socket" scheme="https://recursiveg.me/tags/Socket/"/>
    
      <category term="TCP" scheme="https://recursiveg.me/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Linux下建立GRE隧道并获取IPv6地址</title>
    <link href="https://recursiveg.me/2015/09/get-ipv6-via-gre-tunnel/"/>
    <id>https://recursiveg.me/2015/09/get-ipv6-via-gre-tunnel/</id>
    <published>2015-09-19T06:35:10.000Z</published>
    <updated>2020-01-12T19:20:07.180Z</updated>
    
    <content type="html"><![CDATA[<p>虽然HE有提供免费的Tunnelbroker，不过那速度实在不怎么样。于是考虑在有IPv6地址托管主机上建立一个GRE Tunnel。<br>GRE Tunnel需要有内核模块<code>ip_gre</code>支持。远程主机有一段/64的IPv6，我将其中的一段/80分配给自己的机器。<br>使用iproute2工具。当然，你自己的机器需要有一个公网IPv4地址。</p><ol><li>服务器的公网IPv4是<code>$server_ipv4</code></li><li>自己电脑（或者路由器）的公网IPv4是<code>$client_ipv4</code>。</li><li>服务器的IPv6段是<code>a:b:c:d::/64</code></li><li>要分配下去的IPv6段是<code>a:b:c:d:e::/80</code></li></ol><h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><p>脚本如下，需要root，建议用<code>sudo -i</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip tunnel add gre-tunnel mode gre remote <span class="variable">$client_ipv4</span> ttl 64</span><br><span class="line">ip link <span class="built_in">set</span> gre-tunnel up</span><br><span class="line">ip addr add a:b:c:d:e::1/80 dev gre-tunnel</span><br></pre></td></tr></table></figure><ul><li>第一行建立隧道，<code>gre-tunnel</code>是隧道名称，可以按自己喜欢的来，记得其他的也要一起改</li><li>第二行激活隧道</li><li>第三行分配IP地址</li></ul><a id="more"></a><h2 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h2><p>脚本如下，和服务端配置几乎一样，同样需要root：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip tunnel add gre-tunnel mode gre remote <span class="variable">$server_ipv4</span> ttl 64</span><br><span class="line">ip link <span class="built_in">set</span> gre-tunnel up</span><br><span class="line">ip addr add a:b:c:d:e::2/80 dev gre-tunnel</span><br><span class="line">ip -6 route add default dev gre-tunnel</span><br></pre></td></tr></table></figure><ul><li>第一行建立隧道，隧道名称不必和服务器的一样</li><li>第二行激活隧道</li><li>第三行分配IP地址，注意不要和服务器的冲突，这个IP也是将要暴露在网络上的IP</li><li>第四行设定路由，让IPv6流量都走隧道</li></ul><h2 id="访问网络"><a href="#访问网络" class="headerlink" title="访问网络"></a>访问网络</h2><p>现在，两台机器应该可以互ping了。有的比较奇葩的情况可能需要手动<code>ip link set gre0 up</code>一下，gre0似乎是内核模块自动加入的玩意儿，具体怎么回事我也不清楚–_–|<br>但是现在还不能访问外网，还需要在服务器执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv6.conf.all.forwarding=1</span><br><span class="line">sysctl net.ipv6.conf.all.proxy_ndp=1</span><br><span class="line">ip -6 neigh add proxy a:b:c:d:e::2 dev eth0</span><br></pre></td></tr></table></figure><p>第一行开启forward<br>二三行和IPv6的NDP(邻居发现)有关，又是个没搞明白的东西真是残念……<br>eth0是服务器实际连接网络的接口。</p><h2 id="删除-amp-修改"><a href="#删除-amp-修改" class="headerlink" title="删除 &amp; 修改"></a>删除 &amp; 修改</h2><p>要删除Tunnel，在两端均执行:</p><pre><code>ip link set gre-tunnel downip tunnel del gre-tunnel</code></pre><p>如果客户端IP变化:</p><pre><code>ip tunnel change gre-tunnel remote $new_client_ipv4</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>虽然叫做“隧道”，但是内容依然是<em>明文</em>，对保密要求高的同学们要注意了。<br>另外直接用命令建立的隧道在重启后会没有，所以可以考虑用networkd之类的东西来管理。<br>Linux在访问有IPv6地址的域名时会优先使用IPv6，所以要当心服务器流量爆炸。当然配置成IPv4优先也是可以的。<br>如果你的本地IPv4经常变动的话，你可能需要些脚本之类的东西自动更新服务器的Remote IP。<br>对于每一个新的IP(新的设备)，都需要在服务端执行<code>ip -6 neigh add</code>，有知道怎么解决这个问题的请务必留言…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然HE有提供免费的Tunnelbroker，不过那速度实在不怎么样。于是考虑在有IPv6地址托管主机上建立一个GRE Tunnel。&lt;br&gt;GRE Tunnel需要有内核模块&lt;code&gt;ip_gre&lt;/code&gt;支持。远程主机有一段/64的IPv6，我将其中的一段/80分配给自己的机器。&lt;br&gt;使用iproute2工具。当然，你自己的机器需要有一个公网IPv4地址。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务器的公网IPv4是&lt;code&gt;$server_ipv4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;自己电脑（或者路由器）的公网IPv4是&lt;code&gt;$client_ipv4&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;服务器的IPv6段是&lt;code&gt;a:b:c:d::/64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;要分配下去的IPv6段是&lt;code&gt;a:b:c:d:e::/80&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;服务器配置&quot;&gt;&lt;a href=&quot;#服务器配置&quot; class=&quot;headerlink&quot; title=&quot;服务器配置&quot;&gt;&lt;/a&gt;服务器配置&lt;/h2&gt;&lt;p&gt;脚本如下，需要root，建议用&lt;code&gt;sudo -i&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ip tunnel add gre-tunnel mode gre remote &lt;span class=&quot;variable&quot;&gt;$client_ipv4&lt;/span&gt; ttl 64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ip link &lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt; gre-tunnel up&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ip addr add a:b:c:d:e::1/80 dev gre-tunnel&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;第一行建立隧道，&lt;code&gt;gre-tunnel&lt;/code&gt;是隧道名称，可以按自己喜欢的来，记得其他的也要一起改&lt;/li&gt;
&lt;li&gt;第二行激活隧道&lt;/li&gt;
&lt;li&gt;第三行分配IP地址&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="GRE Tunnel" scheme="https://recursiveg.me/tags/GRE-Tunnel/"/>
    
      <category term="IPv6" scheme="https://recursiveg.me/tags/IPv6/"/>
    
  </entry>
  
  <entry>
    <title>IDEA下建立Forge开发环境的正确姿势</title>
    <link href="https://recursiveg.me/2014/12/setup-forge-workspace-with-idea/"/>
    <id>https://recursiveg.me/2014/12/setup-forge-workspace-with-idea/</id>
    <published>2014-12-11T06:17:48.000Z</published>
    <updated>2020-01-12T19:20:07.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>本文作于2014年末，其中记载的方法可能已经过期，请读者谨慎参考</strong><br>见过不少教程都是基于Eclipse的，而基于IDEA的文章少得可怜，遂决定写此文。<br>本文通篇基于Linux/IntellijIDEA进行讲解，Windows/MAC/Eclipse用户请自行依葫芦画瓢。</p><h1 id="设置Forge工作区"><a href="#设置Forge工作区" class="headerlink" title="设置Forge工作区"></a>设置Forge工作区</h1><p>当然，你得首先去<a href="http://files.minecraftforge.net/" target="_blank" rel="noopener">MinecraftForge</a>下载一份源代码。我这里用的是最新的<code>forge-1.7.10-10.13.2.1258-src.zip</code><br>接着，找个地方建立一个文件夹，这将是你的工程目录，我的叫做<code>Forge1.7.10-1258</code>。然后再在里面建立一个目录，比方说就叫<code>forge-1.7.10-10.13.2.1258-src</code>，把你的Forge源码解压进去。<br>现在，你的文件夹层次应该看起来是这样的：</p><pre><code>Forge1.7.10-1258└── forge-1.7.10-10.13.2.1258-src     ├── build.gradle     ├── CREDITS-fml.txt     ├── eclipse     ├── forge-1.7.10-10.13.2.1258-changelog.txt     ├── gradle     ├── gradlew     ├── gradlew.bat     ├── LICENSE-fml.txt     ├── MinecraftForge-Credits.txt     ├── MinecraftForge-License.txt     ├── README.txt     └── src</code></pre><p>你可以先按自己喜好改动一下<code>build.gradle</code>。比如，我喜欢手动指定一下mappings的版本：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">minecraft &#123;</span><br><span class="line">    version = <span class="string">"1.7.10-10.13.2.1258"</span></span><br><span class="line">    runDir = <span class="string">"eclipse"</span></span><br><span class="line">    mappings = <span class="string">"stable_12"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，cd到forge-1.7.10-10.13.2.1258-src目录下，执行如下两条命令：</p><pre><code>gradle -i setupDecompWorkspacegradle -i ideaModule</code></pre><p>然后请耐心等待指令完成，可以去喝杯牛奶睡个觉什么的。</p><a id="more"></a><h1 id="导入到IDEA"><a href="#导入到IDEA" class="headerlink" title="导入到IDEA"></a>导入到IDEA</h1><p>等以上操作完成后，就可以打开IDEA，选“Create New Project”，注意要建立一个<strong>空工程</strong>（Empty Project）</p><p><img src="/images/setup-forge-workspace-with-idea/1.png" alt="Create New Project"><br>“Project Name”自然可以随意填写，”Project Location”则是之前创建的目录，下方的”Project Format”推荐选”Directory Based”<br>点”Finish”之后应该会自动打开”Project Structure”窗口，如果没有的话可以按Ctrl+Alt+Shift+S或是从菜单栏”File –&gt; Project Structure”<br>打开窗口之后我们首先要选择SDK版本：先点左边的”Project”，然后在右边”Project SDK”里选一个，我是选了Java8，你当然可以选择任何版本（不要低于Java6）<br><img src="/images/setup-forge-workspace-with-idea/2.png" alt="Select Project SDK"><br>接着点左边的”Modules”,再点那个绿色的“+”号，接着选”Import Module”<br><img src="/images/setup-forge-workspace-with-idea/3.png" alt="Location of &quot;Import Module&quot;"><br>然后选forge-1.7.10-10.13.2.1258-src目录下的<code>forge-1.7.10-10.13.2.1258-src.iml</code>文件就好。<br>Import完了之后检查下有没有报错，如果没问题就可以点右下角OK。</p><p>重新cd到forge-1.7.10-10.13.2.1258-src目录下，执行如下三条命令让gradle自动建立运行配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ln -s ../.idea .</span><br><span class="line">gradle -i genIntellijRun</span><br><span class="line">rm .idea</span><br></pre></td></tr></table></figure><p>回到IDEA，然后有必要的话重新加载一下Project。继续选菜单栏”Run –&gt; Edit Configurations”,点左侧的”Minecraft Client”，修改”Working Directory”到<code>forge-1.7.10-10.13.2.1258-src/eclipse</code>。<br><img src="/images/setup-forge-workspace-with-idea/4.png" alt="Edit Configuration"><br>你也可以像我一样指定一个username。接着对”Minecraft Server”也如法炮制。然后右下角”OK”退出。</p><p>现在Forge应该就可以运行了，在IDEA的主界面右上角有这么一片区域，选”Minecraft Client”然后点右侧那个绿色的三角箭头即可<br><img src="/images/setup-forge-workspace-with-idea/5.png" alt="Execution Control Bar"></p><h1 id="一个Mod！"><a href="#一个Mod！" class="headerlink" title="一个Mod！"></a>一个Mod！</h1><p>如果之前的步骤都没有问题，你就可以继续了<br>为了更好地演示运行配置以及发布流程，我决定写一个Mod，添加一种矿石：“Xp Ore”,顾名思义，挖掉后能得到大量经验。</p><p>我们需要新建一个Module来写我们的代码：菜单栏”File –&gt; New Module”<br>我就叫XpOre好了，然后继续打开”Project Structure”，将<code>forge-1.7.10-10.13.2.1258-src</code>添加成为它的依赖。<br><img src="/images/setup-forge-workspace-with-idea/6.png" alt="Add to Dependencies"><br>那个菜单同样是点右边的绿色加号出来，点”Module Dependency”后在弹出来的窗口里选”forge-1.7.10-10.13.2.1258-src”然后”OK”即可。</p><p>之后就可以写Mod了！至于具体Mod怎么写我就不在这里提了，请各位参考其他文章。<br>这是我的代码和目录层次结构，请自行调整，我就不把每一步的细节都写出来了。<br>请记得把<code>java</code>和<code>resources</code>两个目录设置成代码根目录和资源根目录，具体方法是在文件夹上右键然后”Mark Directory As”<br><img src="/images/setup-forge-workspace-with-idea/7.png" alt="The Module Tree"><br>（xp_ore.png是矿石的材质，其实就是拿金矿石的材质把几个像素涂成绿色让它看起来比较像附魔瓶的颜色）<br>为了防止图挂，我再拿文本形式列一下目录</p><pre><code>XpOre├── src│   └── main│       ├── java (Sources Root)│       │   └── org│       │       └── devinprogress│       │           └── xpore│       │               └── XpOre.java│       └── resources (Resources Root)│           ├── assets│           │   └── xpore│           │       ├── lang│           │       │   └── en_US.lang│           │       └── textures│           │           └── blocks│           │               └── xp_ore.png│           └── mcmod.info└── XpOre.iml</code></pre><p>要想让这个Mod在IDEA里运行起来，有两种方式。第一种比较简单，直接菜单栏”Run –&gt; Edit Configurations –&gt; ‘Minecraft Client’ –&gt; Use classpath of mod …”下拉列表里选”XpOre”，保存退出运行即可。这种方式比较适合只开发一个Mod的情况。<br>当有N个Module互相依赖的时候，我推荐创建另一个Module，比方说，叫”Run”。然后令其依赖<code>forge-1.7.10-10.13.2.1258-src</code>和你需要加载的其他Module，然后”Use classpath of mod”选择”Run”即可。</p><h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><p>发布其实相当方便，把forge-1.7.10-10.13.2.1258-src文件夹里的<code>build.gradle</code>复制到<code>XpOre</code>文件夹下面<br>按自己喜好修改其中的<code>version</code>,<code>group</code>和<code>archivesBaseName</code>即可。比方说我的是：</p><pre><code>version = &quot;v0.1&quot;group= &quot;org.devinprogress.xpore&quot;archivesBaseName = &quot;XpOre-1.7.10&quot;</code></pre><p>然后在XpOre文件夹下<code>gradle build</code>即可。运行完成后，就能在<code>XpOre/build/libs/</code>文件夹下找到编译好的jar了。</p><p>最后来一张Mod的效果图<br><img src="/images/setup-forge-workspace-with-idea/8.png" alt="XpOre Mod"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;本文作于2014年末，其中记载的方法可能已经过期，请读者谨慎参考&lt;/strong&gt;&lt;br&gt;见过不少教程都是基于Eclipse的，而基于IDEA的文章少得可怜，遂决定写此文。&lt;br&gt;本文通篇基于Linux/IntellijIDEA进行讲解，Windows/MAC/Eclipse用户请自行依葫芦画瓢。&lt;/p&gt;
&lt;h1 id=&quot;设置Forge工作区&quot;&gt;&lt;a href=&quot;#设置Forge工作区&quot; class=&quot;headerlink&quot; title=&quot;设置Forge工作区&quot;&gt;&lt;/a&gt;设置Forge工作区&lt;/h1&gt;&lt;p&gt;当然，你得首先去&lt;a href=&quot;http://files.minecraftforge.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MinecraftForge&lt;/a&gt;下载一份源代码。我这里用的是最新的&lt;code&gt;forge-1.7.10-10.13.2.1258-src.zip&lt;/code&gt;&lt;br&gt;接着，找个地方建立一个文件夹，这将是你的工程目录，我的叫做&lt;code&gt;Forge1.7.10-1258&lt;/code&gt;。然后再在里面建立一个目录，比方说就叫&lt;code&gt;forge-1.7.10-10.13.2.1258-src&lt;/code&gt;，把你的Forge源码解压进去。&lt;br&gt;现在，你的文件夹层次应该看起来是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Forge1.7.10-1258
└── forge-1.7.10-10.13.2.1258-src
     ├── build.gradle
     ├── CREDITS-fml.txt
     ├── eclipse
     ├── forge-1.7.10-10.13.2.1258-changelog.txt
     ├── gradle
     ├── gradlew
     ├── gradlew.bat
     ├── LICENSE-fml.txt
     ├── MinecraftForge-Credits.txt
     ├── MinecraftForge-License.txt
     ├── README.txt
     └── src&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你可以先按自己喜好改动一下&lt;code&gt;build.gradle&lt;/code&gt;。比如，我喜欢手动指定一下mappings的版本：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;minecraft &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    version = &lt;span class=&quot;string&quot;&gt;&quot;1.7.10-10.13.2.1258&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    runDir = &lt;span class=&quot;string&quot;&gt;&quot;eclipse&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mappings = &lt;span class=&quot;string&quot;&gt;&quot;stable_12&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;接着，cd到forge-1.7.10-10.13.2.1258-src目录下，执行如下两条命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gradle -i setupDecompWorkspace
gradle -i ideaModule&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后请耐心等待指令完成，可以去喝杯牛奶睡个觉什么的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Minecraft" scheme="https://recursiveg.me/tags/Minecraft/"/>
    
      <category term="Java" scheme="https://recursiveg.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Minecraft Coremod开发杂事记</title>
    <link href="https://recursiveg.me/2014/11/minecraft-modding-with-asm/"/>
    <id>https://recursiveg.me/2014/11/minecraft-modding-with-asm/</id>
    <published>2014-11-04T13:48:53.000Z</published>
    <updated>2020-01-12T19:20:08.093Z</updated>
    
    <content type="html"><![CDATA[<p>表示最近时间荒废得厉害，主要都是耗在了<a href="http://www.minecraft.net" target="_blank" rel="noopener">Minecraft</a>这款游戏上。<br>Minecraft的一大魅力在于其几乎无穷的MODs，于是我也小试了一下Mod开发，顺便学习一下Java。<del>于是掉入了万劫不复的深坑</del><br>当然，我要做点和加个方块、改个合成表之类的不一样的事。<br>（教程中不少内容都参考了szszss的<a href="http://www.hakugyokurou.net/wordpress/?page_id=126" target="_blank" rel="noopener">博客</a>，在此表示深深的感谢）</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>关于这篇文章，不适合特别特别新的新人，我假设各位读者都有一些基础的编程经验。如果你是入门级别的，在MCBBS论坛的<a href="http://www.mcbbs.net/thread-54579-1-1.html" target="_blank" rel="noopener">编程开发板块</a>有不少不错的入门教程。<br>我假设各位读者都具备以下能力:</p><ul><li>会安装软件</li><li>了解基本的程序流程控制，比如判断、循环等</li><li>了解基本的OOP概念，比如类，继承等 （其实这条不是那么重要，Java看多了就自然会了 <del>一个原C程序员如是说</del>）</li><li>了解命令行、终端的基本使用方法</li><li>有方法正常访问国际互联网，如Facebook等</li><li>了解基本英语单词（这条似乎也不是那么重要，主要是希望大家能够在遇到问题时不要怕阅读英文资料）</li><li>（本教程面向Linux用户，Mac用户大同小异，Windows用户自己看着办）</li></ul><a id="more"></a><p>然后再来介绍一下要用到的工具:</p><ul><li><a href="http://mcp.ocean-labs.de/" target="_blank" rel="noopener">MCP</a>(Minecraft Coders’ Pack)主要负责反混淆Minecraft的代码，同时向Forge提供对应的文档</li><li><a href="http://files.minecraftforge.net/fml/" target="_blank" rel="noopener">FML</a>(Forge Mod Loader)提供了一些底层功能，如Mod加载，ASM等。</li><li><a href="http://www.minecraftforge.net" target="_blank" rel="noopener">Forge</a>提供了更高级的接口，如增加方块，修改合成表等。</li><li>ForgeGradle帮助建立开发环境和发布</li></ul><p>一般来说，FML都会附带在Forge里，在某些情况下，比如现在（2014年11月5日）1.8的Forge还未完成，但FML已放出，就可以单独只安装FML，先开始Coremod的开发。</p><h1 id="Intellij-IDEA配置教程"><a href="#Intellij-IDEA配置教程" class="headerlink" title="Intellij IDEA配置教程"></a>Intellij IDEA配置教程</h1><p>网上大部分教程都是讲Eclipse的，但是个人偏好IDEA，所以讲一下IDEA的配置流程。</p><ol><li><p>安装IDEA，没有必要找破解版，免费的Community Edition足够</p></li><li><p><a href="http://files.minecraftforge.net/" target="_blank" rel="noopener">下载</a>Forge代码，就是Src那个链接。请选择自己需要的版本，我以<code>1.7.10-Recommended</code>为例</p></li><li><p>解压到一个你看着顺眼的地方，然后依次执行以下命令</p><pre><code>gradle setupDecompWorkspacegradle ideagradle genIntellijRun</code></pre><p>没有装gradle也不想装的，可以用<code>./gradlew</code><br>强烈建议挂着代理或VPN做这事，否则将是极端痛苦的过程。<br>你也可以加上<code>-i</code>选项看滚滚的数据输出以不至于那么无聊。</p></li><li><p>打开IDEA，直接Open Project，选择目录下的.ipr文件应该就好了，你可以试着Run一下看看有没有什么问题。</p></li></ol><p>注：直接<code>gradle idea</code>现在是不被推荐的，可以尝试用<code>gradle ideaModule</code>代替，具体方法在<a href="/2014/12/setup-forge-workspace-with-idea/">我的另一篇日志</a>里有讲。<br>如果需要Socks代理的，可以这么来<code>gradle -DsocksProxyHost={代理服务器地址} -DsocksProxyPort={代理端口}</code></p><h1 id="代码管理与开发"><a href="#代码管理与开发" class="headerlink" title="代码管理与开发"></a>代码管理与开发</h1><p><del>源代码和资源文件都是放在<code>src</code>文件夹里的，有时要在多个不同的Mod间切换开发，我目前的解决方法是将代码统一放在别处，将src文件夹做软链接进来。同时我也非常推荐也用这种方法处理<code>build.gradle</code>文件。将代码放在别处还有个好处，就是可以用<code>git</code>来管理版本，而且可以用分支方便地管理对不同Minecraft版本做的修改。不管什么方式，自己习惯就好。</del></p><p>用了<code>gradle ideaModule</code>后，代码本身就分开放置了，不再需要这种方法了。</p><p>对于开发这一部分，自己深感无力(其实就是懒)，请参阅szszss的系列教程。<br>另外，现在已经没有Coremod文件夹了，所以所有Mod都放在Mods文件夹下，不同之处只在于<code>MANIFEST.MF</code>文件。</p><h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><p>感谢ForgeGradle，打包发布不再需要手动拷贝压缩一大堆文件了。首先，你需要修改下<code>build.gradle</code>文件，这也是我为什么推荐用软链接来管理它的原因。<br>以原始的文件为例：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version = <span class="string">"1.0"</span></span><br><span class="line">group= <span class="string">"com.yourname.modid"</span> <span class="comment">// http://maven.apache.org/guides/mini/guide-naming-conventions.html</span></span><br><span class="line">archivesBaseName = <span class="string">"modid"</span></span><br><span class="line"></span><br><span class="line">minecraft &#123;</span><br><span class="line">    version = <span class="string">"1.7.10-10.13.2.1230"</span></span><br><span class="line">    runDir = <span class="string">"eclipse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>archivesBaseName</code>和第一行<code>version</code>都可以自由修改，只会影响输出的jar文件的名字，关于<code>group</code>用途不明，有了解的求留言告知。<br>如果你打算把Mod升级到一个新的Forge版本，请务必修改<code>minecraft.version</code>和你的开发环境一致，否则会出现奇奇怪怪的问题。<br>修改好后，就可以用<code>gradle build</code>来编译了，同样建议开代理。编译好的jar在<code>build/libs</code>下。</p><p>如果是需要对MANIFEST进行修改的，比如Coremod，需要在<code>build.gradle</code>中minecraft块之后添加jar块:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jar &#123;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes <span class="string">'FMLCorePlugin'</span>: <span class="string">'org.devinprogress.uniskinmod.SkinCore'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你的一个jar包里既有普通Mod（以<code>@Mod</code>作Annotation的）又有Coremod，你还需要</p><pre><code>attributes &apos;FMLCorePluginContainsFMLMod&apos;: true</code></pre><p>否则普通Mod不会被载入。</p><h1 id="ASMTransformer"><a href="#ASMTransformer" class="headerlink" title="ASMTransformer"></a>ASMTransformer</h1><p>因为MCP坑爹的反混淆机制，开发者在处理Method或Field时需要对付三种不同的名字：</p><ol><li>形似<code>a</code>这样的混淆名，<code>obfName</code></li><li>形似<code>func_xxxx_a</code>这样的半混淆名，有时也称作<code>srgName</code></li><li>形似<code>doTick</code>这样的反混淆名，或称<code>mcpName</code></li></ol><p>关于为什么要有srgName，MCP是这么解释的：因为mcpName是任何人都可以贡献的（这是真的），所以会出现这么一种情况，有时为了更好地描述某个函数的功能，在次要版本升级时（比如1.7.1升级1.7.2），mcpName会发生变化，如果直接以mcpName进行编译，那么为1.7.1编译的Mod就无法在1.7.2上使用，即使其他方面都没有问题。于是为了解决这个问题，引入了相对固定的srgName。FML是这么处理名称的，在<code>gradle build</code>时，代码中所有的mcpName均会被混淆成srgName。然后在玩家运行游戏时，所有的obfName均被反混淆成srgName，即<code>RuntimeDeobfuscation</code>，运行时反混淆。</p><p>在你修改某个方法之前，首先必须定位它（废话）。定位一个方法需要四个信息：</p><ul><li>方法所在的类的完全限定名（这里这里指的是反混淆了的类名）</li><li>方法的srgName</li><li>方法的mcpName(用于在开发时确定方法，有时和srgName相同)</li><li>方法的Description，或者说，参数列表。</li></ul><p>类很好确定，每当一个新的类被加载时，都会调用<code>IClassTransformer</code>接口的<code>transform</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IClassTransformer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] transform(String obfuscatedClassName, String transformedClassName, <span class="keyword">byte</span>[] bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个参数就是反混淆了的类名，并且是点分割，大小写正确的，可以直接用<code>equals()</code>来判断。<br>但是方法名的判断就比较复杂，因为在ASM转换时，运行时反混淆还没有被执行，所以方法名全部都是obfName。更要命的是，如果方法的参数里有Minecraft的类，那么这个类名也是被混淆了的类名。</p><p>不过谢天谢地，我们有<code>FMLDeobfuscatingRemapper</code>，你可以用<code>FMLDeobfuscatingRemapper.INSTANCE</code>来取得实例。这个类提供了几个重要的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">mapMethodName</span><span class="params">(String obfedClassName, String obfedMethodName, String obfedMethodDescription)</span></span></span><br><span class="line"><span class="function">String <span class="title">mapFieldName</span><span class="params">(String obfedClassName, String obfedFieldName, String obfedFieldDescription)</span></span></span><br><span class="line"><span class="function">String <span class="title">mapMethodDesc</span><span class="params">(String obfedMethodDescription)</span></span></span><br></pre></td></tr></table></figure><p>其中<code>mapMethodName</code>和<code>mapFieldName</code>返回对应方法和字段的srgName，<code>mapMethodDesc</code>返回反混淆了的Description，也就是将<code>(Lbee;F)V</code>这种变为<code>(Lnet/minecraft/client/gui/GuiMainMenu;F)V</code>。</p><p>如果你需要在某个方法中添加大段的代码，我极度不推荐写长长的代码将所有这些操作码全部加到目标方法里去，这种方法枯燥至极，又不直观，还难于调试。我一般的方法是，使用<code>INVOKESTATIC</code>调用自己写好的函数，并将需要修改的变量作为参数传递，这样需要的代码不多，也易于调试和维护。</p><p>在向代码中添加操作，尤其是费时的操作时（比如网络IO）请务必谨慎选择插入的位置。因为大部分代码会在主线程中执行，一旦卡住轻则界面冻结，重则直接被服务器超时踢出。</p><p>我不是非常推荐让ASM自动计算栈大小和本地变量区大小，因为碰到一些比较复杂的类时会悲剧，比如<code>AbstractClientPlayer</code></p><p>如果你想清空一个方法让它什么都不做，请还是不要忘记加上RETURN</p><p>有时，开发环境下编译出的class和原始的class会有区别，所以还是建议用javap之类的工具看一下原始的字节码。</p><h1 id="AccessTransformer"><a href="#AccessTransformer" class="headerlink" title="AccessTransformer"></a>AccessTransformer</h1><p>有时，我们需要频繁调用某个private的Method或是Field，使用反射会有性能损失，而ASMTransformer也无效(因为无法通过编译)，这就到了AccessTransformer大显身手的时候了。<br>AccessTransformer用于将private或是protected的Method和Field变为public，这样在代码中就可以直接使用了。<br>你需要首先创建一个<code>*_at.cfg</code>的配置文件放在resources目录（就是放<code>mcmod.info</code>的目录）下，然后将其软链接到根目录下（和<code>build.gradle</code>同目录）。<br>配置文件的语法类似这样（这是<code>fml_at.cfg</code>的一部分）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> net.minecraft.entity.<span class="function">EntityList <span class="title">func_75618_a</span><span class="params">(Ljava/lang/Class;Ljava/lang/String;I)</span>V</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> net.minecraft.entity.EntityList field_75625_b #nameToClassMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> net.minecraft.item.crafting.CraftingManager <span class="title">func_92103_a</span><span class="params">(Lnet.minecraft.item.ItemStack;[Ljava/lang/Object;)</span>Lnet.minecraft.item.crafting.ShapedRecipes</span>;</span><br></pre></td></tr></table></figure><p>接着重建工作区：</p><pre><code>gradle clean setupDecompWorkspace idea --refresh-dependencies</code></pre><p>同样建议挂代理，用eclipse的同学把<code>idea</code>换成<code>eclipse</code>，有强迫症的同学可以加上<code>-i</code>选项。这样，开发环境下代码的改动就完成了。我在挂着代理的情况下大约需要8分钟。</p><p>为了让其在混淆环境下也能正常工作，你需要创建一个新的类，继承<code>AccessTransformer</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyATransformer</span> <span class="keyword">extends</span> <span class="title">AccessTransformer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyATransformer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"mymod_at.cfg"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的字符串就是配置文件名，然后在实现了<code>IFMLLoadingPlugin</code>的类里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAccessTransformerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MyATransformer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外需要注意的是，AccessTransformer不会自动转换衍生类，所以在转换基类时请务必当心，否则会编译不通过。</p><p>在1.7.10及以上的版本中，可以在build.gradle文件的中加入以下内容，这样就不必再写IFMLLoadingPlugin了。其中的<code>mymod_at.cfg</code>文件要放在META-INF文件夹下。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jar &#123;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes <span class="string">'FMLAT'</span>: <span class="string">'mymod_at.cfg'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他杂七杂八的东西"><a href="#其他杂七杂八的东西" class="headerlink" title="其他杂七杂八的东西"></a>其他杂七杂八的东西</h1><ul><li>如果你想给MCP贡献mcpName，可以去IRC esper#mcp 找 MCPBot_Reborn</li><li>最新的反混淆名对应表可以在<a href="http://export.mcpbot.bspk.rs/" target="_blank" rel="noopener">MCPBot Export</a>找到</li><li>如果你厌倦了用文本编辑器搜索字符串来找srgName的话，可以试试<a href="https://github.com/bspkrs/MCPMappingViewer/" target="_blank" rel="noopener">MCPMappingViewer</a></li><li><a href="https://bitbucket.org/mstrobel/procyon" target="_blank" rel="noopener">Procyon</a>是个极好的Java反编译器</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;表示最近时间荒废得厉害，主要都是耗在了&lt;a href=&quot;http://www.minecraft.net&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Minecraft&lt;/a&gt;这款游戏上。&lt;br&gt;Minecraft的一大魅力在于其几乎无穷的MODs，于是我也小试了一下Mod开发，顺便学习一下Java。&lt;del&gt;于是掉入了万劫不复的深坑&lt;/del&gt;&lt;br&gt;当然，我要做点和加个方块、改个合成表之类的不一样的事。&lt;br&gt;（教程中不少内容都参考了szszss的&lt;a href=&quot;http://www.hakugyokurou.net/wordpress/?page_id=126&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;博客&lt;/a&gt;，在此表示深深的感谢）&lt;/p&gt;
&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h1&gt;&lt;p&gt;关于这篇文章，不适合特别特别新的新人，我假设各位读者都有一些基础的编程经验。如果你是入门级别的，在MCBBS论坛的&lt;a href=&quot;http://www.mcbbs.net/thread-54579-1-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;编程开发板块&lt;/a&gt;有不少不错的入门教程。&lt;br&gt;我假设各位读者都具备以下能力:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会安装软件&lt;/li&gt;
&lt;li&gt;了解基本的程序流程控制，比如判断、循环等&lt;/li&gt;
&lt;li&gt;了解基本的OOP概念，比如类，继承等 （其实这条不是那么重要，Java看多了就自然会了 &lt;del&gt;一个原C程序员如是说&lt;/del&gt;）&lt;/li&gt;
&lt;li&gt;了解命令行、终端的基本使用方法&lt;/li&gt;
&lt;li&gt;有方法正常访问国际互联网，如Facebook等&lt;/li&gt;
&lt;li&gt;了解基本英语单词（这条似乎也不是那么重要，主要是希望大家能够在遇到问题时不要怕阅读英文资料）&lt;/li&gt;
&lt;li&gt;（本教程面向Linux用户，Mac用户大同小异，Windows用户自己看着办）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Minecraft" scheme="https://recursiveg.me/tags/Minecraft/"/>
    
      <category term="Java" scheme="https://recursiveg.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>域名注册商更换</title>
    <link href="https://recursiveg.me/2014/07/domain-name-registrar-switched/"/>
    <id>https://recursiveg.me/2014/07/domain-name-registrar-switched/</id>
    <published>2014-07-16T05:43:25.000Z</published>
    <updated>2020-01-12T19:20:08.510Z</updated>
    
    <content type="html"><![CDATA[<p>昨天折腾了一天，把域名从Godaddy转移到了Name.com<br>表示基本没遇到什么麻烦，信用卡借用了家长的，付款也很方便。<br>关键是便宜啊。转入9美刀，续期11美刀,比Godaddy坑爹的18刀便宜太多了啊<del>~<br>而且还有免费的WHOIS保护啊</del>优惠码<code>PRIVACYPLEASE</code>超好记有木有！<br>虽然不是最便宜的但是Name.com的控制台相当美观呐~<br>结尾吐槽一句：在万网注册的都是真的勇士。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天折腾了一天，把域名从Godaddy转移到了Name.com&lt;br&gt;表示基本没遇到什么麻烦，信用卡借用了家长的，付款也很方便。&lt;br&gt;关键是便宜啊。转入9美刀，续期11美刀,比Godaddy坑爹的18刀便宜太多了啊&lt;del&gt;~&lt;br&gt;而且还有免费的WHOIS保护啊&lt;/de
      
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Site Management" scheme="https://recursiveg.me/tags/Site-Management/"/>
    
  </entry>
  
  <entry>
    <title>Programming with PTRACE, Part6 - 时间控制</title>
    <link href="https://recursiveg.me/2014/07/programming-with-ptrace-part6/"/>
    <id>https://recursiveg.me/2014/07/programming-with-ptrace-part6/</id>
    <published>2014-07-07T08:51:03.000Z</published>
    <updated>2020-01-12T19:04:30.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="不同的时间计算方法"><a href="#不同的时间计算方法" class="headerlink" title="不同的时间计算方法"></a>不同的时间计算方法</h1><p>程序运行会占用一小段时间（废话），事实上，我们有不止一种方法来表示一个程序运行了多长时间。最直观的应该是“墙上时间”，也就是说，你掐个秒表，看看程序从开始到结束用了多长时间。除此之外，还有“用户态时间”和“内核态时间”，这两个时间都是以CPU实际运算的时间，也就是CPU周期，来计数的。“用户态时间”就是程序在用户态执行的时间，包括程序所引用的库中的代码（比如STL），“内核态时间”就是指程序在内核态执行的时间，一般是各种系统调用（比如各种IO操作）。这两种时间和墙上时间的区别在于，因为CPU其实是在多个程序中快速切换的，所以在运行某个程序的时间里，CPU也处理了属于其他进程的任务，而且CPU切换任务也需要一定的时间（真的很短）。如果处于被调试状态，tracer的运行时间也会被计算在内，这些不属于这个进程的时间片也会被计算在这个进程的“墙上时间”里。所以一般以用户态时间和内核态时间的总和作为进程的运行时间。</p><p>在Linux系统里有一个叫<code>time</code>的命令可以查看一个命令执行了多长时间。这个命令有两个版本，一个是shell内置的，另一个是独立的可执行文件，可以用<code>type time</code>命令查看。虽然可执行版本功能更强一点，但内置的功能足够，这一点区别可以不管。用法是： <code>time [命令] &lt;参数&gt;</code>。给个例子：</p><pre><code>time ffmpeg -i sample.mp4 target.mp3...5.42s user0.10s system100% cpu5.520 total</code></pre><a id="more"></a><h1 id="动手写个带时限的time"><a href="#动手写个带时限的time" class="headerlink" title="动手写个带时限的time"></a>动手写个带时限的time</h1><p>还在对上个PART的<code>setrlimit</code>耿耿于怀么？我们现在就来用它！相关的定义位于<code>sys/resource.h</code>头文件里。我们这次要用到<code>RLIMIT_CPU</code>,这个选项限制进程所能占用的CPU时间，以秒为单位，可以把它理解为用户态时间和内核态时间的和。我们首先要使用<code>getrlimit</code>获得当前的限制：</p><pre><code>struct rlimit TimeL;getrlimit(RLIMIT_CPU,&amp;TimeL);</code></pre><p><code>rlimit</code>结构有两个成员:</p><ul><li><code>rlim_cur</code> 软限制</li><li><code>rlim_max</code> 硬限制</li></ul><p>系统一般会用比较平和的方式对待那些达到软限制的进程，比如发个SIGSEGV什么的。而那些达到硬限制的进程会被直接SIGKILL。我们接下来要修改软限制，注意单位是秒。</p><pre><code>TimeL.rlim_cur=Timeout;</code></pre><p>以上工作都要在<code>fork()</code>之前完成，之后要在<em>子进程</em>里应用这个限制（没错就是exec那里）</p><pre><code>setrlimit(RLIMIT_CPU,&amp;TimeL);</code></pre><p>这样，如果子进程超过软限制，系统就会发送<code>SIGXCPU</code>信号给子进程。当然，因为ptrace的原因，信号会被先发送给父进程，这样就可以用part3里介绍的方法进行处理。这样子进程是要清蒸还是油炸就都由父进程决定了。<br>当然，我们还有别的方法获取时间信息。一是用<code>gettimeofday()</code>函数配合<code>timeval</code>结构，可以获得当前时间，精确到微秒（百万分之一秒）。在程序开始时调用下，结束时调用下，相减即可得到墙上时间。另一种方法是利用<code>wait4</code>里的<code>ru</code>参数，它其实是个<code>rusage</code>结构,成员<a href="http://man7.org/linux/man-pages/man2/getrusage.2.html" target="_blank" rel="noopener">见此</a>。其中的<code>ru_utime</code>和<code>ru_stime</code>成员是<code>timeval</code>结构，分别记录了用户态时间和内核态时间，同样精确到微秒。</p><h1 id="程序睡着了"><a href="#程序睡着了" class="headerlink" title="程序睡着了"></a>程序睡着了</h1><p><code>RLIMIT_CPU</code>大多数情况下都能正常工作，配合<code>timeval</code>结构甚至能进一步提高精度。但是有两个例外（如果有更多请务必告诉我）：</p><ol><li>程序主动调用<code>sleep()</code></li><li>交互状态下<code>scanf()</code>一类的函数等待键盘输入</li></ol><p>在这两种情况下：进程不占用CPU时间，<code>RLIMIT_CPU</code>管不着；没有系统调用，<code>wait4()</code>不返回。为了能够在这种情况下依然能够限制时间，我想出了两种方法。一是限制和<code>sleep()</code>相关的系统调用，二是父进程设置ALARM。我在这里讲一下第二种方法。<br>Linux提供了一个<code>alarm()</code>函数，可以在指定的秒数<strong>(墙上时间)</strong>后给这个进程本身发送<code>SIGALRM</code>信号。而且，我们可以给信号绑定一个处理函数（就是当信号到达时调用的函数），在这个处理函数里，可以用<code>kill</code>命令给子进程发送信号（比如<code>SIGUSR1</code>），这样就能使父进程里的<code>wait4()</code>返回，就可以控制子进程了。以下是一个简要指导：<br>首先我们需要一个信号处理函数,记得把pid改成全局变量：</p><pre><code>void AlarmIn(int sig){    if(sig==SIGALRM)    kill(pid,SIGUSR1);}</code></pre><p>然后在子程序开始执行的时候绑定信号并设置Alarm，我在这设置超时一秒:</p><pre><code>signal(SIGALRM,AlarmIn);alarm(1);</code></pre><p>然后请根据part3所讲的内容在while循环里正确处理<code>SIGUSR1</code>。最后记得取消Alarm，如果没超时的话：</p><pre><code>alarm(0);</code></pre><h1 id="完整代码？"><a href="#完整代码？" class="headerlink" title="完整代码？"></a>完整代码？</h1><p>表示完整代码太长了，放这儿太不美观，<del>我会稍后贴到gist上去。</del>代码被幽幽子吃掉了大家自己写把。</p><h1 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h1><ul><li><a href="http://zh.wikipedia.org/wiki/%E6%95%B0%E9%87%8F%E7%BA%A7_%28%E6%97%B6%E9%97%B4%29" target="_blank" rel="noopener">Wikipedia - 数量级 (时间)</a> 我把这个链接放这儿是因为老有人把微秒缩写成<code>ms</code>然后和毫秒搞混</li><li><a href="http://blog.csdn.net/xwdok/article/details/542109" target="_blank" rel="noopener">协同式多任务与抢占式多任务</a></li><li><a href="http://www.cnblogs.com/iceocean/articles/1650929.html" target="_blank" rel="noopener">Linux时间管理</a></li><li><a href="http://russelltao.iteye.com/blog/1405353" target="_blank" rel="noopener">浅谈时间函数gettimeofday的成本</a></li></ul>]]></content>
    
    <summary type="html">
    
      Sixth part of serial of tutorial: Programming with PTRACE
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="PTRACE" scheme="https://recursiveg.me/tags/PTRACE/"/>
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Programming with PTRACE, Part5 - 内存管理</title>
    <link href="https://recursiveg.me/2014/05/programming-with-ptrace-part5/"/>
    <id>https://recursiveg.me/2014/05/programming-with-ptrace-part5/</id>
    <published>2014-05-26T02:00:32.000Z</published>
    <updated>2020-01-12T19:04:29.750Z</updated>
    
    <content type="html"><![CDATA[<p>这个part主要讲解Linux的内存管理机制，以及如何查看并限制子进程的内存使用。</p><h1 id="内存的划分"><a href="#内存的划分" class="headerlink" title="内存的划分"></a>内存的划分</h1><p>（嘛。。。这一部分也算是现学现卖的，如果大家觉得有什么讲的不到位的请翻下方的拓展阅读部分）<br>大家都知道，32位系统最大可以寻址4GB的地址空间（不考虑<a href="http://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E6%89%A9%E5%B1%95" target="_blank" rel="noopener">物理地址扩展</a>），那么这个“地址”究竟指的是哪儿的地址呢？你可以写一个小程序，malloc一点内存，然后把地址打印出来，重复几次，你会发现，分配的内存几乎都在同一个位置。这是因为，对于程序来说，这些地址都是虚拟地址，虚拟地址空间对于每个进程都是独立的，也就是说，对于不同的进程，同样虚拟地址上的数据是不同的。<br>当然，数据肯定是存放在内存条上的，我们把可以直接读写内存条的地址叫做物理地址。物理地址以一定的方式映射到虚拟地址上，所以当程序试图访问虚拟地址时，系统要以一定方式把虚拟地址变成物理地址，这项工作通常是由<a href="http://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83" target="_blank" rel="noopener">MMU(内存管理单元)</a>来完成的。内存的映射不是大块大块的，而是一小片一小片分别映射的，所以在虚拟地址上连续的地址可能在物理地址上相差十万八千里，这些一小片一小片的内存被称为“页”。<br>页的存在给内存分配带来了极大的灵活性，页可以存储在内存里，也可以存储在交换分区里，可以将同一块物理内存映射到不同进程的虚拟空间里（动态库经常这么干），甚至可以映射到磁盘上的某个文件。光说可能有点抽象，于是给幅图(来自Wikipedia)<br><img src="http://upload.wikimedia.org/wikipedia/commons/3/32/Virtual_address_space_and_physical_address_space_relationship.svg" alt="内存页映射是不连续的"><br>虚拟地址被分成多个段，数据有序存放于其中。这是32位Linux的新内存布局(Linux 2.6.7之后):<br><img src="http://static.duartes.org/img/blogPosts/linuxFlexibleAddressSpaceLayout.png" alt="Linux新内存布局"><br>如果你研究过可执行文件的结构，你就会发现，虚拟地址的段就是按可执行文件的段来填充的。另外，由于代码段的起点地址是固定的(0x08048000)，所以编译器就可以预先算出函数的地址了。顺带一提，因为动态库加载时的虚拟地址是不固定的，不能预先计算出函数地址，所以要在编译时使用<code>-fPIC</code>选项生成位置无关代码，否则每次被一个新进程使用时都要进行重定位(可以理解为重新计算函数地址)，并生成该动态库的一个副本，这样压根没有起到节约内存的作用。<br>扯远了，回来。尽管每个进程的虚拟地址空间时互相独立的，但并不意味着进程想访问哪儿就能访问的，比如3GB以上的区域，那儿是内核的领地。即使是堆段，也只能访问已申请的内存部分，非法的内存访问将会引发段错误(Segmentation Fault)。回到<code>malloc()</code>函数上，malloc最终会调用<code>brk</code>或<code>mmap</code>系统调用，brk用于在堆中分配小块内存，mmap则用于在Memory Mapping Segment中分配大块内存。但是并不是每次malloc都会调用brk，这是因为分配的内存实在是太小了，而brk只能分配大一点的内存，所以C运行库(比如glibc)在收到一个malloc时会先用brk向系统“批发”一块大一点的内存，而收到后续分配请求时则把这块大内存“零售”给程序，直到售完再次brk。<br>如果有一个程序死循环单纯malloc内存，内存会不会被吃光呢？答案是不会(我不清楚是不是真的有如此单纯的系统真的会挂掉)，因为系统发现，你只是分配了内存，却没有使用，于是它很机智地将那片内存设置为“可访问”，却没有把它映射到任何一个实际的内存页上！</p><a id="more"></a><h1 id="你用了多少内存？"><a href="#你用了多少内存？" class="headerlink" title="你用了多少内存？"></a>你用了多少内存？</h1><p>还记得之前的<code>rusage</code>结构么？其成员可在<a href="http://man7.org/linux/man-pages/man2/getrusage.2.html" target="_blank" rel="noopener">这里</a>找到。事实上，这是一种非常简陋的内存使用信息获取方式，我们只关心其中的<code>ru_maxrss</code>一项，RSS即”Resident Set Size”，表示该进程在物理内存中的占用大小，不包括交换分区中的内存大小，也不包含分配了却未使用而没有物理内存页的内存。为了获得更详细的内存信息，我们需要访问<code>/proc</code>目录。该目录下各文件的用途在<code>man 5 proc</code>里描述得很清楚，<a href="http://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="noopener">这里</a>是网页版本。关于这个目录的作用，我就偷懒，将man手册中的描述翻译如下：</p><blockquote><p><code>proc</code>文件系统是一个伪文件系统，提供了访问内核数据结构的接口。它通常被挂载在<code>/proc</code>上并且大部分是只读的，除了少数文件被允许用来改变内核参数。</p></blockquote><p><code>/proc</code>下有N多文件夹，大部分是按进程的pid来命名的，我们关心的是这些文件夹中的<code>status</code>文件。来看一个例子：<code>cat /proc/1/status|grep Vm</code></p><pre><code>VmPeak:      173616 kBVmSize:      107968 kBVmLck:           0 kBVmPin:           0 kBVmHWM:        3816 kBVmRSS:        3744 kBVmData:       83744 kBVmStk:         136 kBVmExe:        1140 kBVmLib:        2268 kBVmPTE:          72 kBVmSwap:           0 kB</code></pre><p>我们看到了两个令人感兴趣的东西：<code>VmData</code>和<code>VmStk</code>。分别代表了数据区和栈的大小，而且这两个数据是真正的可访问的虚拟内存大小，即不会像RSS那样，漏掉那些分配了而未访问的内存。当然，其他数据也都是很有趣的，有兴趣的人可以自己去翻man手册。这段代码计算给定进程的数据段和堆栈段内存使用总和。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getMemory</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pid_t</span> pid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> stat_loc[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">long</span> VmData,VmStk;</span><br><span class="line">    <span class="built_in">sprintf</span>(stat_loc,<span class="string">"/proc/%d/status"</span>,pid);</span><br><span class="line">    FILE *stat=fopen(stat_loc,<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">line</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">while</span>(EOF!=<span class="built_in">fscanf</span>(stat,<span class="string">"%[^\n]"</span>,<span class="built_in">line</span>))&#123;</span><br><span class="line">        <span class="built_in">sscanf</span>(<span class="built_in">line</span>,<span class="string">"VmData: %ld"</span>,&amp;VmData);</span><br><span class="line">        <span class="built_in">sscanf</span>(<span class="built_in">line</span>,<span class="string">"VmStk: %ld"</span>,&amp;VmStk);</span><br><span class="line">        fgetc(stat);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> VmData+VmStk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="限制内存"><a href="#限制内存" class="headerlink" title="限制内存"></a>限制内存</h1><p>也许你们已经知道，有一个叫做<code>setrlimit</code>的函数可以用来限制资源使用，你们也许已经翻过了它的man手册，看到了<code>RLIMIT_AS</code> <code>RLIMIT_DATA</code> <code>RLIMIT_RSS</code>等一票似乎很有用的参数。现在，请你立刻忘掉他们！既然我们之前讲了<code>/proc</code>当然要用起来啦。我们不用<code>setrlimit</code>是因为，这种限制策略会导致malloc失败（确切的讲是brk和mmap失败），而大部分OIer都没有检查malloc返回值的的习惯，最终导致本应是MLE(Memory Limit Exceeded)的情况变成了由访问无效内存导致的RE(Runtime Error)。更糟糕的是，如果是系统栈增长被限制了，进程会被直接<code>SIGSEGV</code>，连errno都没有，这种情况下就更难分辨了。那么，有什么好的方法来限制内存呢？答案就是在每次分配内存的系统调用（不限于brk和mmap）时通过proc来检查内存使用，注意要在返回时检查哦。一旦超过，就由父进程直接杀死子进程，方法多种多样，你可以使用<code>ptrace(PTRACE_KILL,pid,0,0)</code>，或是用Part3所讲的方法发送信号，或是直接用<a href="http://man7.org/linux/man-pages/man2/kill.2.html" target="_blank" rel="noopener">kill函数</a>。这种方法看上去很不优雅，但确实很有效。至于那些对<code>setrlimit</code>耿耿于怀的同学，不要担心，下个part时间限制，将会大量用到。</p><h1 id="拓展阅读-amp-参考资料"><a href="#拓展阅读-amp-参考资料" class="headerlink" title="拓展阅读&amp;参考资料"></a>拓展阅读&amp;参考资料</h1><ul><li><a href="http://xixinfei.iteye.com/blog/1949123" target="_blank" rel="noopener">Linux内存管理详解</a></li><li><a href="http://www.itvane.net/?p=1240" target="_blank" rel="noopener">Linux进程地址空间详解</a></li><li><a href="http://www.cnblogs.com/clover-toeic/p/3754433.html" target="_blank" rel="noopener">Linux虚拟地址空间布局</a></li><li><a href="http://acm.tongji.edu.cn/cnfaqs" target="_blank" rel="noopener">OJ系统各状态含义</a>(见Question #6；应该还有一个RF:Restricted Function)</li><li><a href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/" target="_blank" rel="noopener">Anatomy of a Program in Memory</a></li><li>man手册</li></ul>]]></content>
    
    <summary type="html">
    
      Fifth part of serial of tutorial: Programming with PTRACE
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="PTRACE" scheme="https://recursiveg.me/tags/PTRACE/"/>
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Programming with PTRACE, Part4 - 系统调用进阶</title>
    <link href="https://recursiveg.me/2014/05/programming-with-ptrace-part4/"/>
    <id>https://recursiveg.me/2014/05/programming-with-ptrace-part4/</id>
    <published>2014-05-26T02:00:31.000Z</published>
    <updated>2020-01-12T19:04:29.316Z</updated>
    
    <content type="html"><![CDATA[<p>这个part是<a href="/2014/04/programming-with-ptrace-part2/">Part2</a>的延续，所以我强烈建议你弄明白Part2中的内容后再来看本part。那么进入正题，我将在这个部分讲解系统调用的参数传递顺序以及如何利用ptrace系统调用获得用户空间的数据。</p><h2 id="参数与寄存器"><a href="#参数与寄存器" class="headerlink" title="参数与寄存器"></a>参数与寄存器</h2><p>我在Part2中提到过，系统调用的参数是以一定顺序保存在寄存器里的，那么这个顺序是什么呢？在<code>man 2 syscall</code>中有两张表格解释了这个问题，你也可以在<a href="http://man7.org/linux/man-pages/man2/syscall.2.html" target="_blank" rel="noopener">这里</a>看到，就在”Architecture calling conventions”下面。我知道很多人很懒，所以我就把这两张表格复制过来了。</p><center><table><thead><tr><th align="left">arch/ABI</th><th align="left">instruction</th><th align="left">syscall #</th><th align="left">retval</th><th align="left">Notes</th></tr></thead><tbody><tr><td align="left">arm/OABI</td><td align="left">swi NR</td><td align="left">-</td><td align="left">a1</td><td align="left">NR is syscall #</td></tr><tr><td align="left">arm/EABI</td><td align="left">swi 0x0</td><td align="left">r7</td><td align="left">r0</td><td align="left"></td></tr><tr><td align="left">blackfin</td><td align="left">excpt 0x0</td><td align="left">P0</td><td align="left">R0</td><td align="left"></td></tr><tr><td align="left">i386</td><td align="left">int $0x80</td><td align="left">eax</td><td align="left">eax</td><td align="left"></td></tr><tr><td align="left">ia64</td><td align="left">break 0x100000</td><td align="left">r15</td><td align="left">r10/r8</td><td align="left">bool error/errno value</td></tr><tr><td align="left">parisc</td><td align="left">ble 0x100(%sr2, %r0)</td><td align="left">r20</td><td align="left">r28</td><td align="left"></td></tr><tr><td align="left">s390</td><td align="left">svc 0</td><td align="left">r1</td><td align="left">r2</td><td align="left">See below</td></tr><tr><td align="left">s390x</td><td align="left">svc 0</td><td align="left">r1</td><td align="left">r2</td><td align="left">See below</td></tr><tr><td align="left">sparc/32</td><td align="left">t 0x10</td><td align="left">g1</td><td align="left">o0</td><td align="left"></td></tr><tr><td align="left">sparc/64</td><td align="left">t 0x6d</td><td align="left">g1</td><td align="left">o0</td><td align="left"></td></tr><tr><td align="left">x86_64</td><td align="left">syscall</td><td align="left">rax</td><td align="left">rax</td><td align="left"></td></tr></tbody></table><table><thead><tr><th align="left">arch/ABI</th><th align="left">arg1</th><th align="left">arg2</th><th align="left">arg3</th><th align="left">arg4</th><th align="left">arg5</th><th align="left">arg6</th><th align="left">arg7</th></tr></thead><tbody><tr><td align="left">arm/OABI</td><td align="left">a1</td><td align="left">a2</td><td align="left">a3</td><td align="left">a4</td><td align="left">v1</td><td align="left">v2</td><td align="left">v3</td></tr><tr><td align="left">arm/EABI</td><td align="left">r0</td><td align="left">r1</td><td align="left">r2</td><td align="left">r3</td><td align="left">r4</td><td align="left">r5</td><td align="left">r6</td></tr><tr><td align="left">blackfin</td><td align="left">R0</td><td align="left">R1</td><td align="left">R2</td><td align="left">R3</td><td align="left">R4</td><td align="left">R5</td><td align="left">-</td></tr><tr><td align="left">i386</td><td align="left">ebx</td><td align="left">ecx</td><td align="left">edx</td><td align="left">esi</td><td align="left">edi</td><td align="left">ebp</td><td align="left">-</td></tr><tr><td align="left">ia64</td><td align="left">out0</td><td align="left">out1</td><td align="left">out2</td><td align="left">out3</td><td align="left">out4</td><td align="left">out5</td><td align="left">-</td></tr><tr><td align="left">parisc</td><td align="left">r26</td><td align="left">r25</td><td align="left">r24</td><td align="left">r23</td><td align="left">r22</td><td align="left">r21</td><td align="left">-</td></tr><tr><td align="left">s390</td><td align="left">r2</td><td align="left">r3</td><td align="left">r4</td><td align="left">r5</td><td align="left">r6</td><td align="left">r7</td><td align="left">-</td></tr><tr><td align="left">s390x</td><td align="left">r2</td><td align="left">r3</td><td align="left">r4</td><td align="left">r5</td><td align="left">r6</td><td align="left">r7</td><td align="left">-</td></tr><tr><td align="left">sparc/32</td><td align="left">o0</td><td align="left">o1</td><td align="left">o2</td><td align="left">o3</td><td align="left">o4</td><td align="left">o5</td><td align="left">-</td></tr><tr><td align="left">sparc/64</td><td align="left">o0</td><td align="left">o1</td><td align="left">o2</td><td align="left">o3</td><td align="left">o4</td><td align="left">o5</td><td align="left">-</td></tr><tr><td align="left">x86_64</td><td align="left">rdi</td><td align="left">rsi</td><td align="left">rdx</td><td align="left">r10</td><td align="left">r8</td><td align="left">r9</td><td align="left">-</td></tr></tbody></table></center><a id="more"></a>表格内容虽多，但其实我们关心的只有i386和x86_64（32位和64位）一共4行（因为有两张表格嘛）。精简提炼下，一共就两句话<blockquote><p>对于32位系统，系统调用号存放在EAX寄存器，参数依次放入EBX、ECX、EDX、ESI … 返回值位于EAX寄存器<br>  对于64位系统，系统调用号存放在RAX寄存器，参数依次放入RDI、RSI、RDX、R10 … 返回值位于RAX寄存器</p></blockquote><p>以64位系统下的<code>write()</code>调用为例:</p><pre><code>ssize_t write(int fd, const void *buf, size_t count);</code></pre><p>那么RAX是1(write的调用号)，RDI一般为1(stdout),RSI存储着指向用户空间中将要被输出的字符串的地址，RDX自然就是字符串长度啦。</p><h2 id="获取那个字符串"><a href="#获取那个字符串" class="headerlink" title="获取那个字符串"></a>获取那个字符串</h2><p>理论讲完了，进入实战。这次我们拿<code>open()</code>系统调用开刀，一是因为监视程序打开了什么文件比得知输出了什么更常用，二是因为传递给<code>open()</code>的字符串没有长度信息，只能自己通过<code>\0</code>判断，更有挑战性。我们这次要使用ptrace的一个新功能<code>PTRACE_PEEKTEXT</code>,其实还有另外一个叫做<code>PTRACE_PEEKDATA</code>的，不过根据man手册的描述，这两个的功能是一样的。它的用法是这样的</p><pre><code>data = ptrace(PTRACE_PEEKTEXT,pid,addr,0);</code></pre><p>即从子进程（由pid标识）的addr内存地址处取出对应字长(64位为8字节，32位4字节)的数据，做为返回值。也就是说，读取一次能得到八个字符。现在如果我们要取得从<code>base_addr</code>地址开始的一个字符串，那么我们只要8个字节8个字节读取，直到碰到<code>\0</code>为止。把这个功能写成函数就是这样：（32位系统不要忘记改那个define）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WORD_LEN 8</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">peek_str</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">long</span> base_addr,<span class="keyword">char</span> target[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">union</span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">word</span>;</span><br><span class="line">    <span class="keyword">char</span> str[WORD_LEN];</span><br><span class="line">  &#125; data;<span class="comment">/*利用union把WORD_LEN字节的整数变为字符数组*/</span></span><br><span class="line">  <span class="keyword">long</span> offset=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> done=<span class="number">0</span>,i;</span><br><span class="line">  target[<span class="number">0</span>]=<span class="string">'\0'</span>;</span><br><span class="line">  <span class="keyword">while</span>(!done)&#123;<span class="comment">/*循环读取*/</span></span><br><span class="line">    data.<span class="keyword">word</span>=ptrace(PTRACE_PEEKTEXT,pid,base_addr+offset,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">strncat</span>(target,data.str,WORD_LEN);<span class="comment">/*追加至多WORD_LEN个字符*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;WORD_LEN;i++)<span class="comment">/*检查是否有'\0'*/</span></span><br><span class="line">      <span class="keyword">if</span>(data.str[i]==<span class="string">'\0'</span>)</span><br><span class="line">        done=<span class="number">1</span>;</span><br><span class="line">    offset+=WORD_LEN;<span class="comment">/*准备读取下一个WORD_LEN字节*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主程序的大<code>while()</code>循环里的代码是这样的（我已经设置了<code>PTRACE_O_TRACESYSGOOD</code>标记）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">wait4(pid,&amp;sta,<span class="number">0</span>,&amp;ru);</span><br><span class="line"><span class="keyword">if</span>(WIFEXITED(sta))&#123;<span class="built_in">printf</span>(<span class="string">"Exited with code %d"</span>,WEXITSTATUS(sta));<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(WIFSIGNALED(sta))&#123;<span class="built_in">printf</span>(<span class="string">"Terminated by signal: %s"</span>,strsignal(WTERMSIG(sta)));<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">int</span> sig_no;<span class="keyword">if</span>(WIFSTOPPED(sta))sig_no=WSTOPSIG(sta);<span class="keyword">else</span>&#123;<span class="built_in">puts</span>(<span class="string">"Unknown Status"</span>);<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(sig_no!=(SIGTRAP|<span class="number">0x80</span>))&#123;ptrace(PTRACE_SYSCALL,pid,<span class="number">0</span>,sig_no);<span class="keyword">continue</span>;&#125;</span><br><span class="line"><span class="keyword">if</span> (intocall)&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> <span class="title">reg</span>;</span></span><br><span class="line">  ptrace(PTRACE_GETREGS,pid,<span class="number">0</span>,&amp;reg);</span><br><span class="line">  <span class="keyword">if</span> (reg.orig_rax==SYS_open)&#123;</span><br><span class="line">    <span class="keyword">char</span> file[<span class="number">255</span>];</span><br><span class="line">    peek_str(pid,reg.rdi,file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"open() opened: %s\n"</span>,file);</span><br><span class="line">  &#125;      </span><br><span class="line">&#125;</span><br><span class="line">intocall^=<span class="number">1</span>;</span><br><span class="line">ptrace(PTRACE_SYSCALL,pid,<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在这里我使用的<code>PTRACE_GETREGS</code>和<code>user_regs_struct</code>结构来一次性获得所有寄存器的值，该结构定义于<code>sys/user.h</code>头文件中。另外，我还使用了<code>SYS_open</code>来判断系统调用号，避免了Magic Number。<code>SYS_*</code>宏定义于<code>sys/syscall.h</code>头文件中。传递RDI寄存器也很容易理解，查询<code>man 2 open</code>可知open系统调用的路径是第一个参数。现在，重新编译你的<code>target</code>，不要加<code>-static</code>,然后运行，你应该能看到类似这样的输出。</p><pre><code>Parent startedChild PiD == 4717Child exec...Child execve() returned with 0open() opened: /usr/lib/tls/x86_64/libc.so.6open() opened: /usr/lib/tls/libc.so.6open() opened: /usr/lib/x86_64/libc.so.6open() opened: /usr/lib/libc.so.6Hello World!Exited with code 0</code></pre><p>可以很明显的看到程序搜索动态链接库的过程。<br>如果你觉得这还不够过瘾，那么你可以看<a href="http://www.kgdb.info/gdb/playing_with_ptrace_part_i/" target="_blank" rel="noopener">Playing with ptrace, part1</a>,后面提供了一个配合使用<code>PTRACE_PEEKTEXT</code>和<code>PTRACE_POKETEXT</code>来将<code>write</code>输出的字符串反转的例子</p><h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><ul><li><a href="http://godorz.info/2011/02/how-debuggers-work-part-1" target="_blank" rel="noopener">调试器是怎样工作的</a></li><li><a href="http://linuxgazette.net/issue81/sandeep.html" target="_blank" rel="noopener">Process Tracing Using Ptrace</a></li></ul><h2 id="不是后记的后记"><a href="#不是后记的后记" class="headerlink" title="不是后记的后记"></a>不是后记的后记</h2><p>不知不觉已经写到Part4了，期间一边查资料一边写代码做验证一边写这篇文章，又发现了好多好多之前遗漏的信息和好文章。同时深深感觉自己真是个蒟蒻，好多东西觉得很重要，想讲却心有余而力不足，而且越来越像是在翻译man手册了……我是不是一开始就应该去翻译手册而不是写这系列文章呢？（笑）<br>下个part开始，估计就要暂时和ptrce说再见，然后和内存管理开始较劲了。</p>]]></content>
    
    <summary type="html">
    
      Fourth part of serial of tutorial: Programming with PTRACE
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="PTRACE" scheme="https://recursiveg.me/tags/PTRACE/"/>
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Programming with PTRACE, Part3 - 进程的终止与信号</title>
    <link href="https://recursiveg.me/2014/05/programming-with-ptrace-part3/"/>
    <id>https://recursiveg.me/2014/05/programming-with-ptrace-part3/</id>
    <published>2014-05-25T10:26:20.000Z</published>
    <updated>2020-01-12T19:04:28.883Z</updated>
    
    <content type="html"><![CDATA[<p>在Part2中，我们粗略了解了如何使用<code>ptrace</code>获得系统调用信息，即在一个大循环里不断获取程序信息，如果程序退出则停止循环。当然，那个判断异常简陋，几乎无法处理任何特殊情况。我将在本Part中详细解说各种异常情况的处理，同时讲解各种信号相关的问题。</p><h2 id="一些重要的宏"><a href="#一些重要的宏" class="headerlink" title="一些重要的宏"></a>一些重要的宏</h2><p>在使用<code>wait4</code>后，程序的信息被存储在<code>sta</code>变量中，这些信息被存储在这个整数的不同二进制位上，这儿有一系列宏用于帮我们提取这些信息。以下信息是我对<code>man 3 wait</code>中相关部分的翻译,同时参考了<a href="http://www.manualpages.de/OpenBSD/OpenBSD-5.0/man2/WIFEXITED.2.html" target="_blank" rel="noopener">这个</a>页面</p><pre><code>WIFEXITED   如果进程正常退出，返回一个非0值(通常是进程调用了`exit()`或是`_exit()`)WIFSIGNALED 如果进程由于一个未被捕获的信号而被终止，返回一个非0值WIFSTOPPED  当进程被停止(非终止)时，返回一个非0值(通常发生在当进程处于`traced`状态时)WEXITSTATUS 当`WIFEXITED`为非0值，获得进程`main()`函数的返回值WTERMSIG    如果`WIFSIGNALED`为非0值，获得引起进程终止的信号代码WSTOPSIG    如果`WIFSTOPPED`为非0值，获得引起进程停止的信号代码</code></pre><p>除了这六个，还有<code>WIFCONTINUED</code>和<code>WCOREDUMP</code>两个宏，不过我们用不到，我也没仔细研究，就不说了。<br>当进程自行终止时，<code>WIFEXITED</code>即为<code>true</code>，配套使用<code>WEXITSTATUS</code>获得返回值，不做过多解释。当子进程进行系统调用时，<code>WIFSTOPPED</code>为<code>true</code>,同时<code>WSTOPSIG</code>等于<code>SIGTRAP</code>(信号代码为7),我们可以用这种方法区分<code>syscall-stop</code>和<code>signal-delivery-stop</code>。当有一个外部信号要发送给子进程，这个信号会先到达父进程，使<code>WIFSTOPPED</code>为<code>true</code>，同时<code>WSTOPSIG</code>等于该信号的信号代码。父进程可以选择将这个信号继续传递或是不传递，甚至传递另一个信号给子进程。一旦信号真正到达子进程，就进入子进程自己的处理流程或是系统默认动作，可能触发<code>WIFSIGNALED</code>，比如<code>SIGINT</code>。<br>在所有信号中，<code>SIGKILL</code>是一个例外，它不会经过父进程引发<code>WIFSTOPPED</code>，而是直接传递到子进程，引发<code>WIFSIGNALED</code>。</p><a id="more"></a><h2 id="信号的传递与修改"><a href="#信号的传递与修改" class="headerlink" title="信号的传递与修改"></a>信号的传递与修改</h2><p>之前提到，父进程需要将信号传递给子进程，这是由<code>ptrace(PTRACE_SYSCALL,pid,0,0)</code>的第四个参数决定的。如果为0,就不传递信号，否则传递对应代码的信号，比如<code>ptrace(PTRACE_SYSCALL,pid,0,9)</code>就将信号9(SIGKILL)传递给了子进程。<br>修改信号简直信手拈来，传一个你想要传的信号即可。</p><h2 id="strsignal-和代码"><a href="#strsignal-和代码" class="headerlink" title="strsignal()和代码"></a>strsignal()和代码</h2><p><code>strsignal()</code>接受一个整数参数，返回<code>const char*</code>，用于把信号代码变为对应的、人类可读的字符串描述，定义于<code>string.h</code>。下面给出判断程序退出的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wait4(pid,&amp;sta,<span class="number">0</span>,&amp;ru);</span><br><span class="line"><span class="keyword">if</span>(WIFEXITED(sta))&#123;<span class="built_in">printf</span>(<span class="string">"Exited with code %d"</span>,WEXITSTATUS(sta));<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(WIFSIGNALED(sta))&#123;<span class="built_in">printf</span>(<span class="string">"Terminated by signal: %s"</span>,strsignal(WTERMSIG(sta)));<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">int</span> sig_no;</span><br><span class="line"><span class="keyword">if</span>(WIFSTOPPED(sta))sig_no=WSTOPSIG(sta);</span><br><span class="line"><span class="keyword">if</span>(sig_no==SIGTRAP)sig_no=<span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line">ptrace(PTRACE_SYSCALL,pid,<span class="number">0</span>,sig_no);</span><br></pre></td></tr></table></figure><h2 id="来自ptrace的高级选项"><a href="#来自ptrace的高级选项" class="headerlink" title="来自ptrace的高级选项"></a>来自ptrace的高级选项</h2><p>你也许会纠结，如果外部传递了一个<code>SIGTRAP</code>信号，那么如何分辨呢？答案是使用<code>PTRACE_SETOPTIONS</code>设置<code>PTRACE_O_TRACESYSGOOD</code>标记，即在while之前，第一个wait之后，第一个<code>PTRACE_SYSCALL</code>之前，使用<code>ptrace(PTRACE_SETOPTIONS,pid,0,PTRACE_O_TRACESYSGOOD)</code>。这会使得<code>syscall-stop</code>导致的<code>WSTOPSIG</code>从<code>SIGTRAP</code>变为<code>SIGTRAP|0x80</code>，而普通的来自外部的<code>SIGTRAP</code>依然是<code>SIGTRAP</code>。</p>]]></content>
    
    <summary type="html">
    
      Third part of serial of tutorial: Programming with PTRACE
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="PTRACE" scheme="https://recursiveg.me/tags/PTRACE/"/>
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Programming with PTRACE, Part2 - 系统调用入门</title>
    <link href="https://recursiveg.me/2014/04/programming-with-ptrace-part2/"/>
    <id>https://recursiveg.me/2014/04/programming-with-ptrace-part2/</id>
    <published>2014-04-20T12:00:19.000Z</published>
    <updated>2020-01-12T19:04:28.450Z</updated>
    
    <content type="html"><![CDATA[<p>在这部分，我会介绍如何使用ptrace监控子进程的系统调用。我先将完整代码列在开头，你现在十有八九看不懂它，但我希望你在看完这篇文章后能彻底理解这段代码。（这段代码在64位系统上有效，32位系统请参照最后<code>给32位系统的Tip</code>手动修改源代码）</p><figure class="highlight c"><figcaption><span>demo4.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/reg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Parent started"</span>);</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  pid=fork();</span><br><span class="line">  <span class="keyword">if</span> (pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"fork() failed"</span>);</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pid==<span class="number">0</span>)&#123;</span><br><span class="line">    ptrace(PTRACE_TRACEME,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Child sleeping..."</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Child exec..."</span>);</span><br><span class="line">    execlp(<span class="string">"./target"</span>,<span class="string">"target"</span>,<span class="literal">NULL</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Child PiD == %d\n"</span>,pid);</span><br><span class="line">    <span class="keyword">int</span> sta=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rusage</span> <span class="title">ru</span>;</span></span><br><span class="line">    wait4(pid,&amp;sta,<span class="number">0</span>,&amp;ru);</span><br><span class="line">    <span class="keyword">long</span> rax_rt=ptrace(PTRACE_PEEKUSER,pid,<span class="number">8</span>*RAX,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Child execve() returned with %ld\n"</span>,rax_rt);</span><br><span class="line">    ptrace(PTRACE_SYSCALL,pid,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> intocall=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      wait4(pid,&amp;sta,<span class="number">0</span>,&amp;ru);</span><br><span class="line">      <span class="keyword">if</span> (WIFEXITED(sta))&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Child Exited"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">long</span> _ORIG_RAX=ptrace(PTRACE_PEEKUSER,pid,<span class="number">8</span>*ORIG_RAX,<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">long</span> _RAX=ptrace(PTRACE_PEEKUSER,pid,<span class="number">8</span>*RAX,<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (intocall)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Entering SYSCALL %ld .... "</span>,_ORIG_RAX);</span><br><span class="line">        intocall=<span class="number">0</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Exited with %ld\n"</span>,_RAX);</span><br><span class="line">        intocall=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ptrace(PTRACE_SYSCALL,pid,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="运行我们的程序"><a href="#运行我们的程序" class="headerlink" title="运行我们的程序"></a>运行我们的程序</h2><p>当然，如果你试图直接编译并运行上面这段程序肯定是失败的，因为你缺少一个用于被执行的“target”（就是execlp里的那个）。在这里，我们的第一个target是最经典的“Hello World!”程序：</p><figure class="highlight c"><figcaption><span>target.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Hello World!"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我建议你静态方式进行链接：</p><pre><code>gcc -static target.c -o target</code></pre><p>注意到我这里使用了<code>-static</code>参数，它的作用是将c运行时库静态链接入可执行文件中。你可以比较一下用两种方式编译的文件大小（几K和几百K的区别）。虽然用动态链接也可以，但是会和我之后的输出有一点点出入（因为动态链接文件需要根据环境变量搜索动态库）。现在把<code>target</code>和<code>demo4.c</code>放在同一目录下，然后</p><pre><code>gcc demo4.c -o demo4 &amp;&amp; ./demo4</code></pre><p>如果运行正确，你应该看到类似如下的输出</p><pre><code>Parent startedChild PiD == 9702Child sleeping...Child exec...Child execve() returned with 0Entering SYSCALL 63 .... Exited with 0Entering SYSCALL 12 .... Exited with 31248384Entering SYSCALL 12 .... Exited with 31252928Entering SYSCALL 158 .... Exited with 0Entering SYSCALL 89 .... Exited with 55Entering SYSCALL 12 .... Exited with 31388096Entering SYSCALL 12 .... Exited with 31391744Entering SYSCALL 5 .... Exited with 0Entering SYSCALL 9 .... Exited with 140378408579072Hello World!Entering SYSCALL 1 .... Exited with 13Entering SYSCALL 231 .... Child Exited</code></pre><h2 id="深入这段代码"><a href="#深入这段代码" class="headerlink" title="深入这段代码"></a>深入这段代码</h2><p>我先介绍一下各个头文件的用途：</p><ul><li><code>stdio.h</code>：（如果你不知道这个文件是干嘛的请重学C语言）</li><li><code>unistd.h</code>：提供<code>fork()</code>、<code>pid_t</code>、<code>execlp()</code>、<code>sleep()</code>等</li><li><code>sys/ptrace.h</code>：提供ptrace相关函数和宏定义</li><li><code>sys/wait.h</code>：提供<code>wait4()</code>和<code>WIFEXITED</code>宏</li><li><code>sys/resource.h</code>：提供<code>rusage</code>结构定义</li><li><code>sys/reg.h</code>：提供寄存器系列宏定义（<code>ORIG_RAX</code>等）</li></ul><p>看到代码的第15行，一个巨大的<code>if...else...</code>将代码清晰地分成了父子进程两个部分，16行的<code>ptrace(PTRACE_TRACEME,0,0,0);</code>首先吸引了我们的注意力。（为什么有一种在写春游作文的感觉）这个调用使得子进程被标记为<code>TRACED</code>并且使系统内核在子进程调用exec族函数<em>之后</em>通知父进程，这也是为什么17到19行的系统调用没有被追踪到的原因。<br>再看父进程部分，由于系统调用是一个从用户态到内核态再到用户态的过程，所以每进行一次系统调用都会触发两次<code>syscall_stop</code>,分别是进入时的<code>syscall_enter_stop</code>和离开内核时的<code>syscall_exit_stop</code>。这种子进程的状态的变化可以在父进程中使用<code>wait()</code>、<code>waitpid()</code>、<code>wait4()</code>等一票函数完成（还记得part1课后阅读中的僵尸进程么？）。值得注意的是，第一次的状态变化是由<code>execve()</code>调用返回导致的<code>syscall_exit_stop</code>，所以我在25到29行单独做了处理。我喜欢使用<code>wait4()</code>的原因是它还可以获得子进程的当前资源占用情况（就是那个<code>rusage</code>结构），这对于了解进程资源使用情况非常有用，只不过现在还用不到（我应该会在之后专门开几个part来讲系统资源的限制），所以我们只要关注那个<code>sta</code>就可以了。<br>注意下面那个大的<code>while</code>循环，在每次循环的开头等待，一旦<code>wait4()</code>返回，子进程就已经进入了暂停的状态（其实是内核给子进程发送了<code>SIGTRAP</code>信号，但因为子进程处于<code>TRACED</code>状态，所以这个信号被转交给了父进程，使父进程的<code>wait4()</code>返回，但这也意味着由其他方式引起的信号(比如<code>kill</code>命令)也会引起wait4的返回）。接着在32行使用<code>WIFEXITED</code>宏加上wait4收集的状态信息<code>sta</code>判断子进程是否已经退出，如果已退出，那么父进程也从循环中退出。当然这是一个非常粗糙的处理方式，更具完整的处理流程将在之后的part里介绍。接着，我们就可以使用各种各样的命令来调戏子进程了，这里我们只是简单的取得系统调用号和返回值。最后，在45行，让子进程继续执行，并要求子进程在下一个系统调用（进入或返回）停住，然后父进程开始等待下一次的<code>syscall_stop</code>。因为一次系统调用会导致两次<code>syscall_stop</code>，所以我使用变量<code>intocall</code>来分辨，并且在38到44行打印出不同的提示信息。顺带提一下，在输出中，<code>Hello World!</code>应该输出在<code>Entering SYSCALL 1</code>和<code>Exited with 13</code>中间，但因为缓冲区刷新的问题所以被输出到了前面。</p><p>终于到最激动人心的部分了！36、37两行代码是最重要的部分，可以看出，他们做的工作是差不多的，都是从子进程的内存空间中取一些数据。为了解释好这两行，我要讲一讲系统调用的调用过程。系统调用和普通的函数调用差不多，函数调用是将参数以约定好的顺序压入栈中，而系统调用则发生了一个类似上下文切换的过程：程序将需要调用的系统调用的调用号以及参数存入寄存器中，然后将所有寄存器存入栈中，进入内核态后，内核从栈中取得调用号和调用参数，并将返回值写入栈中对应寄存器的位置，最后还原寄存器的值并返回用户态，于是返回值就这样被“还原”到了寄存器里。在x86-64平台上，负责传递系统调用号和返回值的都是<code>RAX</code>寄存器，也就是说返回值会覆盖调用号，为了在系统调用返回时也能知道调用号，<code>RAX</code>寄存器在保存时被入栈两遍，一个是用于保存返回值的<code>RAX</code>，另一个是负责保存调用号的<code>ORIG_RAX</code>。现在，我们要获得寄存器的值，只要访问栈中的对应位置就可以了。而系统内核又会在系统调用时将栈中的这些信息复制一遍到一个叫做<code>u-area</code>(USER Area)的内存区域。在<code>sys/reg.h</code>头文件中定义了各寄存器保存时在<code>u-area</code>中的顺序，乘以每个寄存器的长度（64位系统自然就是8了嘛~~）就得到了我们所要访问的字节偏移量，<code>PTRACE_PEEKUSER</code>要求ptrace从指定偏移取出一个寄存器长度的数据（也就是8字节）作为返回值，于是<code>ptrace(PTRACE_PEEKUSER,pid,8*ORIG_RAX,0)</code>就能获得系统调用号啦！</p><h2 id="给32位系统的Tip"><a href="#给32位系统的Tip" class="headerlink" title="给32位系统的Tip"></a>给32位系统的Tip</h2><p>要让程序通过编译，需要做两个改动：</p><ol><li><p>在<code>int main()</code>之前加入这两个预处理命令：</p><pre><code>#define RAX EAX#define ORIG_RAX ORIG_EAX</code></pre></li><li><p>把26、36、37行ptrace第三个参数中的8全部改成4</p></li></ol><p>这是因为32位系统的寄存器长度是4字节，而且负责传递系统调用号和返回值的是<code>EAX</code>寄存器。</p><h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><ul><li><a href="http://sourceforge.net/projects/strace/" target="_blank" rel="noopener">strace</a>是一个用于监视并输出某程序系统调用情况的工具，比如<code>strace ./target</code></li><li><a href="http://man7.org/linux/man-pages/man7/signal.7.html" target="_blank" rel="noopener">Linux信号代码</a>：也可以通过查man手册得到<code>man 7 signal</code></li><li><a href="http://www.kgdb.info/gdb/playing_with_ptrace_part_i/" target="_blank" rel="noopener">Playing with ptrace</a>：Pradeep Padala 的关于ptrace的文章。</li><li><a href="http://blog.rchapman.org/post/36801038863/linux-system-call-table-for-x86-64" target="_blank" rel="noopener">x86_64 系统调用号列表</a>：也可以在<code>asm/unistd_64.h</code>头文件中找到，<code>asm/unistd_32.h</code>就是32位的</li><li><a href="http://www.hep.wisc.edu/~pinghc/Process_Memory.htm" target="_blank" rel="noopener">Process and Process Memory</a></li><li><strong>有问题或意见请务必留言啊啊啊啊~</strong>没人留言都不知道评论系统是否工作正常</li></ul>]]></content>
    
    <summary type="html">
    
      Second part of serial of tutorial: Programming with PTRACE
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="PTRACE" scheme="https://recursiveg.me/tags/PTRACE/"/>
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Programming with PTRACE, Part1 - 起步</title>
    <link href="https://recursiveg.me/2014/04/programming-with-ptrace-part1/"/>
    <id>https://recursiveg.me/2014/04/programming-with-ptrace-part1/</id>
    <published>2014-04-17T13:16:29.000Z</published>
    <updated>2020-01-12T19:20:08.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人作为一个信息学竞赛的参与者，在很久之前曾经试图自己写过一个Online Judge系统（允许用户上传源代码并在服务器上编译运行），考虑到安全因素，必须要对程序的行为进行限制，因此对ptrace进行了一番研究。网上有一份关于ptrace的很好的教程（<a href="http://www.kgdb.info/gdb/playing_with_ptrace_part_i/" target="_blank" rel="noopener">Playing with ptrace</a>）,但是时间有点久了，而且没有涉及64位操作系统。因此，我决定写这份教程，基于64位Linux，尽力介绍一些新加入的功能，同时兼顾一下32位系统。另外，由于一开始的目的是“对程序的行为进行<em>限制</em>”，所以不会涉及到诸如设置断点之类的内容，相反，可能会涉及到其他关于系统资源管理的内容。<br><code>ptrace()</code>是一个由Linux内核提供的系统调用。它允许一个用户态进程检查、修改另一个进程的内存和寄存器。这种技术被广泛用于<code>gdb</code>等调试器中。尽管这系列文章的标题叫做“Programming with PTRACE”，但在第一部分中，我将着重介绍Linux的进程和相关的几个重要函数。</p><h2 id="fork-vfork-与-clone"><a href="#fork-vfork-与-clone" class="headerlink" title="fork(), vfork() 与 clone()"></a>fork(), vfork() 与 clone()</h2><p>在Linux中，每一个进程都有一个唯一的编号，被称作<code>pid</code>(Process ID)。在Linux中，进程不能凭空产生（<code>init</code>进程是个例外），只能从一个已有进程衍生出来。原来的进程被称做父进程，衍生出来的进程叫子进程。一个系统中所有进程以父子关系相连接，形成一棵树，这棵“树”的树根就是<code>init</code>进程，它是在系统启动时被直接启动的，因此它没有父进程。并且系统中所有其他进程都直接或间接地是它的子进程。在Linux系统中，实现“把一个进程变成两个”这一功能的有三个系统调用，即<code>fork()</code>、<code>vfork()</code>和<code>clone()</code>。</p><p><code>fork()</code>的工作流程的确和叉子有几分相似之处，它将当前进程所有数据复制一份，产生一个和父进程一模一样的子进程。并在两个进程中返回不同的返回值。比如这段代码：</p><figure class="highlight c"><figcaption><span>demo1.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> return_val;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Program started."</span>);</span><br><span class="line">    return_val=fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork() returned %d\n"</span>,return_val);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将会输出</p><pre><code>Program started.fork() returned 5768fork() returned 0</code></pre><p>很明显地可以看到，<code>puts()</code>只被调用了一次而<code>printf()</code>被调用了两次，这说明在<code>fork()</code>前的一个进程变成了两个，而且<code>fork()</code>在两个进程中有不同的返回值（这就是“调用一次，返回两次”的来历）。<code>fork()</code>会返回0给子进程，返回子进程的pid给父进程，因此，我们很容易判断出<code>fork() returned 0</code>是由子进程打印的。在实际应用中，也通过<code>if</code>语句判断返回值的方法来决定执行不同的代码：</p><pre><code>int pid=fork();if (pid==0){  //子进程的工作}else{  //父进程的工作}</code></pre><p>一般来说，子进程的工作就是调用<code>exec</code>族函数，启动另一个程序(把自己替换掉)。如果子进程还在执行而父进程已结束，那么它就成为“孤儿”进程，成为<code>init</code>进程的子进程。另外，请不要纠结那个<code>if</code>判断带来的性能损失，Linux的内核开发者都不纠结，你纠结什么呢？</p><a id="more"></a><p><code>vfork()</code>的存在是一个历史遗留问题，在很久很久以前，<code>fork()</code>调用是没有<a href="http://en.wikipedia.org/wiki/Copy_on_write" target="_blank" rel="noopener">CoW</a>机制的，如果fork出的一个子进程又立即调用了<code>exec</code>族函数，那么辛辛苦苦拷贝出来的内存又立马被扔进了废纸篓里（这个比喻可能不太恰当，毕竟被从内存里抹去的数据是捡不回来的）。Linux的开发者当然不会允许效率如此低下的事情发生，于是他们创造出了<code>vfork()</code>。它和<code>fork()</code>最大的差别在于，vfork出的子进程，在执行<code>exec</code>族函数前和父进程<strong>共享同一块内存</strong>。也就是说，子进程对内存的修改也会体现在父进程上。只有当子进程执行了<code>exec</code>族函数，它才真正拥有一块属于自己的内存。这样就节省了<code>fork()</code>中那个无意义的内存拷贝。现在因为有了CoW，<code>fork()</code>和<code>vfork()</code>已经几乎没有性能差异了。</p><figure class="highlight c"><figcaption><span>demo2.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid,x=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"X=%d\n"</span>,x);</span><br><span class="line">    pid=vfork();</span><br><span class="line">    <span class="keyword">if</span> (pid==<span class="number">0</span>)&#123;</span><br><span class="line">        x+=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Child-X=%d\n"</span>,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        x+=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Parent-X=%d\n"</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码输出，而且一定输出</p><pre><code>X=1Child-X=2Parent-X=3</code></pre><p>很好地说明了内存的共享，如果换成<code>fork()</code>，那么父子进程就都输出X=2了。<br>也许有人会问，为什么不可能是父进程先输出呢？这涉及到<code>vfork()</code>的另一个特点。如果使用<code>vfork()</code>创建进程，那么在子进程使用<code>exec</code>族函数或是<code>_exit()</code>(这就是我为什么不用<code>return 0</code>的原因，但没有详细研究过原因，求大神指教)之前，父进程会始终等待vfork返回。比如以下代码：</p><figure class="highlight c"><figcaption><span>demo3.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    pid=vfork();</span><br><span class="line">    <span class="keyword">if</span> (pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Child Sleeping..."</span>);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Child Exit."</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Parent Exit."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><pre><code>Child Sleeping...//这里等了3秒Child Exit.Parent Exit.</code></pre><p>而改成<code>fork()</code>后输出</p><pre><code>Parent Exit.Child Sleeping...~$//这里等了3秒Child Exit.</code></pre><p>可以明显看出两者差别。(给Windows用户的Tip: 那个<code>~$</code>是Linux终端的提示符，类似cmd)</p><p><code>clone()</code>函数提供了更多的控制选项，可自由决定要执行哪个代码片段甚至是哪些内存共享，哪些内存要复制。但我没怎么用过，不敢乱说，有兴趣的读者可以自行实验。</p><h2 id="令人困惑的exec族函数"><a href="#令人困惑的exec族函数" class="headerlink" title="令人困惑的exec族函数"></a>令人困惑的exec族函数</h2><p>我在这篇文章之前的部分N次提到了一个叫<code>exec族函数</code>的东西，如果我们man手册里查找(<code>man 3 exec</code>)，我们会得到一大堆函数（是不是开始感到困惑了？）：</p><pre><code>int execl  (const char *path, const char *arg, ...);int execlp (const char *file, const char *arg, ...);int execle (const char *path, const char *arg, ..., char * const envp[]);int execv  (const char *path, char *const argv[]);int execve (const char *path, char *const argv[], char *const envp[]);int execvp (const char *file, char *const argv[]);int execvpe(const char *file, char *const argv[], char *const envp[]);</code></pre><p><code>exec族函数</code>就是这一“族”函数，全部以exec打头，他们都是对系统调用<code>execve()</code>的包装。他们的作用就是把某个进程（通常是fork出来的子进程）从里到外，完完整整，包括代码、堆栈，全部换成另一个程序，然后从头开始运行。它们的调用效果是一样的，区别在于调用方式。总的来说，大致的参数顺序是这样的：<code>exec*(可执行文件路径，程序参数表[,环境变量表])</code>，其中环境变量表是可选的。<br>去掉打头的exec，带<code>l</code>（代表list）的函数使用了一种比较接近人类方法来表示程序参数表，即以<code>NULL</code>作为结尾（man手册推荐使用<code>(char *)0</code>）的变参列表；而带<code>v</code>(代表vector)的则使用一个字符串数组来表示程序参数表，就像<code>int main(int argc,char *argv[])</code>里的<code>argv</code>一样。<br>如果结尾带<code>e</code>（environment），则该函数接受一个字符串数组表示的环境变量表；反之，则会默认传递所有当前环境变量。如果带有<code>p</code>，那么你就不必在第一个参数中列出完整路径，系统会自动检查当前目录和<code>PATH</code>环境变量（如果你非要手贱加个路径分割符进去，那么系统就会把它当成完整路径）。<br>值得一提的是，不管你使用那种方法表示程序参数表，第0个参数（C的数组下标从0开始，记得么？）都应当和可执行文件路径保持一致，虽然不一致依然可以正确运行，但有可能出现奇奇怪怪的问题。（博主继续偷懒，欢迎各位读者当小白鼠自行实验）。如果你已经混乱了，或是直接跳过了上面的一大堆说明直接到了这，那么我推荐你直接使用<code>execlp()</code>函数，比如说，你要运行一个叫<code>foo</code>的程序：</p><pre><code>execlp(&quot;foo&quot;,&quot;foo&quot;,NULL);</code></pre><p>或是列举出根目录下所有文件：</p><pre><code>execlp(&quot;ls&quot;,&quot;ls&quot;,&quot;/&quot;,NULL);</code></pre><h2 id="继续之前的其他一些准备"><a href="#继续之前的其他一些准备" class="headerlink" title="继续之前的其他一些准备"></a>继续之前的其他一些准备</h2><p>从本系列的下一篇开始，我将要开始讨论<code>ptraec()</code>这一强大的工具。但是，如果你有一下现象之一的，我建议你<em>不要</em>继续阅读并且从头学习有关<code>*nix</code>系列系统的知识：</p><ol><li>基本看不懂这篇文章的</li><li>不会C语言的</li><li>狂热的Windows爱好者</li><li>不会使用<a href="https://www.google.com" target="_blank" rel="noopener">Google</a>的</li><li>没有IDE就不会编译程序的</li><li>没有听说过<code>寄存器</code>，<code>堆栈</code>的</li></ol><p>另外，<code>ptrace()</code>相当接近系统底层，对内核版本，系统构架，指令长度，库头文件等有相当大的依赖性，如果你还在使用2.x系列的内核，你可能在之后遇到问题，因为一些功能在新版本内核才被加入。我在这里列出我的编程环境：</p><ul><li>系统: ArchLinux x86_64</li><li>内核: Linux 3.14.1</li><li>glibc 2.19</li><li>gcc 4.8.2</li></ul><p>另外，这里有更多关于进程的文章</p><ul><li><a href="http://www.cnblogs.com/vamei/archive/2012/09/20/2694466.html" target="_blank" rel="noopener">Linux进程基础</a> （我觉得其中关于食谱的那个比喻不太恰当，也许程序和进程的关系更像类和类的实例的关系？）</li><li><a href="http://www.ibm.com/developerworks/cn/linux/l-linux-process-management/" target="_blank" rel="noopener">Linux 进程管理剖析</a> (IBM developerWorks是我超喜欢的一个网站，有相当多高质量的文章)</li><li><a href="http://coolshell.cn/articles/656.html" target="_blank" rel="noopener">Linux 的僵尸(zombie)进程</a></li></ul>]]></content>
    
    <summary type="html">
    
      First part of serial of tutorial: Programming with PTRACE
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="PTRACE" scheme="https://recursiveg.me/tags/PTRACE/"/>
    
      <category term="教程" scheme="https://recursiveg.me/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>有屏幕的地方就有烂苹果</title>
    <link href="https://recursiveg.me/2014/03/bad-apple-character-player/"/>
    <id>https://recursiveg.me/2014/03/bad-apple-character-player/</id>
    <published>2014-03-19T11:55:49.000Z</published>
    <updated>2020-01-12T19:20:09.376Z</updated>
    
    <content type="html"><![CDATA[<p>如果你还不知道Bad Apple是什么东西，请移步<a href="http://zh.wikipedia.org/wiki/Bad_apple!!" target="_blank" rel="noopener">这里</a><br>播放的原理很简单，就是不停的打印清屏再打印清屏。任何一个略有编程基础的人都能做到。比较令人头大的是如何把原视频转化为一个易于解析而且又不占地方的文件。<br>其实，借助<code>FFmpeg</code>、<code>ImageMagick</code>和一点点的编程小技巧就可以轻松完成。</p><p>第一步当然是要去下一个视频文件，我已经下好了，叫做<code>BadApple.mkv</code>。</p><a id="more"></a><p>第二步要把视频变成一帧一帧的图片，请出FFmpeg来帮忙:</p><pre><code>ffmpeg -i BadApple.mkv -s 80x60 -r 15 Ba%d.png</code></pre><p>然后你就会得到<code>Ba1.png Ba2.png Ba3.png</code>等一大堆文件，这就是各帧了。注意我在这一步同时把大小缩小到了80*60和把帧速率调到了15帧每秒。</p><p>第三步用ImageMagick将图像转换成黑白图，然后再转换成<code>xpm</code>格式。XPM格式本质上是一个文本文档，可以直接被<code>#include</code>。我们这一步要用到一点点脚本技巧。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> *.png</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  convert <span class="variable">$x</span> -monochrome `basename -s .png <span class="variable">$x</span>`.xpm</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>最后写一段C语言小程序，利用游程编码进一步缩小文件体积。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;xpm.h&quot;</span><br><span class="line">void main()&#123;</span><br><span class="line">  FILE *f&#x3D;fopen(&quot;BA.dat&quot;,&quot;a&quot;);</span><br><span class="line">  char count;</span><br><span class="line">  int t&#x3D;ARR[0][6]&#x3D;&#x3D;&#39;1&#39;?1:2;</span><br><span class="line">  for(int i&#x3D;1+t;i&lt;61+t;i++)&#123;</span><br><span class="line">    count&#x3D;1;</span><br><span class="line">    for(int j&#x3D;1;j&lt;80;j++)&#123;</span><br><span class="line">      if(ARR[i][j]&#x3D;&#x3D;ARR[i][j-1])&#123;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        if(ARR[i][j]&#x3D;&#x3D;&#39;.&#39;)count&#x3D;-count;</span><br><span class="line">        fprintf(f,&quot;%c&quot;,count);</span><br><span class="line">        count&#x3D;1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ARR[i][79]&#x3D;&#x3D;&#39; &#39;)count&#x3D;-count;</span><br><span class="line">    fprintf(f,&quot;%c&quot;,count);</span><br><span class="line">    fprintf(f,&quot;%c&quot;,0);</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，离不了脚本和编译器的帮助，我这里使用了<code>tcc</code>进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (( i=1; i&lt;=3288; i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  cp Ba<span class="variable">$i</span>.xpm xpm.h</span><br><span class="line">  tcc -DARR=Ba<span class="variable">$i</span> bad_apple.c &amp;&amp; ./a.out</span><br><span class="line">  rm xpm.h</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>其中，那个3288就是总帧数。这样就得到了一个<code>BA.dat</code>文件。文件内容是一堆用二进制存储的数字，正数代表连续的白色，负数代表连续的黑色，零代表换行。一帧60行，总计3288帧。这样就把一个80多兆的视频压缩到了900多K。有了数据文件剩下的就好办了。</p><p><strong>未完待续。。。。。。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你还不知道Bad Apple是什么东西，请移步&lt;a href=&quot;http://zh.wikipedia.org/wiki/Bad_apple!!&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;&lt;br&gt;播放的原理很简单，就是不停的打印清屏再打印清屏。任何一个略有编程基础的人都能做到。比较令人头大的是如何把原视频转化为一个易于解析而且又不占地方的文件。&lt;br&gt;其实，借助&lt;code&gt;FFmpeg&lt;/code&gt;、&lt;code&gt;ImageMagick&lt;/code&gt;和一点点的编程小技巧就可以轻松完成。&lt;/p&gt;
&lt;p&gt;第一步当然是要去下一个视频文件，我已经下好了，叫做&lt;code&gt;BadApple.mkv&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="技术宅" scheme="https://recursiveg.me/tags/%E6%8A%80%E6%9C%AF%E5%AE%85/"/>
    
      <category term="东方Project" scheme="https://recursiveg.me/tags/%E4%B8%9C%E6%96%B9Project/"/>
    
  </entry>
  
  <entry>
    <title>在Linux下使用MinGW静态交叉编译带有zlib的libcurl</title>
    <link href="https://recursiveg.me/2014/02/how-to-cross-compile-libcurl-on-linux/"/>
    <id>https://recursiveg.me/2014/02/how-to-cross-compile-libcurl-on-linux/</id>
    <published>2014-02-28T13:17:41.000Z</published>
    <updated>2020-01-12T19:20:09.810Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://curl.haxx.se/" target="_blank" rel="noopener">libcurl</a>是一个跨平台的、易用的、强大的网络库。在大部分Linux发行版中都有编译好的二进制包可供使用，Mac系统更是将其作为了一个核心部件。但是在Windows平台上却需要手工编译，更不必说一些有特殊洁癖的人（比如说我）还特别讨厌多出来几个DLL,非要静态链接不可。本文作为我两个晚上折腾经历的一个小小总结，讲解如何在Linux下使用MinGW编译给Windows使用的libcurl静态库。</p><a id="more"></a><h3 id="STEP1-安装MinGW编译器"><a href="#STEP1-安装MinGW编译器" class="headerlink" title="STEP1 安装MinGW编译器"></a>STEP1 安装MinGW编译器</h3><p>这步我不打算多说，大部分Linux发行版的仓库应该都有，以我的ArchLinux为例，执行：</p><pre><code>~# pacman -S mingw-w64</code></pre><p>即可。如果你不需要交叉编译，要在Windows上直接编译，请自行去SourceForge上下载Windows版本。不要担心那个<code>w64</code>是不是64位版本，它既可以编译32位又可以编译64位程序。还是以我的版本为例:</p><pre><code>~# pacman -Ql mingw-w64-gcc| grep &apos;/usr/bin/.*gcc$&apos;mingw-w64-gcc /usr/bin/i686-w64-mingw32-gccmingw-w64-gcc /usr/bin/x86_64-w64-mingw32-gcc</code></pre><p>可以看到有两个gcc,用<code>i686-w64-mingw32-gcc</code>编译出来的程序就是32位的，而<code>x86_64-w64-mingw32-gcc</code>编译出来的就是64位的。现在，随便写个Hello World（你可以用我的<a href="/2012/12/helloworld/">Hello World代码</a> ^_^），然后编译试试：</p><pre><code>i686-w64-mingw32-gcc hello_world.c -o hello_world.exe</code></pre><p>把它拿到虚拟机或扔进Wine里，如果能正常运行，那么恭喜你，第一步完成了。</p><!--more--><h3 id="STEP2-下载源码"><a href="#STEP2-下载源码" class="headerlink" title="STEP2 下载源码"></a>STEP2 下载源码</h3><p>很简单的步骤，如果自己搞不定的建议直接右上角。</p><ul><li><a href="http://curl.haxx.se/download.html" target="_blank" rel="noopener">LibCurl</a>:最上面的Source Archives</li><li><a href="http://www.zlib.net/" target="_blank" rel="noopener">zLib</a>:请下Source Code</li><li><a href="https://www.openssl.org/source/" target="_blank" rel="noopener">OpenSSL</a>:可选，如果没有必要就不要编译，会极大地增加文件体积</li></ul><p>把<code>curl-7.35.0</code>和<code>zlib-1.2.8</code>(可能还有<code>openssl-1.0.1f</code>)这几个文件夹放在同一个目录下，然后进行下一步。</p><h3 id="STEP3-编译源码"><a href="#STEP3-编译源码" class="headerlink" title="STEP3 编译源码"></a>STEP3 编译源码</h3><p>先打开<code>zlib/win32</code>文件夹下的<code>Makefile.gcc</code>文件,把<code>PREFIX =</code>这行改成STEP1里的gcc前缀，对于我来说就是<code>PREFIX = i686-w64-mingw32-</code>。把这个文件拷贝到<code>zlib</code>文件夹下，然后在<code>zlib</code>文件夹下<code>make -f Makefile.gcc</code>，你就应该能看到<code>libz.a</code>这个文件了。</p><p>如果你要编译OpenSSL,那么就去openssl文件夹下</p><pre><code>$ ./Configure no-shared --cross-compile-prefix=i686-w64-mingw32- mingw$ make</code></pre><p>即可，记得改prefix。生成<code>libssl.a</code>和<code>libcrypto.a</code></p><p>最后去libcurl里的lib文件夹里修改<code>Makefile.m32</code>文件，在<code>CC    = $(CROSSPREFIX)gcc</code>上加一行<code>CROSSPREFIX=i686-w64-mingw32-</code>（请按需修改），然后把下面<code>CFLAGS</code>那行改成这样<code>CFLAGS    = -g -O2 -Wall -DCURL_DISABLE_LDAP</code>，最后</p><pre><code>make -f Makefile.m32 CFG=-zlib</code></pre><p>或是</p><pre><code>make -f Makefile.m32 CFG=-zlib-ssl</code></pre><p>make到最后时会报个错，是因为文件没放对地方，手动挪一下即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> vtls/openssl.o vtls/gtls.o vtls/vtls.o vtls/nss.o vtls/qssl.o vtls/polarssl.o vtls/polarssl_threadlock.o vtls/axtls.o vtls/cyassl.o vtls/curl_schannel.o vtls/curl_darwinssl.o vtls/gskit.o</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    mv `basename <span class="variable">$x</span>` vtls</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>然后再make一下，<code>libcurl.a</code>文件应该就出现了。<br>如果生成dll出错也不要紧，我们要的是<code>.a</code>文件</p><h3 id="STEP4-测试"><a href="#STEP4-测试" class="headerlink" title="STEP4 测试"></a>STEP4 测试</h3><p>现在，你可以找一段libcurl的demo来测试了。注意要加上宏定义<code>CURL_STATICLIB</code></p><pre><code>i686-w64-mingw32-gcc -I. -L. -DCURL_STATICLIB curl_demo.c -lcurl -lz -lws2_32 -o curl_demo.exe</code></pre><p>如果你因为不知道gcc<code>-I</code>和<code>-L</code>选项的用法而编译不过，请自行Google。如果你加了ssl支持，你需要链接更多的库，具体请根据错误信息自行Google。最后提醒一点:<strong>请把<code>-lcurl</code>选项放在源文件后面</strong>，我当初就是因为这个死活链接不过。最后把<code>curl_demo.exe</code>拖进虚拟机里，如果一切正常，那么恭喜你，你成功了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://curl.haxx.se/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;libcurl&lt;/a&gt;是一个跨平台的、易用的、强大的网络库。在大部分Linux发行版中都有编译好的二进制包可供使用，Mac系统更是将其作为了一个核心部件。但是在Windows平台上却需要手工编译，更不必说一些有特殊洁癖的人（比如说我）还特别讨厌多出来几个DLL,非要静态链接不可。本文作为我两个晚上折腾经历的一个小小总结，讲解如何在Linux下使用MinGW编译给Windows使用的libcurl静态库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="MinGW" scheme="https://recursiveg.me/tags/MinGW/"/>
    
      <category term="交叉编译" scheme="https://recursiveg.me/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>记一次坑爹的乱码解决过程</title>
    <link href="https://recursiveg.me/2014/02/clear-a-special-kind-of-messy-code/"/>
    <id>https://recursiveg.me/2014/02/clear-a-special-kind-of-messy-code/</id>
    <published>2014-02-08T06:12:59.000Z</published>
    <updated>2020-01-12T19:20:10.260Z</updated>
    
    <content type="html"><![CDATA[<p>某日，我在网上下载了一些音乐，然后打开，发现了乱码。Linux系统上出现乱码本不是什么好大惊小怪的事，但是，在经过N种方法来回折腾依然无法解决的情况下，我意识到，这大约是我见过的最奇葩的一种乱码了。先上图：<br><img src="/images/clear-a-special-kind-of-messy-code/1.png" alt="An Example of the Messy Code"></p><a id="more"></a><p>为了解释这个问题，我要先引入Python3中的字符串与字节序列的概念。在Python3中，一个字符串不存在‘编码类型’这种概念，每一个包含相同文字的字符串都是完全一样的(确切的讲,Python3中的字符串是以<a href="https://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">Unicode</a>编码的字节序列)。而字节序列和C中的char数组很像，它是字符串保存在文件系统上的真正形态。一个固定的字符串(即包含相同的文字)可以被编码(即Python中的<code>encode()</code>)成字节序列。如果对其使用不同的编码方式，生成的字节序列也不同。举个例子，一栋房子地面上的第一层，英国人叫它’ground floor’，而美国人叫它‘first floor’。这就是不同的编码方式。相反，解码(Python中的<code>decode()</code>)就是把一个字节序列变回字符串。在普通情况下，乱码是由于对一个字节序列使用了错误的编码方式进行解码，解码之后的内容自然无法阅读。就像一个英国人给一个美国人留了张便条，写着‘Meet me at first floor.’(二楼)，然后美国人去一楼转了半天都没找到。这种使用了错误的解码方式的问题一般是由于操作系统的默认设定造成的，比如Windows系统使用当地语言的编码(大陆GBK,台湾BIG5,日本SHIFT-JIS之类的)，而Linux普遍使用UTF-8编码。解决这种乱码的方法也很简单，你不是默认以UTF8方式解读么？而现在的字节序列又需要以GBK方式解读才能获得正确的内容，那么我们只要找到一个字节序列，让它被以UTF8解码时得到的内容和现在的字节序列被以GBK解码时得到的内容一样就行了。具体方法就是把当前的字节序列先以GBK解码，再以UTF-8编码，然后写回文件系统里，就搞定了。这个命令在Linux上就是<code>iconv -f GBK -t UTF-8</code>(记得加管道)。</p><p>但是，这次的乱码坑爹就坑爹在: 它的字节序列(字符串是以字节序列的形式保存在磁盘上的，还记得么？)无法以GBK方式解码，相反，它更像是一个根正苗红的UTF-8编码的字节序列。在多次尝试失败后，我开始无聊地“欣赏”乱码字符。注意到那些字符上的装饰了么？就是那些小点波浪尖角什么的？我也注意到了。然后我意识到，这是显著的西欧字符集的特征。也就是说，曾经有某个字节序列被以ISO-8859-1(一种西欧字符集)解码过一次，然后才表现出了现在的样子。那么，我们把现在的<strong>字符串</strong>用ISO-8859-1编码一次看看：<code>iconv -f UTF-8 -t ISO-8859-1</code>(因为我的系统的默认编码是UTF-8，所以需要‘-f UTF-8’)。然后得到了一坨问号，这正是GBK编码以UTF-8方式解码的结果，于是再接再厉：<code>iconv -f GBK -t UTF-8</code>。终于看到了熟悉的文字。最终，这个问题以两行命令被解决(因为是文件名乱码，所以用<code>convmv</code>命令)：</p><pre><code>convmv -f UTF-8 -t ISO-8859-1 --notest *convmv -f GBK -t UTF-8 --notest *</code></pre><p><strong>总结：</strong>这个乱码的产生原因也是对字节序列使用了错误的解码方式（对GBK字节序列使用ISO-8859-1解码），但是因为最终的字节序列是一个根正苗红的UTF-8编码，所以特别难以解决。这种问题特别容易发生在网络当中，比如，一个网站允许用户上传文件，因为一些原因，这个网站把所有的文件名都转成UTF-8存储，如果用户用西欧语言，那么这样就完全没关系，但如果一个中国用户上传了一个GBK文件名编码的文件，那么这种问题就发生了。</p><p>如果大家对排版或是图片之类的有什么意见建议请务必留言。<br><strong>做人要厚道，转载请注明出处</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;某日，我在网上下载了一些音乐，然后打开，发现了乱码。Linux系统上出现乱码本不是什么好大惊小怪的事，但是，在经过N种方法来回折腾依然无法解决的情况下，我意识到，这大约是我见过的最奇葩的一种乱码了。先上图：&lt;br&gt;&lt;img src=&quot;/images/clear-a-special-kind-of-messy-code/1.png&quot; alt=&quot;An Example of the Messy Code&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
      <category term="乱码" scheme="https://recursiveg.me/tags/%E4%B9%B1%E7%A0%81/"/>
    
      <category term="Python" scheme="https://recursiveg.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>网站从Octopress迁移至Hexo</title>
    <link href="https://recursiveg.me/2013/12/site-migration-complete/"/>
    <id>https://recursiveg.me/2013/12/site-migration-complete/</id>
    <published>2013-12-24T13:26:08.000Z</published>
    <updated>2020-01-12T19:01:21.744Z</updated>
    
    <content type="html"><![CDATA[<p>经过我两个小时的折腾，总算是重新把网站弄起来了。Ruby实在是坑爹，各种gem装得目录结构乱七八糟的……（强迫性人格障碍的典型表现）而且速度还慢……<br>曾尝试用Python和Tornado模板自己写一个静态页面生成器，然后发现我想多了。我果然还是不适合写UI……<br>一通Google之后，最终决定使用Hexo。它使用node.js(也就是javascript)作为编程语言(这样说恰当么？反正就是这个意思啦),据说速度极快。最重要的是，AUR源里有Hexo打好的包，能用pacman管理就是好。<br>主题试了一圈下来还是默认的Light看着最舒心。<strong>以后千万不能再手贱自己写主题了！！</strong><br>膜拜一下Hexo的作者tommy351。自己改了一下高亮配色和Widgets，把以前Octopress的Markdown文档做了一点点修改，这样就算上线了吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经过我两个小时的折腾，总算是重新把网站弄起来了。Ruby实在是坑爹，各种gem装得目录结构乱七八糟的……（强迫性人格障碍的典型表现）而且速度还慢……&lt;br&gt;曾尝试用Python和Tornado模板自己写一个静态页面生成器，然后发现我想多了。我果然还是不适合写UI……&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Hexo" scheme="https://recursiveg.me/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>通用存储及分布式文件共享系统的设想</title>
    <link href="https://recursiveg.me/2013/03/universal-storge/"/>
    <id>https://recursiveg.me/2013/03/universal-storge/</id>
    <published>2013-03-30T12:02:00.000Z</published>
    <updated>2020-01-12T19:01:22.228Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Update: 本计划已无限期暂停，在可预见的未来没有重启计划，如有需要资料的欢迎发邮件索取</strong></p><p>众所周知，网盘这东西对大众来说不可或缺，国内的在线存储服务也欣欣向荣。但是，由于各种原因，我们仍感到这些不能完全满足我们的要求。<br>比如各种限制、各种暂停分享、还有各种必须付钱才能用的VIP服务等。各大公司想挣钱无可非议，毕竟网络存储绝对是烧钱的主，但作为一个搞技术的人，决不能整天写登陆界面，对吧？<br>动机在<a href="/2013/01/data-structure-of-vdisk/">新浪微盘数据结构解析</a>中说了，在那之后我又研究了其他的网盘，萌生了这么一个设想。<br>简要的说，这个系统可以大大方便文件的传播与获取，延长资源的存活时间。</p><a id="more"></a><p>废话不多说，以下是我的构想：</p><ol><li>人肉解析各资源站链接协议，比如下载上传链接解析什么的。</li><li>写成模块，类库什么的，方便调用。</li><li>以统一的界面管理多处资源，进行下载、上传等。</li><li>以写成的库为基础，对资源进行自动管理，比如可以分块存储于不同的位置，或是创建多个备份等。</li><li>维护一个数据库，存储用户共享信息，实现全网资源搜索。其实，不仅文件可以是分布式的，数据库也可以是分布式的，技术细节正在努力构思中。</li><li>有条件的同学可以在自己的服务器上运行一个特殊的服务端，接受来自其他用户的请求，比如一些已被停止共享的文件的下载(比如115的VIP的离线下载功能)。</li></ol><p><strong>更多可能，任君想象</strong></p><p>可能你们已经注意到了，我尽可能的避免使用<code>网盘</code>这个字眼。没错，我的目标不仅是网盘，我还希望加入一些“只读”的资源，比如通过解析视频网站的地址来下载视频文件等。正如Bilibili所做的那样(不过也许他们有合作关系？)。<br>目前，统一管理界面正在书写中，使用Python3, 应该不久可以放出Alpha版和API。不过，最后，我要给大家浇盆冷水，<em>本计划仍处于设想阶段</em>，不要期望能瞬间完成。而且，我们需要考虑遭到封杀后的应对措施，以及如何保持协议更新后库的快速升级等问题。</p><p>PS：欢迎有兴趣和有能力的同学来信交流：<code>gzh.shadow@gmail.com</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Update: 本计划已无限期暂停，在可预见的未来没有重启计划，如有需要资料的欢迎发邮件索取&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;众所周知，网盘这东西对大众来说不可或缺，国内的在线存储服务也欣欣向荣。但是，由于各种原因，我们仍感到这些不能完全满足我们的要求。&lt;br&gt;比如各种限制、各种暂停分享、还有各种必须付钱才能用的VIP服务等。各大公司想挣钱无可非议，毕竟网络存储绝对是烧钱的主，但作为一个搞技术的人，决不能整天写登陆界面，对吧？&lt;br&gt;动机在&lt;a href=&quot;/2013/01/data-structure-of-vdisk/&quot;&gt;新浪微盘数据结构解析&lt;/a&gt;中说了，在那之后我又研究了其他的网盘，萌生了这么一个设想。&lt;br&gt;简要的说，这个系统可以大大方便文件的传播与获取，延长资源的存活时间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Black Technology" scheme="https://recursiveg.me/tags/Black-Technology/"/>
    
      <category term="网盘" scheme="https://recursiveg.me/tags/%E7%BD%91%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>Pascal中鲜为人知的那些技巧</title>
    <link href="https://recursiveg.me/2013/01/cheat-with-pascal/"/>
    <id>https://recursiveg.me/2013/01/cheat-with-pascal/</id>
    <published>2013-01-31T13:46:00.000Z</published>
    <updated>2020-01-12T19:20:10.706Z</updated>
    
    <content type="html"><![CDATA[<p>做为一个搞信息学竞赛这么长时间的人，再加上估计很快就要转C++了，我觉得我有必要留下一些关于Pascal语言的资料，于是就有了这篇文章。我只负责解释用法，对基础概念不了解的请自行Google。所有这篇文章里的东西应该都能在Free Pascal自带的文档里找到，我写出来是为了众多不喜欢看英文的同学们，如果你愿意自己去看一下，一定会收益匪浅。</p><h3 id="不同进制的表示"><a href="#不同进制的表示" class="headerlink" title="不同进制的表示"></a>不同进制的表示</h3><p>平时我们写的常量都是十进制数，但我们有时需要写一个比如十六进制数怎么办呢？我们当然可以手动计算一下，但还有更优雅的方法。</p><pre><code>writeln($Ff,#32,&amp;10,#32,%100);</code></pre><p>你觉得它会输出什么呢？它输出<code>255 8 4</code>!所以以<code>$</code>开头的是16进制数，<code>&amp;</code>开头的是8进制数，<code>%</code>开头的是二进制数。顺带一提的是，以<code>#</code>开头的数会转变成对应ASCII码的字符，其实它可以和前面的三个符号共同使用，即<code>#$20</code>和<code>#%100000</code>都代表了空格。</p><a id="more"></a><h3 id="函数内联"><a href="#函数内联" class="headerlink" title="函数内联"></a>函数内联</h3><p>关于内联的解释请自己找资料，写法如下：</p><pre><code>function foo(bar:Type):ReturnType;inline;</code></pre><p>即在函数头后加<code>inline;</code>即可。测试证明确实有效，不过建议只用于诸如<code>min</code>或<code>max</code>这种函数。</p><h3 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h3><p>Pascal也是支持重载的，甚至可以重载系统函数！演示如下：</p><pre><code>procedure sort(var a:TArray;l,r:longint);begin  ...end;procedure sort(var a:TArray;r:longint);begin  sort(a,1,r)end;</code></pre><p>这样，调用<code>sort(arr,top)</code>就相当于调用<code>sort(arr,1,top)</code>.</p><h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><p>是不是对写高精度时的<code>plus(a,b)</code>感到厌倦？是不是想换一种更帅的书写方式？没问题，操作符重载能满足你的愿望！它可以让你用<code>a+b</code>的形式对高精度进行计算！</p><pre><code>operator + (a,b:Type) c:Type;operator := (a:Type1) b:Type2;operator &gt; (a,b:Type) c:boolean;</code></pre><p>需要注意的是</p><ul><li>比较操作符的返回值只能是<code>Boolean</code></li><li>二元操作符和赋值操作符如果两端类型不同不能随意交换位置</li><li>重载后优先级不变</li></ul><p>为了解决不能随意交换位置的问题，你可以这样写：</p><pre><code>operator + (a:Type1;b:Type2)c:ReturnType;begin  ...end;operator + (a:Type2;b:Type1)c:ReturnType;begin  c:=b+aend;</code></pre><h3 id="想重载str-和val-？"><a href="#想重载str-和val-？" class="headerlink" title="想重载str()和val()？"></a>想重载str()和val()？</h3><p>看完前面的函数重载，你是不是迫不及待地想要重载<code>val()</code>和<code>str()</code>这两个你看着不爽很久的函数了？但是却发现不能调用系统原来的函数了，Pascal把它当成了递归！解决方法很简单，在要用原始系统函数的地方加上<code>system.</code>即可。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">str</span><span class="params">(x:longint)</span>:</span><span class="keyword">string</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="comment">//str(x,str)&lt;--This is completely wrong!</span></span><br><span class="line">  system.str(x,str);<span class="comment">//&lt;--This is the right form</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>担心数组太大爆内存？但心数组太小存不下？动态数组解除你的忧虑！主要操作如下：</p><ol><li><code>a:array of Type;</code>：变量声明。</li><li><code>setlength(a,length)</code>：设定数组下标，范围为<code>[0..length-1]</code>，会自动清零。</li><li><code>b:=a</code>:看上去像是赋值，但其实不是赋值，只是复制地址而已，因此对<code>b</code>的修改就是对<code>a</code>的修改。</li><li><code>c:=copy(a,0,length(a))</code>：这就是真正的赋值了！还记得<code>copy()</code>和<code>length()</code>函数么？现在它们可以用于动态数组了！</li><li><code>d:array of array of Type</code>:二维动态数组声明。</li><li><code>setlength(d,length1,length2)</code>:不解释。</li><li><code>a:=d[1]</code>:<code>a</code>是一维动态数组，对<code>a[x]</code>的修改就是对<code>d[1][x]</code>的修改。</li><li><code>copy(d[x],0,length(d[x]))</code>:取出第<code>x</code>个一维动态数组。</li><li>二维动态数组可以用<code>d[x,y]</code>的方式访问，也可以用<code>d[x][y]</code>的方式访问。</li></ol><h3 id="取地址操作符"><a href="#取地址操作符" class="headerlink" title="取地址操作符"></a>取地址操作符</h3><p>想用C语言中的<code>&amp;</code>操作符？在Pascal中它是<code>@</code>!估计某年的NOIP坑了不少人。</p><h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>你还在定义<code>text</code>类型么？你还在用查找替换功能批量替换你的<code>readln()</code>么？赶快试试这个！</p><pre><code>assign(input,&apos;foo.in&apos;);reset(input);assign(output,&apos;foo.out&apos;);rewrite(output);...close(input);close(output);</code></pre><p>再也不用担心输入输出了！</p><h3 id="用动态数组实现伪变参"><a href="#用动态数组实现伪变参" class="headerlink" title="用动态数组实现伪变参"></a>用动态数组实现伪变参</h3><p>是不是很羡慕C中<code>printf</code>的变参？是不是很羡慕<code>writeln</code>可以有好多好多参数？利用动态数组可以实现类似的功能！</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">average</span><span class="params">(arr:<span class="keyword">array</span> <span class="keyword">of</span> longint)</span>:</span>real;</span><br><span class="line"><span class="keyword">var</span> i:longint;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  average:=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> high(arr) <span class="keyword">do</span></span><br><span class="line">    average:=average+arr[i];</span><br><span class="line">  average:=average/length(arr)</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>请注意其中<code>high()</code>和<code>length()</code>的区别。合法调用如下：</p><pre><code>var A:array[1..MAX]of longint;average([3]);average([1,2,3,4]);average(A);average(A[1..5]);</code></pre><h3 id="函数也是变量？！"><a href="#函数也是变量？！" class="headerlink" title="函数也是变量？！"></a>函数也是变量？！</h3><p>或许你对C++中的<code>sort()</code>已有所耳闻，或许你已经知道，它的比较函数是做为参数传进去的。配合<code>@</code>操作符，Pascal可以做到相同的效果。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TMyCompareFunc=<span class="function"><span class="keyword">Function</span><span class="params">(a,b:MyType)</span>:</span>boolean;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">largerthan</span><span class="params">(a,b:MyType)</span>:</span>boolean;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">sort</span><span class="params">(<span class="keyword">var</span> a:<span class="keyword">array</span> <span class="keyword">of</span> MyType;l,r:longint;f:TMyCompareFunc)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//Use `f(a[x],a[y])` to compare</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">compare(arr,<span class="number">1</span>,max,@largerthan);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><p>既然是变量，就能互相赋值，但是请注意：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TNoArgFunc=<span class="function"><span class="keyword">Function</span><span class="params">()</span>:</span>integer;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">  F:TNoArgFunc;</span><br><span class="line">  N:integer;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyFunc</span><span class="params">()</span>:</span>integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  MyFunc:=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">F:=MyFunc; <span class="comment">//F()成为MyFunc()的别名</span></span><br><span class="line">N:=MyFunc; <span class="comment">//N被赋值为3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//if F=MyFunc then</span></span><br><span class="line"><span class="comment">//  writeln('You will never see this');</span></span><br><span class="line"><span class="comment">//这个判断将导致`类型不匹配`编译错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> F=@MyFunc <span class="keyword">then</span></span><br><span class="line">  writeln(<span class="string">'这是同一个函数'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> F()=MyFunc <span class="keyword">then</span></span><br><span class="line">  writeln(<span class="string">'这两个函数的返回值相同'</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h3 id="C风格的操作符"><a href="#C风格的操作符" class="headerlink" title="C风格的操作符"></a>C风格的操作符</h3><p>我就不多介绍了<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>…考试时先试试能不能用。使用有风险，偷懒须谨慎。</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>知道C中的<code>(int)a</code>或是<code>int(a)</code>么？不知道没关系，Pascal中的强制类型转换是这样写的<code>TypeIdentifier(Variable)</code>。下面给几个例子：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntPtr=^integer;</span><br><span class="line">IntVal:=<span class="number">97</span>;</span><br><span class="line">RealVal:=<span class="number">3.7</span>;</span><br><span class="line">longint(IntVal);<span class="comment">//长版的IntVal</span></span><br><span class="line">real(IntVal);<span class="comment">//实数版IntVal，效果和赋值一样</span></span><br><span class="line">pointer(IntVal);<span class="comment">//一个指向内存地址97的无类型指针</span></span><br><span class="line">IntPtr(IntVal);<span class="comment">//一个指向内存地址97的Integer指针</span></span><br><span class="line">longint(@IntVal);<span class="comment">//IntVal地址的Longint版。注意，它是一个数，所以可以用writeln()输出</span></span><br><span class="line">writeln(IntPtr(@RealVal)^);<span class="comment">//你可以猜猜这句话输出什么（写程序时请绝对不要这么做）</span></span><br></pre></td></tr></table></figure><h3 id="无类型变量与无类型指针"><a href="#无类型变量与无类型指针" class="headerlink" title="无类型变量与无类型指针"></a>无类型变量与无类型指针</h3><p>标题写着<code>无类型变量</code>，其实应该叫做<code>多类型变量</code>更准确。他的主要工作原理就是在内部进行类型转换，因此效率极其低下，占用空间还特别大，连官方手册都不建议用。类型名为<code>Variant</code>。<br>无类型指针就是上一节提到的<code>Pointer</code>了。任何指针都可以赋值给它，它也可以赋值给任何指针，例子如下：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">  p:pointer;</span><br><span class="line">  r:real;</span><br><span class="line">  i:^integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  r:=<span class="number">3.7</span>;</span><br><span class="line">  p:=@r;</span><br><span class="line">  i:=p;</span><br><span class="line">  writeln(i^);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><p>看出来了么？这段文字和上一段的最后一句话等效。</p><h3 id="这玩意儿是类？！"><a href="#这玩意儿是类？！" class="headerlink" title="这玩意儿是类？！"></a>这玩意儿是类？！</h3><p>这是我最近才看到的一种写法，从来没用过。有愿意尝试的请自行研究。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span></span><br><span class="line">  TGetSum=<span class="keyword">object</span></span><br><span class="line">  a,b:longint;</span><br><span class="line">  <span class="function"><span class="keyword">procedure</span> <span class="title">Init</span><span class="params">(x,y:longint)</span>;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">GetSum</span><span class="params">()</span>:</span>longint;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">TGetSum</span>.<span class="title">Init</span><span class="params">(x,y:longint)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  a:=x;b:=y;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TGetSum</span>.<span class="title">GetSum</span><span class="params">()</span>:</span>longint;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  GetSum:=a+b;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">  sum:TGetSum;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  sum.Init(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">  writeln(sum.GetSum())</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><p>关于Object Pascal,推荐一本书:<a href="http://code-sd.com/books/startprog/" target="_blank" rel="noopener">Start Programming Using Object Pascal</a></p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>Pascal是不少OIer最开始使用的一种语言，仅以此文献给众多正在使用和曾经使用过Pascal的OIer。<br><strong>做人要厚道，转载请注明出处！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做为一个搞信息学竞赛这么长时间的人，再加上估计很快就要转C++了，我觉得我有必要留下一些关于Pascal语言的资料，于是就有了这篇文章。我只负责解释用法，对基础概念不了解的请自行Google。所有这篇文章里的东西应该都能在Free Pascal自带的文档里找到，我写出来是为了众多不喜欢看英文的同学们，如果你愿意自己去看一下，一定会收益匪浅。&lt;/p&gt;
&lt;h3 id=&quot;不同进制的表示&quot;&gt;&lt;a href=&quot;#不同进制的表示&quot; class=&quot;headerlink&quot; title=&quot;不同进制的表示&quot;&gt;&lt;/a&gt;不同进制的表示&lt;/h3&gt;&lt;p&gt;平时我们写的常量都是十进制数，但我们有时需要写一个比如十六进制数怎么办呢？我们当然可以手动计算一下，但还有更优雅的方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;writeln($Ff,#32,&amp;amp;10,#32,%100);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你觉得它会输出什么呢？它输出&lt;code&gt;255 8 4&lt;/code&gt;!所以以&lt;code&gt;$&lt;/code&gt;开头的是16进制数，&lt;code&gt;&amp;amp;&lt;/code&gt;开头的是8进制数，&lt;code&gt;%&lt;/code&gt;开头的是二进制数。顺带一提的是，以&lt;code&gt;#&lt;/code&gt;开头的数会转变成对应ASCII码的字符，其实它可以和前面的三个符号共同使用，即&lt;code&gt;#$20&lt;/code&gt;和&lt;code&gt;#%100000&lt;/code&gt;都代表了空格。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Pascal" scheme="https://recursiveg.me/tags/Pascal/"/>
    
      <category term="ACM" scheme="https://recursiveg.me/tags/ACM/"/>
    
      <category term="编程" scheme="https://recursiveg.me/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>新浪微盘数据结构解析</title>
    <link href="https://recursiveg.me/2013/01/data-structure-of-vdisk/"/>
    <id>https://recursiveg.me/2013/01/data-structure-of-vdisk/</id>
    <published>2013-01-27T14:00:00.000Z</published>
    <updated>2020-01-12T19:01:23.194Z</updated>
    
    <content type="html"><![CDATA[<p><em>注意!这个是<a href="http://vdisk.weibo.com" target="_blank" rel="noopener">微盘</a>而不是<a href="http://www.vdisk.cn" target="_blank" rel="noopener">威盘</a></em><br>研究这个问题的起因是有一次我需要从微盘上批量下载一堆文件。做为一个会写程序的人，我怎么能亲自做如此ugly的工作呢？这种事情当然要交给电脑做了！为了做到自动获取文件连接，于是就不得不研究这个问题了。</p><a id="more"></a><h3 id="用户的登录"><a href="#用户的登录" class="headerlink" title="用户的登录"></a>用户的登录</h3><p>微盘内部使用一个叫做<code>gsid</code>的值来识别用户。具体获取方法如下：</p><ol><li>URL:<code>http://vdisk.weibo.com/wap_auth</code>。</li><li>POST参数 <code>username</code>:用户名</li><li>POST参数 <code>password</code>:用户密码</li><li>返回数据：JSON字符串。Example:<code>{ &quot;message&quot;: &quot;/?gsid=...&quot;}</code>。其中<code>...</code>的部分就是<code>gsid</code></li></ol><h3 id="文件信息的获取"><a href="#文件信息的获取" class="headerlink" title="文件信息的获取"></a>文件信息的获取</h3><p>得到<code>gsid</code>后，就可以用来下载文件了。当然，要先得到下载连接。</p><ol><li>URL：<code>http://vdisk.weibo.com/share/ajaxFileinfo</code></li><li>GET参数 <code>fid</code>：文件ID</li><li>Cookie参数 <code>gsid</code>:GSID</li><li>浏览器标识(UA):需要设置为移动设备</li><li>返回数据：JSON字符串。    Example:</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"id"</span>:<span class="string">"406458665"</span>,<span class="attr">"name"</span>:<span class="string">"\u5fae\u535a\u5c01\u9762\u80cc\u666f.zip"</span>,<span class="attr">"uid"</span>:<span class="string">"60999569"</span>,<span class="attr">"dir_id"</span>:<span class="string">"0"</span>,<span class="attr">"ctime"</span>:<span class="string">"1358820088"</span>,<span class="attr">"ltime"</span>:<span class="string">"1358820088"</span>,<span class="attr">"dtime"</span>:<span class="string">"0"</span>,<span class="attr">"size"</span>:<span class="string">"1662111"</span>,<span class="attr">"is_locked"</span>:<span class="string">"0"</span>,<span class="attr">"type"</span>:<span class="string">"application\/x-zip"</span>,<span class="attr">"md5"</span>:<span class="string">"9e8eec4a5d2d3ac5be41bb9f34dc3e40"</span>,<span class="attr">"sha1"</span>:<span class="string">"6e59853b198e3eae818d5b0756f47c34d4eae6df"</span>,<span class="attr">"w"</span>:<span class="string">"0"</span>,<span class="attr">"h"</span>:<span class="string">"0"</span>,<span class="attr">"hid"</span>:<span class="string">"0"</span>,<span class="attr">"status"</span>:<span class="string">"1"</span>,<span class="attr">"app_key"</span>:<span class="string">"139204333"</span>,<span class="attr">"source"</span>:<span class="string">"2"</span>,<span class="attr">"ip"</span>:<span class="string">"0"</span>,<span class="attr">"rev_id"</span>:<span class="string">"140316098"</span>,<span class="attr">"share_status"</span>:<span class="string">"0"</span>,<span class="attr">"share"</span>:<span class="number">-1</span>,<span class="attr">"s3_url"</span>:<span class="string">"http:\/\/file.data.vdisk.me\/61099569\/6e59853b198e3eae818d5b0756f47c34d4eae6df?ip=1358945643,10.75.7.27&amp;ssig=o9x4sQ9tz6&amp;Expires=1358944443&amp;KID=sae,l30zoo1wmz&amp;fn=%E5%BE%AE%E5%8D%9A%E5%B0%81%E9%9D%A2%E8%83%8C%E6%99%AF.zip"</span>,<span class="attr">"url"</span>:<span class="string">"http:\/\/vdisk.weibo.com\/s\/oex4F"</span>,<span class="attr">"byte"</span>:<span class="string">"1662111"</span>,<span class="attr">"length"</span>:<span class="string">"1662111"</span>&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>s3_url</code>就是下载地址了。顺带一提，从<code>http://vdisk.weibo.com/file/info?fid=...</code>也可以得到文件信息，需要Cookie:<code>gsid</code>，但似乎不是所有文件都能成功得到信息。</p><h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><p>从上一步得到了URL就可以下载了。</p><ol><li>URL：<code>s3_url</code></li><li>Cookie参数 <code>gsid</code>：GSID</li></ol><p>需要注意的是，这个URL可能会有很多<code>302 Redirection</code>，可能是出于负载平衡的原因吧。</p><h3 id="fid与fid64"><a href="#fid与fid64" class="headerlink" title="fid与fid64"></a>fid与fid64</h3><p>平时我们下载都是用<code>http://vdisk.weibo.com/s/aMVfa</code>这种形式的短链接，其中<code>aMVfa</code>就是fid64,说白了就是64进制表示的fid，其0～63对应如下：</p><pre><code>0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-</code></pre><p>因此，<code>aR_8-</code>解码后就是<code>181920319</code></p><h3 id="文件列表的获取"><a href="#文件列表的获取" class="headerlink" title="文件列表的获取"></a>文件列表的获取</h3><p>研究完上文所提到的东西后，应该就可以进行文件批量下载了。但做为一个上进的好青年，我们不会止步与此。为了能够方便地管理自己的文件夹，当然要做进一步研究。</p><ol><li>URL：<code>http://vdisk.weibo.com/dir/list</code></li><li>GET参数 <code>dir_id</code>：Directionary ID</li><li>Cookie参数 <code>gsid</code>：GSID</li><li>浏览器标识(UA):需要设置为移动设备</li><li>返回数据：JSON字符串。其中<code>dirinfo</code>中的<code>dir_num</code>和<code>file_num</code>分别储存了在这个文件夹下有多少个目录和多少个文件。<code>data</code>段是一个数组，每个元素都代表了一个文件或目录，其中保存了<code>fid</code>或是<code>dir_id</code>。通过是否有<code>type</code>段来判断具体是文件还是目录。</li></ol><p>用户根文件夹的<code>dir_id</code>是<code>0</code></p><h3 id="Cookie与浏览器标识-UA"><a href="#Cookie与浏览器标识-UA" class="headerlink" title="Cookie与浏览器标识(UA)"></a>Cookie与浏览器标识(UA)</h3><p>似乎所有的链接都可以通过在Cookie中加入<code>device=mobile</code>来跳过UA检查。(就是说不用设置UA了)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;注意!这个是&lt;a href=&quot;http://vdisk.weibo.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微盘&lt;/a&gt;而不是&lt;a href=&quot;http://www.vdisk.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;威盘&lt;/a&gt;&lt;/em&gt;&lt;br&gt;研究这个问题的起因是有一次我需要从微盘上批量下载一堆文件。做为一个会写程序的人，我怎么能亲自做如此ugly的工作呢？这种事情当然要交给电脑做了！为了做到自动获取文件连接，于是就不得不研究这个问题了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Black Technology" scheme="https://recursiveg.me/tags/Black-Technology/"/>
    
      <category term="网盘" scheme="https://recursiveg.me/tags/%E7%BD%91%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>公钥加密</title>
    <link href="https://recursiveg.me/2012/12/public-key-cryptography/"/>
    <id>https://recursiveg.me/2012/12/public-key-cryptography/</id>
    <published>2012-12-31T13:02:00.000Z</published>
    <updated>2020-01-12T18:58:51.351Z</updated>
    
    <content type="html"><![CDATA[<p>各种加密方法大体可以分成两类，一类是对称加密，另一类是非对称加密。</p><p>凯撒密码是对称加密中的一种，他的加密方法是把A变成B，把B变成C，于是解密的时候只要把字母替换回来就行了。也就是说，任何知道加密方法的人就可以解密。</p><p>RSA是一种非对称加密算法，他的特点是任何人都可以加密，但只有我可以解密。做个比喻，人人都可以把锁头扣上，但只有拥有钥匙的人可以开锁。这个分发出去的用于加密的东西叫做公钥，也被称作证书。而留在自己身边的“钥匙”就是私钥，是绝对不能被第二个人拿到的。</p><p>于是乎，你可以把公钥发给别人，别人把数据用你的公钥加密后传给你，你用私钥解密后阅读。在这个过程中，任何人截取到数据都是无效的，因为它没有你的私钥。</p><p>RSA还有一个特点，就是可以用私钥加密，用公钥解密。你会问，公钥人人都能拿到，相当于人人都能解密，那这样加密有什么意义呢？意义在于，它可以作为身份验证。用私钥加密的过程叫签名，而验证签名就是用对应的公钥解密。因为为只有用对应的私钥签名的文件才能用公钥解密，既然它可以用公钥解密，就一定是由对应私钥签署的，而私钥只有你有，于是这份文件就一定是你发布的。网络上的HTTPS就是依靠着个。一般来说，用私钥加密的都是MD5、SHA1 之类的，加密原文太耗系统资源。</p><p>对付这种非对称的加密方式，有一种叫做“中间人攻击”的攻击方法，它会使双方之间的通信完全暴露。我就偷懒不写了，大家自己找资料。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;各种加密方法大体可以分成两类，一类是对称加密，另一类是非对称加密。&lt;/p&gt;
&lt;p&gt;凯撒密码是对称加密中的一种，他的加密方法是把A变成B，把B变成C，于是解密的时候只要把字母替换回来就行了。也就是说，任何知道加密方法的人就可以解密。&lt;/p&gt;
&lt;p&gt;RSA是一种非对称加密算法，
      
    
    </summary>
    
    
      <category term="Mathematics" scheme="https://recursiveg.me/categories/Mathematics/"/>
    
    
      <category term="加密" scheme="https://recursiveg.me/tags/%E5%8A%A0%E5%AF%86/"/>
    
      <category term="RSA" scheme="https://recursiveg.me/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>Sync with iDevice on Linux</title>
    <link href="https://recursiveg.me/2012/12/sync-with-idevice-on-linux/"/>
    <id>https://recursiveg.me/2012/12/sync-with-idevice-on-linux/</id>
    <published>2012-12-31T13:01:00.000Z</published>
    <updated>2020-01-12T19:01:23.694Z</updated>
    
    <content type="html"><![CDATA[<p>It’s a bit hard to connect an iDevice with Linux because Apple is not so open and we have to use iTunes to sync with our iDevice for a long time. Luckily we now have a set of tool so that we can control our device on linux. The most important two library are <a href="http://www.libimobiledevice.org/" target="_blank" rel="noopener">libimobiledevice</a>(libiphone) and libgpod.</p><p>libimobiledevice, like it’s name, is a library who provides the interface to access the iDevice. It provides a higher level of access such as photo, bookmark, install/uninstall softwares and even sync music. And it doesn’t need jailbreak.</p><p>What I want to mention is how musics synchronized with an iDevice. Under the iTunes folder (You may never seen that before. That’s ordinary.), there’s a file called iTunesDB. That’s the file which libgpod really works with. This file contains the name of songs, singers’ names, your play lists and so on. Unfortunately, because Apple don’t want it be modified by any programs except iTunes, they add some hash info into the file. If iPod found the hash is incorrect, it refused to display the songs. There was once a project called iPodHash, but it seems to be die due to a DMCA notice. Apple engineers have changed the hash algorithm for several times and the latest version haven’t been reverse-engineering, as a result, now we can only sync with a old version of iOS.</p><p>If your iDevice is jailbreaked, you can change a key called DBVersion(Sorry, I forgot where it is.). It tells iPod which version of hash algorithm it should use so we could use a known hash on new iOS. This process depends on libimobiledevice too. It only support to sync with iOS 4 or older. That means it’s useless even if you changed DBVersion on your iOS5 device. By the way, you may will not find a iTunesDB file but a iTunesCDB instead. It’s a compressed version of iTunesDB using zlib.</p><p>I feel so sad that such a project is closed and now I can only sync with my iPod on Windows.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;It’s a bit hard to connect an iDevice with Linux because Apple is not so open and we have to use iTunes to sync with our iDevice for a lo
      
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Written In English" scheme="https://recursiveg.me/tags/Written-In-English/"/>
    
      <category term="iDevice" scheme="https://recursiveg.me/tags/iDevice/"/>
    
      <category term="Linux" scheme="https://recursiveg.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>How to solve the &quot;Connection Reset&quot; problem</title>
    <link href="https://recursiveg.me/2012/12/how-to-solve-the-connection-reset-problem/"/>
    <id>https://recursiveg.me/2012/12/how-to-solve-the-connection-reset-problem/</id>
    <published>2012-12-31T12:50:00.000Z</published>
    <updated>2020-01-12T19:01:24.174Z</updated>
    
    <content type="html"><![CDATA[<p>考虑到安全原因，这篇文章用英语写成。如果你没有足够的勇气读完它，请自觉退出。</p><p>This article is written mainly for those people in China. Be sure you are enough familiar with what you are reading and what you try to do.</p><p>================================================================</p><p>As we all known, in China mainland, we cannot visit sites like YouTube Facebook Twitter. And the Google sites are out of service frequently. It’s because the Chinese government used some technical methods to prevent us from visiting them. The government has setup a system to do this. It’s called the <a href="https://en.wikipedia.org/wiki/Great_Firewall" target="_blank" rel="noopener">Great Firewall of China</a> (GFW). This system keeps look on the gateway export. And if it finds something unusual. It will stop the connection.</p><p>The system usually inject a RESET into the TCP connection. To prevent this, we can use HTTPS(The S means Secure) instead of HTTP. So the system can not inject the RESET any more. It’s easy to perform. You just need to replace the “http://“ part of a URL with “https://“. And the URL will look like this “<a href="https://www.facebook.com&quot;" target="_blank" rel="noopener">https://www.facebook.com&quot;</a>. Most of the sites support a HTTPS connection.</p><p>Unfortunately, this will not always works. Because the system also used another method called “DNS Redirection”. As we all known, the computers on the Internet are identified by IP address. But human can’t remember them easily. So we use some meaningful phases called “Domain”. Some computers on the Internet provide the kind of service to translate the domains to IP address which is the only form computers can recognize. They are called the “DNS Server”. DNS Redirection is that the DNS servers won’t return the correct IP address (usually were instructed to do so) so that we can’t visit the particular sites.</p><p>Luckily, we can assign an IP to a domain manually. That’s the function of a file called <a href="https://en.wikipedia.org/wiki/Hosts_(file)" target="_blank" rel="noopener">hosts</a>. There’s a project called <a href="https://code.google.com/p/smarthosts/" target="_blank" rel="noopener">smarthosts</a> on Google Code. It provided a set of IP address you may use. Paste them to your local hosts file and enjoy the Internet.</p><p>I will write more about the Internet censorship and how to avoid it. Check back later.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;考虑到安全原因，这篇文章用英语写成。如果你没有足够的勇气读完它，请自觉退出。&lt;/p&gt;
&lt;p&gt;This article is written mainly for those people in China. Be sure you are enough familiar w
      
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Written In English" scheme="https://recursiveg.me/tags/Written-In-English/"/>
    
      <category term="Black Technology" scheme="https://recursiveg.me/tags/Black-Technology/"/>
    
      <category term="GFW" scheme="https://recursiveg.me/tags/GFW/"/>
    
  </entry>
  
  <entry>
    <title>Hello, World!</title>
    <link href="https://recursiveg.me/2012/12/helloworld/"/>
    <id>https://recursiveg.me/2012/12/helloworld/</id>
    <published>2012-12-22T12:32:00.000Z</published>
    <updated>2020-01-12T19:01:24.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A-standard-“Hello-World-”-page"><a href="#A-standard-“Hello-World-”-page" class="headerlink" title="A standard “Hello World!” page"></a>A standard “Hello World!” page</h2><h2 id="你好世界。"><a href="#你好世界。" class="headerlink" title="你好世界。"></a>你好世界。</h2><figure class="highlight delphi"><figcaption><span>hello_world.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> Hello_World;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  writeln(<span class="string">'Hello World!'</span>);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight c"><figcaption><span>hello_world.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>hello_world.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello World!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>hello_world.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"Hello World!"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>hello_world.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello_world</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;A-standard-“Hello-World-”-page&quot;&gt;&lt;a href=&quot;#A-standard-“Hello-World-”-page&quot; class=&quot;headerlink&quot; title=&quot;A standard “Hello World!” page&quot;&gt;&lt;/a&gt;A standard “Hello World!” page&lt;/h2&gt;&lt;h2 id=&quot;你好世界。&quot;&gt;&lt;a href=&quot;#你好世界。&quot; class=&quot;headerlink&quot; title=&quot;你好世界。&quot;&gt;&lt;/a&gt;你好世界。&lt;/h2&gt;&lt;figure class=&quot;highlight delphi&quot;&gt;&lt;figcaption&gt;&lt;span&gt;hello_world.pas&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;program&lt;/span&gt; Hello_World;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  writeln(&lt;span class=&quot;string&quot;&gt;&#39;Hello World!&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://recursiveg.me/categories/Programming/"/>
    
    
      <category term="Site Management" scheme="https://recursiveg.me/tags/Site-Management/"/>
    
      <category term="Hello World!" scheme="https://recursiveg.me/tags/Hello-World/"/>
    
  </entry>
  
</feed>
